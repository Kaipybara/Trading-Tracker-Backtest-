<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Trading Tracker 13.6</title> 

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- JSZip for bundle export/import -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    :root{
      --bg:#0f1222;
      --bg-soft:#171a2d;
      --card:#1d2140;
      --card-2:#1a1e3a;
      --text:#e7e9f0;
      --muted:#9aa1c6;
      --line:#2b315d;
      --green:#35cc7a;
      --red:#ff5a6b;
      --amber:#ffc857;
      --blue:#4ea1ff;
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:12px;
      --gap:16px;
      --block-gap:22px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:
        radial-gradient(1200px 1200px at 80% -20%, #3f3cbb22 0%, transparent 60%),
        radial-gradient(1200px 1200px at -10% 120%, #4ea1ff22 0%, transparent 60%),
        var(--bg);
      color:var(--text);
      font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Inter, system-ui, Avenir, "Helvetica Neue", Arial, "Noto Sans";
      line-height:1.35;
    }

    /* ---------- Top App Bar ---------- */
    .appbar{
      position:sticky; top:0; z-index:40;
      backdrop-filter:saturate(120%) blur(12px);
      background:rgba(15,18,34,.7);
      border-bottom:1px solid var(--line);
    }
    .appbar-inner{
      max-width:1300px; margin:0 auto; padding:12px 16px;
      display:flex; gap:12px; align-items:center; flex-wrap:wrap;
    }
    .brand{font-weight:700; letter-spacing:.2px; font-size:18px; margin-right:auto; display:flex; align-items:center; gap:10px}
    .brand small{color:var(--muted); font-weight:500}

    /* New: second-row layout for tabs + actions */
    .controls-row{ width:100%; display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:10px; }
    .controls-row .left{ display:flex; align-items:center; gap:10px; }

    .seg{
      display:inline-flex; background:var(--card); border:1px solid var(--line); border-radius:999px; overflow:hidden;
    }
    .seg button{
      padding:8px 14px; border:0; background:transparent; color:var(--muted); cursor:pointer; font-weight:700;
    }
    .seg button.active{background:var(--blue); color:white}

    .btn{
      border:0; background:var(--card-2); color:var(--text); padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:700; box-shadow:var(--shadow);
    }
    .btn:active{transform:translateY(1px)}
    .btn.blue{background:linear-gradient(180deg, #4ea1ff, #277ae3)}
    .btn.soft{background:var(--card); border:1px solid var(--line); box-shadow:none; color:var(--muted); font-weight:600}
    .btn.green{background:linear-gradient(180deg, #27be69, #149a53)}
    .btn.red{background:linear-gradient(180deg, #ff5a6b, #d93c4f)}
    .btn.yellow{background:linear-gradient(180deg, #ffc857, #e0a300)}
    .btn.big{width:100%; padding:14px 16px; font-size:18px; font-weight:900; border-radius:12px;}

    .toolbar{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .kbd{padding:2px 6px; border:1px solid var(--line); border-bottom-width:2px; background:var(--bg-soft); border-radius:6px; color:var(--muted); font-size:12px}

    input, select, textarea{
      background:var(--bg-soft); border:1px solid var(--line); color:var(--text); border-radius:8px; padding:8px 10px; outline:none; min-height:36px;
    }
    label{color:var(--muted); font-size:12px}
    
    /* Tag popover (replaces bulky multi-selects) */
    .tag-picker{ position:relative; min-width:160px; }
    .tag-btn{ min-width:140px; background:var(--bg-soft); border:1px solid var(--line); color:var(--text); }
    .tag-btn .count{ margin-left:6px; padding:1px 6px; border-radius:999px; background:#2a2f57; color:#cfd2e6; font-size:11px; }
    .tag-popover{
      position:absolute; left:0; top:100%; margin-top:8px; width:min(320px, 72vw);
      background:var(--card); border:1px solid var(--line); border-radius:12px; box-shadow:var(--shadow); z-index:50;
      padding:10px; display:none;
    }
    .tag-popover.show{ display:block; }
    .tag-popover .search{ width:100%; margin-bottom:8px }
    .tag-popover .list{ max-height:220px; overflow:auto; border:1px dashed #2b315d; border-radius:8px; padding:6px; }
    .tag-popover .list label{ display:flex; align-items:center; gap:8px; padding:6px 4px; cursor:pointer; }
    .tag-popover footer{ display:flex; gap:8px; justify-content:flex-end; margin-top:8px }
    .tag-mode{ display:flex; gap:12px; align-items:center; margin-top:6px }

    /* ---------- Page ---------- */
    .shell{max-width:1300px; margin:0 auto; padding:18px 16px 80px}
    .tabcontent{display:none; margin-top:16px}
    .tabcontent.active{display:block; animation:fade .25s ease}
    @keyframes fade{from{opacity:0; transform:translateY(8px)} to{opacity:1; transform:translateY(0)}}

    .grid{display:grid; gap:var(--gap)}
    .grid.cols-2{grid-template-columns:2fr 3fr}
    .grid.cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}
    .grid.cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}
    .grid.cols-5{grid-template-columns:repeat(5,minmax(0,1fr))}
    @media (max-width:1100px){ .grid.cols-4{grid-template-columns:repeat(2,1fr)} }
    @media (max-width:900px){ .grid.cols-2{grid-template-columns:1fr} .grid.cols-3{grid-template-columns:repeat(2,1fr)} }
    @media (max-width:680px){ .grid.cols-3{grid-template-columns:1fr} }

    .stack > .card,
    .stack > .grid { margin-bottom: var(--block-gap); }
    .stack > :last-child { margin-bottom: 0; }

    .stack .grid{ gap:calc(var(--gap) + 6px); }

    .card{
      background:var(--card); border:1px solid var(--line); border-radius:var(--radius); padding:16px; box-shadow:var(--shadow)
    }
    .card h3{margin:0 0 12px 0; font-size:16px; letter-spacing:.2px}
    .kpis{display:grid; grid-template-columns:repeat(5,minmax(0,1fr)); gap:var(--gap)}
    @media (max-width:1000px){ .kpis{grid-template-columns:repeat(2,1fr)} }
    @media (max-width:600px){ .kpis{grid-template-columns:1fr} }
    .kpi{background:var(--card-2); border:1px solid var(--line); border-radius:12px; padding:14px; overflow:hidden}
    .kpi .label{color:var(--muted); font-size:12px; margin-bottom:6px}
    .kpi .value{font-size:22px; font-weight:800; word-break:break-word}
    .profit-concentration-summary{margin-top:12px; display:flex; flex-wrap:wrap; gap:12px; font-size:13px; color:var(--muted);}
    .profit-concentration-summary span{padding:6px 10px; border-radius:999px; background:rgba(78,161,255,.12); color:var(--text); font-weight:600;}
    .profit-concentration-summary span small{display:block; font-size:11px; color:var(--muted); font-weight:500;}
    /* Smaller percent add-on next to KPI values */
    .kpi .value .pct{ font-size:.85em }
    /* Help hint popover */
    .help{ display:inline-flex; align-items:center; justify-content:center; width:18px; height:18px; border-radius:50%; background:#2a2f57; color:#cfd2e6; font-size:12px; cursor:pointer; margin-left:6px }
    .help:hover{ background:#3a4a8a }
    .help-pop{ position:absolute; z-index:70; max-width:360px; background:var(--card); color:#cfd2e6; border:1px solid var(--line); border-radius:10px; padding:10px; box-shadow:var(--shadow); display:none }
    .help-pop.show{ display:block }

    table{width:100%; border-collapse:collapse}
    th, td{padding:10px 8px; border-bottom:1px solid var(--line); text-align:left; font-size:14px}
    thead th{color:var(--muted); font-size:12px; text-transform:uppercase; letter-spacing:.4px}
    tbody tr:hover{background:rgba(255,255,255,.03)}
    thead th.sticky{position:sticky; top:0; z-index:1; background:var(--card)}

    /* ---------- Quick Entry Dock ---------- */
    .quick-dock{
      position:sticky; top:76px; z-index:35;
      background:linear-gradient(180deg, rgba(26,30,58,.9), rgba(26,30,58,.86));
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      box-shadow:var(--shadow);
      display:grid;
      grid-template-columns:1.2fr 1.6fr 1.2fr 1.2fr 1.2fr;
      gap:10px;
      align-items:center;
      margin-bottom:var(--block-gap);
    }
    @media (max-width:980px){ .quick-dock{ grid-template-columns:1.2fr 1.6fr 1fr 1fr 1fr; } }
    @media (max-width:760px){ .quick-dock{ grid-template-columns:1fr; top:64px } }
    .quick-dock.hidden{display:none}
    .dock-group{
      display:flex; align-items:center; gap:8px; width:100%;
      background:var(--bg-soft); border:1px solid var(--line); border-radius:10px; padding:8px;
    }
    .dock-group .seg{background:transparent; border:0}
    .dock-group .seg button{min-width:92px}
    .icon-btn{background:transparent; border:0; color:var(--muted); cursor:pointer; font-size:18px}
    .icon-btn:hover{color:#fff}
    .icon-btn[data-pinned="true"]{color:var(--amber);}
    .hint{color:var(--muted); font-size:12px; margin-top:4px; text-align:center}
    .btn.soft.small{padding:6px 10px; font-size:12px; border-radius:8px;}

    /* Reward:Risk controls */
    .rr-ctl{ display:flex; align-items:center; justify-content:center; gap:6px; margin-top:6px; }
    .rr-input{ width:72px; text-align:center; }
    .rr-sym{ color:var(--muted); font-weight:800; }
    .rr-label{ color:var(--muted); font-size:12px; text-align:center; margin-top:2px; }

    /* ---------- Screenshot area ---------- */
    .shot-card .shot-drop{
      border:2px dashed #3a4177; border-radius:12px;
      background:linear-gradient(0deg, #161a33bb, #161a33aa);
      padding:12px; min-height:120px; display:flex; align-items:center; justify-content:center; text-align:center; color:var(--muted);
      cursor:text;
    }
    .shot-card .shot-drop.focus{outline:2px solid var(--blue); outline-offset:2px}
    .shot-card .shot-img{display:block; width:100%; height:auto; border-radius:10px; margin-top:12px; border:1px solid var(--line)}
    .shot-tools{display:flex; gap:8px; align-items:center; justify-content:flex-end; margin-top:8px}

    .muted{color:var(--muted)}
    .sr{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}

    /* ---------- Toasts ---------- */
    .toast{position:fixed; right:16px; bottom:16px; z-index:60}
    .toast .t{background:#1e223f; color:#e7e9f0; border:1px solid #2b315d; border-radius:10px; padding:10px 12px; margin-top:8px; box-shadow:var(--shadow); font-size:14px}
    .toast .undo{margin-left:10px; color:#4ea1ff; cursor:pointer; font-weight:700}

    /* ---------- Analytics ---------- */
    .progress{height:8px; border-radius:999px; background:#1c2144; border:1px solid #2b315d; overflow:hidden}
    .progress > div{height:100%; background:linear-gradient(90deg, #4ea1ff, #277ae3); width:0%}
    .code{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; color:#cfd2e6}

    /* ---------- Unit config panel ---------- */
    .unit-config{
      display:none; max-width:1300px; margin:8px auto 0;
      background:var(--card); border:1px solid var(--line); border-radius:12px; padding:12px;
      box-shadow:var(--shadow);
    }
    .unit-config.show{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .unit-config .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .unit-config .note{color:var(--muted); font-size:12px}

    /* Tag chips */
    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:2px 8px; border-radius:999px;
      background:#262a52; border:1px solid var(--line);
      font-size:12px; color:#cfd2e6; margin:2px 6px 2px 0;
      white-space:nowrap;
    }
    .chip .xbtn{cursor:pointer; font-size:14px; line-height:1}
    .chip-input{
      display:flex; flex-wrap:wrap; gap:6px; padding:8px;
      background:var(--bg-soft); border:1px solid var(--line); border-radius:10px;
      min-height:40px;
    }
    #quickTagsBox{ margin-top:6px; }
    .chip-input input{
      min-width:120px; flex:1 0 120px; background:transparent; border:0; outline:none; color:var(--text); padding:4px 6px; min-height:auto;
    }
    .scenario-inline{
      display:flex; align-items:center; gap:6px; margin-left:auto; flex-wrap:wrap; justify-content:flex-end;
    }
    .scenario-inline .scenario-label{ color:var(--muted); font-size:12px; }
    .scenario-inline .seg{ background:var(--card); border:1px solid var(--line); border-radius:999px; overflow:hidden; }
    .scenario-inline .seg button{ min-width:72px; padding:6px 12px; }

    /* Modal (Tag Manager) */
    .modal-backdrop{
      position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:90; display:none;
    }
    .modal-backdrop.show{display:block}
    .modal{
      position:fixed; left:50%; top:10%;
      transform:translateX(-50%);
      width:min(640px, 92vw);
      background:var(--card); border:1px solid var(--line); border-radius:12px; padding:16px; z-index:95; display:none;
      box-shadow:var(--shadow);
    }
    .modal.show{display:block}
    .modal h4{margin:0 0 10px 0}
    .modal .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:8px 0}
    .modal .list{
      background:var(--bg-soft); border:1px solid var(--line); border-radius:10px; padding:8px; max-height:240px; overflow:auto;
    }
    .modal .list .item{
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      padding:8px; border-bottom:1px dashed #2b315d;
    }
    .modal .list .item:last-child{border-bottom:0}

    /* All Trades layout */
    .alltrades-layout{
      display:grid; grid-template-columns: 1fr 3fr; gap:var(--gap); margin-top: var(--gap); 
    }
    @media (max-width:1100px){
      .alltrades-layout{ grid-template-columns: 1fr; }
    }
    .bulkbar{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      background:var(--bg-soft); border:1px solid var(--line); border-radius:10px; padding:8px;
    }

    .col-select{ width:38px }
    .col-pic{ width:64px; text-align:center }
    .pic-icon{
      width:36px; height:24px; border-radius:6px; display:inline-flex; align-items:center; justify-content:center;
      background:#2a2f57; border:1px solid var(--line); cursor:pointer; user-select:none;
      font-size:12px; color:#9fb3ff;
    }
    .pic-icon:hover{ outline:1px solid #4ea1ff; }

    .preview-pane{
      position:sticky; top:76px;
      background:var(--card-2); border:1px solid var(--line); border-radius:12px; padding:10px; min-height:240px;
    }
    .preview-pane .meta{ color:var(--muted); font-size:12px; margin-bottom:6px; display:flex; gap:10px; flex-wrap:wrap }
    .preview-holder{
      width:100%; height:70vh; min-height:220px; border-radius:10px; background:#121430; border:1px dashed #2b315d; overflow:hidden;
      display:flex; align-items:center; justify-content:center;
    }
    .preview-holder img{ width:100%; height:100%; object-fit:contain; display:block }

    /* Filters */
    .filterbar .row{display:flex; gap:8px; flex-wrap:wrap; align-items:flex-end}
    .tag-select{ min-width:180px; max-width:280px; }
    .tag-mode label{cursor:pointer}

    /* Sticky table head */
    .tall-table{ overflow:auto; max-height:60vh; }
    .tall-table thead th{ position:sticky; top:0; background:var(--card); z-index:1 }

    #tab-alltrades .tall-table{
      max-height: 70vh;
      overflow: auto;
    }

    .alltrades-layout > .card{
      display: flex;
      flex-direction: column;
    }
    .alltrades-layout > .card .tall-table{
      flex: 0 1 auto;
      min-height: 280px;
    }

    /* ---------- Compare Tab ---------- */
    .compare-layout{
      display:grid;
      gap:var(--gap);
      grid-template-columns:repeat(auto-fit, minmax(280px,1fr));
    }
    .compare-slot{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .compare-slot header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .compare-slot header h3{
      margin:0;
      font-size:18px;
    }
    .compare-slot .btn-row{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .compare-meta{
      display:grid;
      gap:4px;
      font-size:13px;
      color:var(--muted);
    }
    .compare-meta strong{color:var(--text);}
    .compare-empty{
      border:1px dashed var(--line);
      border-radius:var(--radius);
      padding:12px;
      text-align:center;
      color:var(--muted);
      font-size:13px;
    }
    .compare-summary{
      display:grid;
      gap:var(--gap);
    }
    .compare-kpis{
      display:grid;
      gap:var(--gap);
      grid-template-columns:repeat(auto-fit, minmax(160px,1fr));
    }
    .compare-kpi{
      background:var(--bg-soft);
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .compare-kpi .label{font-size:12px; color:var(--muted); letter-spacing:.2px; text-transform:uppercase;}
    .compare-kpi .values{display:flex; gap:10px; align-items:baseline; flex-wrap:wrap;}
    .compare-kpi .values span{font-weight:800; font-size:18px;}
    .compare-kpi .diff{font-size:12px; color:var(--muted);}
    .compare-kpi .diff.positive{color:var(--green);}
    .compare-kpi .diff.negative{color:var(--red);}
    .compare-charts{
      display:grid;
      gap:var(--gap);
      grid-template-columns:repeat(auto-fit, minmax(420px,1fr));
      align-items:stretch;
    }
    .compare-chart-card{
      display:flex;
      flex-direction:column;
      min-height:320px;
    }
    .compare-chart-card h3{margin-bottom:8px;}
    .compare-chart-card .chart-holder{
      position:relative;
      flex:1;
      min-height:260px;
    }
    .compare-chart-card canvas{
      width:100% !important;
      height:100% !important;
    }
    .compare-key-grid{
      display:grid;
      gap:var(--gap);
      grid-template-columns:repeat(auto-fit, minmax(220px,1fr));
    }
    .compare-key-item{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .compare-key-item strong{font-size:14px;}
    .compare-key-item .mini-chart{
      position:relative;
      min-height:150px;
    }
    .compare-key-item canvas{
      width:100% !important;
      height:100% !important;
    }
    .compare-filter-card{
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    .compare-filter-grid{
      display:grid;
      gap:12px;
      grid-template-columns:repeat(auto-fit, minmax(180px,1fr));
    }
    .compare-filter-grid label{font-size:12px; color:var(--muted); display:block; margin-bottom:4px;}
    .compare-filter-grid input, .compare-filter-grid select{
      width:100%;
    }
    .compare-outcome-checks{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      font-size:13px;
    }
    .compare-outcome-checks label{display:flex; align-items:center; gap:6px; color:var(--muted);}
    .compare-extended{ margin-top:var(--block-gap); }
    .compare-table-scroll{ overflow:auto; }
    .compare-table{ width:100%; border-collapse:collapse; font-size:13px; }
    .compare-table th, .compare-table td{ padding:8px 10px; border-bottom:1px solid var(--line); text-align:left; }
    .compare-table th{ color:var(--muted); font-weight:600; text-transform:uppercase; font-size:12px; letter-spacing:.4px; }
    .compare-table td.metric-label{ font-weight:600; }
    .compare-table td.diff-positive{ color:var(--green); font-weight:600; }
    .compare-table td.diff-negative{ color:var(--red); font-weight:600; }
    .compare-tag-list{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .compare-tag{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 10px;
      border-radius:999px;
      background:var(--bg-soft);
      border:1px solid var(--line);
      font-size:12px;
      color:var(--muted);
    }
    .compare-note{font-size:12px; color:var(--muted);}

    /* Checkbox */
    input[type="checkbox"]{ width:18px; height:18px; }
    input[type="radio"]{ margin-right:4px; }

    /* Small utility */
    .grow{flex:1}
    .spacer{flex:1}
    .right{margin-left:auto}
    .nowrap{white-space:nowrap}
    .danger{color:var(--red)}
    .ok{color:var(--green)}
    .amber{color:var(--amber)}
  
    /* Active filters indicator */
    .filter-active{
      background:var(--blue); color:white; padding:2px 6px; border-radius:4px; font-size:11px; margin-left:8px;
    }

    /* Report drag layout */
    .report-sections{ display:flex; flex-direction:column; gap: var(--block-gap); }
    .report-section{ position:relative; }
    .report-section.dragging{ opacity:.6; }
    .dd-card{ border-top:1px solid rgba(255,255,255,0.08); padding:12px 0; }
    .dd-card:first-child{ border-top:none; padding-top:0; }
    .dd-summary{ display:flex; flex-wrap:wrap; gap:16px; justify-content:space-between; align-items:flex-start; }
    .dd-rank{ font-size:1.1rem; font-weight:700; color:var(--amber); min-width:48px; }
    .dd-metric{ font-weight:600; font-size:1rem; }
    .dd-meta-grid{ display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:12px; margin-top:12px; }
    .dd-pill{ background:rgba(255,255,255,0.06); border-radius:999px; padding:4px 10px; font-size:.85rem; display:inline-flex; align-items:center; gap:6px; }
    .dd-setup-grid{ margin-top:10px; display:grid; grid-template-columns:repeat(auto-fit,minmax(140px,1fr)); gap:8px; }
    .dd-setup{ background:rgba(255,255,255,0.04); border-radius:8px; padding:8px 10px; }
    .dd-muted{ color:var(--muted); font-size:.85rem; }
    .drag-handle{
      position:absolute; top:8px; right:8px; z-index:5;
      background:#1e2244; color:#cfd2e6; border:1px solid var(--line);
      border-radius:6px; padding:2px 6px; font-size:12px; cursor:grab; user-select:none;
    }

    /* ---------- Journal ---------- */
    .journal-layout{display:grid; grid-template-columns:320px minmax(0,1fr); gap:var(--gap);}
    @media (max-width:1150px){ .journal-layout{grid-template-columns:1fr;} }
    .journal-list{max-height:540px; overflow:auto; display:flex; flex-direction:column; gap:8px; padding-right:4px;}
    .journal-item{background:var(--bg-soft); border:1px solid var(--line); border-radius:10px; padding:10px 12px; cursor:pointer; display:flex; flex-direction:column; gap:4px; transition:background .2s ease, border-color .2s ease;}
    .journal-item:hover{background:#22254a;}
    .journal-item.active{border-color:var(--blue); box-shadow:0 0 0 1px rgba(78,161,255,.45);}
    .journal-item .title{font-weight:700; font-size:14px; display:flex; align-items:center; gap:6px;}
    .journal-item .meta{font-size:12px; color:var(--muted); display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
    .journal-pin{color:var(--amber); font-size:14px;}
    .journal-empty{padding:20px; text-align:center; color:var(--muted); border:1px dashed var(--line); border-radius:10px;}
    .journal-toolbar{display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin:12px 0 10px;}
    .journal-toolbar button{background:var(--bg-soft); border:1px solid var(--line); border-radius:8px; color:var(--text); padding:6px 10px; cursor:pointer; font-weight:600; font-size:13px;}
    .journal-toolbar button.active{background:var(--blue); color:#fff;}
    .journal-toolbar select{background:var(--bg-soft); border:1px solid var(--line); border-radius:8px; color:var(--text); padding:6px 8px;}
    .journal-editor{min-height:240px; background:var(--bg-soft); border:1px solid var(--line); border-radius:12px; padding:14px; line-height:1.55; font-size:15px; overflow-y:auto;}
    .journal-editor:empty:before{content:attr(data-placeholder); color:var(--muted);}
    .journal-editor:focus{outline:2px solid var(--blue);}
    .journal-editor a{color:var(--blue);}
    .journal-editor ul, .journal-editor ol{margin:6px 0 6px 20px;}
    .journal-editor blockquote{border-left:3px solid var(--blue); margin:10px 0; padding-left:12px; color:#cfd2e6; font-style:italic;}
    .journal-tags{margin-top:12px;}
    .journal-meta{display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin-top:12px; font-size:13px; color:var(--muted);}
    .journal-meta label{font-size:12px; color:var(--muted);}
    .journal-filter-bar{display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:12px;}
    .journal-filter-bar input[type="search"]{min-width:200px;}
    .journal-stats{display:grid; grid-template-columns:repeat(auto-fit, minmax(120px,1fr)); gap:var(--gap); margin:16px 0;}
    .journal-stats .card{background:var(--card-2); border:1px solid var(--line); box-shadow:none; padding:14px;}
    .journal-stats .label{font-size:12px; color:var(--muted); margin-bottom:4px;}
    .journal-stats .value{font-weight:800; font-size:20px;}
    .journal-custom-actions{display:flex; flex-wrap:wrap; gap:8px; margin-bottom:12px;}
    .journal-screenshots{margin-top:14px; padding-top:12px; border-top:1px solid var(--line); display:flex; flex-direction:column; gap:12px;}
    .journal-screenshots .muted{font-size:13px;}
    .journal-shot{position:relative; background:var(--bg-soft); border:1px solid var(--line); border-radius:12px; padding:10px;}
    .journal-shot img{display:block; max-width:100%; height:auto; border-radius:10px; border:1px solid #2b315d; cursor:pointer;}
    .journal-shot header{display:flex; align-items:center; gap:10px; margin-bottom:8px; font-size:13px; color:var(--muted);}
    .journal-shot header span{font-weight:600; color:var(--text);}
    .journal-thumb-grid{display:grid; grid-template-columns:repeat(auto-fit, minmax(160px,1fr)); gap:12px;}
    .journal-thumb{background:var(--bg-soft); border:1px solid var(--line); border-radius:10px; padding:10px; display:flex; flex-direction:column; gap:8px;}
    .journal-thumb img{width:100%; height:120px; object-fit:cover; border-radius:8px; border:1px solid #2b315d; cursor:pointer;}
    .journal-thumb strong{font-size:13px;}
    .journal-thumb .net{font-size:12px; font-weight:700;}

    /* ---------- Scaling Tab ---------- */
    .scaling-layout{grid-template-columns:minmax(0,1.45fr) minmax(0,1fr);}
    @media (max-width:1100px){ .scaling-layout{grid-template-columns:1fr;} }
    .scaling-header{display:flex; align-items:flex-end; justify-content:space-between; gap:12px;}
    .scaling-anchor-control{display:flex; flex-direction:column; gap:4px; min-width:150px;}
    .scaling-anchor-control input{width:100%;}
    .sizing-head{display:flex; align-items:flex-end; justify-content:space-between; gap:12px; margin-bottom:10px;}
    .sizing-title{display:flex; align-items:center; gap:8px;}
    .sizing-title h3{margin:0;}
    .sizing-title .icon-btn{width:32px; height:32px; border-radius:50%; border:1px solid rgba(120,134,255,.4); background:rgba(27,31,60,.8); color:#d5dbff; font-weight:700; font-size:16px; box-shadow:0 6px 14px rgba(0,0,0,.35);}
    .sizing-title .icon-btn:hover{background:rgba(41,48,88,.9); color:#ffffff;}
    .scaling-ladder-controls{display:flex; flex-direction:column; gap:4px; min-width:150px;}
    .scaling-ladder-controls label{font-size:12px; color:var(--muted); letter-spacing:.3px; text-transform:uppercase;}
    .sizing-current{position:relative;}
    .scaling-ladder-status{margin:10px 0 16px; padding:10px 12px; border-radius:12px; background:linear-gradient(120deg, rgba(28,33,70,.7), rgba(17,19,42,.7)); border:1px solid rgba(130,140,205,.25); color:#d6dbff; font-size:13px; letter-spacing:.25px; line-height:1.45; box-shadow:0 10px 24px rgba(0,0,0,.28) inset;}
    @media (max-width:720px){
      .sizing-head{flex-direction:column; align-items:flex-start;}
      .scaling-ladder-controls{width:100%;}
    }
    .scaling-status{font-size:13px;}
    .scaling-status.ready{color:var(--green); font-weight:600;}
    .scaling-status.fail{color:var(--red); font-weight:600;}
    .scaling-status.reset{color:var(--amber); font-weight:600;}
    .scaling-daily-header{display:flex; align-items:flex-end; justify-content:space-between; gap:12px; margin-bottom:10px;}
    .scaling-daily-title{display:flex; align-items:center; gap:10px;}
    .scaling-date-control{display:flex; flex-direction:column; gap:4px; min-width:150px;}
    .scaling-daily-meta{display:flex; flex-wrap:wrap; gap:14px; margin-bottom:18px; font-size:13px; color:#a8b2e6; letter-spacing:.2px; text-transform:uppercase;}
    .scaling-checklist{display:grid; gap:14px;}
    .scaling-checklist-section{background:linear-gradient(160deg, rgba(37,43,82,.92), rgba(21,24,49,.92)); border:1px solid rgba(78,161,255,.18); border-radius:14px; padding:18px; box-shadow:0 10px 24px rgba(0,0,0,.35);}
    .scaling-checklist-section h4{margin:0 0 12px 0; font-size:15px; letter-spacing:.4px; text-transform:uppercase; color:#d0d5ff;}
    .scaling-checklist-list{display:grid; gap:10px;}
    .scaling-check-item{display:grid; grid-template-columns:28px 1fr; gap:10px; align-items:center; font-size:13px; line-height:1.45; color:#e4e8ff;}
    .scaling-check-item input{appearance:none; width:20px; height:20px; border-radius:6px; border:2px solid rgba(142,153,255,.6); background:linear-gradient(180deg, #101633, #1c224a); position:relative; cursor:pointer; transition:border .2s ease, background .2s ease;}
    .scaling-check-item input:checked{border-color:#53f3ff; background:linear-gradient(180deg, #2d92ff, #53f3ff); box-shadow:0 0 12px rgba(83,243,255,.55);}
    .scaling-check-item input:checked::after{content:"✔"; position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:13px; font-weight:700; color:#041029;}
    .scaling-check-item span{display:block; color:#d5dbff;}
    .scaling-log-actions{margin-top:16px;}
    .scaling-feedback{margin-top:10px; font-size:13px; color:var(--muted);}
    .scaling-feedback strong{color:var(--text);}

    .scaling-level-track{display:grid; gap:16px; margin-top:6px;}
    .scaling-level{
      position:relative;
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:18px 20px;
      border-radius:18px;
      background:linear-gradient(155deg, rgba(19,23,52,.96), rgba(9,12,28,.92));
      border:1px solid rgba(112,132,255,.35);
      box-shadow:0 16px 32px rgba(0,0,0,.46);
      overflow:hidden;
    }
    .scaling-level::before{content:""; position:absolute; inset:0; background:linear-gradient(120deg, transparent 0%, rgba(83,243,255,.18) 45%, transparent 100%); opacity:0; transition:opacity .3s ease; pointer-events:none;}
    .scaling-level::after{content:""; position:absolute; inset:1px; border-radius:16px; border:1px solid rgba(255,255,255,.04); pointer-events:none;}
    .scaling-level .level-head{display:flex; align-items:center; justify-content:space-between; gap:14px;}
    .scaling-level .level-chip{display:inline-flex; align-items:center; justify-content:center; padding:5px 14px; border-radius:12px; font-weight:900; font-size:16px; letter-spacing:.4px; color:#fff; background:linear-gradient(200deg, #7f8cff, #3d4ffe); box-shadow:0 6px 16px rgba(86,102,255,.45); text-shadow:0 1px 2px rgba(0,0,0,.35);}
    .scaling-level .level-name{flex:1; display:flex; flex-direction:column; gap:2px; min-width:0;}
    .scaling-level .level-name strong{font-size:16px; letter-spacing:.3px; font-weight:800; color:#eef1ff;}
    .scaling-level .level-name span{font-size:12px; text-transform:uppercase; letter-spacing:.3px; color:#8c96d9;}
    .scaling-level .level-status{font-size:12px; font-weight:800; letter-spacing:.35px; text-transform:uppercase; color:#9fa7ff;}
    .scaling-level .level-meta{display:flex; flex-wrap:wrap; gap:12px; font-size:12px; letter-spacing:.25px; color:#9fa7ff; text-transform:uppercase;}
    .scaling-level .level-meta span{display:inline-flex; align-items:center; background:rgba(255,255,255,.06); padding:4px 12px; border-radius:999px; font-weight:700; letter-spacing:.35px; color:inherit;}
    .scaling-level .xp-track{position:relative; height:12px; border-radius:10px; background:linear-gradient(180deg, rgba(18,21,44,.95), rgba(8,11,26,.95)); border:1px solid rgba(120,134,255,.25); overflow:hidden;}
    .scaling-level .xp-track::after{content:""; position:absolute; inset:0; background:linear-gradient(135deg, rgba(255,255,255,.28), transparent 55%); mix-blend-mode:screen; pointer-events:none;}
    .scaling-level .xp-fill{height:100%; width:0%; background:linear-gradient(90deg, #55f7ff 0%, #69ffba 50%, #f9ff90 100%); box-shadow:0 0 18px rgba(105,255,186,.45); transition:width .35s ease; position:relative;}
    .scaling-level .xp-fill::after{content:""; position:absolute; inset:0; background:linear-gradient(180deg, rgba(255,255,255,.45), rgba(255,255,255,0));}
    .scaling-level.passed{box-shadow:0 20px 36px rgba(55,180,110,.18);}
    .scaling-level.active{box-shadow:0 22px 38px rgba(61,169,235,.26);}
    .scaling-level.active::before{opacity:.45;}
    .scaling-level.ready{animation:ladderGlow 2.2s ease-in-out infinite;}
    .scaling-level.ready .level-status{text-shadow:0 0 10px rgba(117,255,176,.65);}
    .scaling-level.locked{border-color:rgba(70,80,120,.25); box-shadow:0 12px 26px rgba(15,18,34,.45); opacity:.6; transition:opacity .25s ease, transform .25s ease;}
    .scaling-level.locked:hover{opacity:.75; transform:translateY(-2px);}
    .scaling-level.locked .level-chip{filter:grayscale(.35); box-shadow:none;}
    .scaling-level.locked .level-status{opacity:.65; color:#7f86b3;}
    .scaling-level.locked .level-meta span{background:rgba(120,126,170,.15); color:#9aa1cf;}

    .scaling-level.tier-L0{border-color:rgba(210,214,232,.5);}
    .scaling-level.tier-L0 .level-chip{background:linear-gradient(200deg, #f4f4f8, #c9ccd8); color:#171a2f; box-shadow:0 6px 14px rgba(110,118,150,.35);}
    .scaling-level.tier-L0 .level-status{color:#d7dbf0;}
    .scaling-level.tier-L0 .xp-fill{background:linear-gradient(90deg, #e4e6f1, #c9ccdc); box-shadow:0 0 14px rgba(200,204,220,.45);}
    .scaling-level.tier-L0 .level-meta{color:#dce2f8;}
    .sizing-info-tier.tier-L0 .color-swatch{background:linear-gradient(200deg, #f4f4f8, #c9ccd8);}

    .scaling-level.tier-L1{border-color:rgba(67,209,122,.45);}
    .scaling-level.tier-L1 .level-chip{background:linear-gradient(200deg, #43d17a, #29a35a); box-shadow:0 8px 18px rgba(67,209,122,.45);}
    .scaling-level.tier-L1 .level-status{color:#43d17a;}
    .scaling-level.tier-L1 .xp-fill{background:linear-gradient(90deg, #43d17a, #7bffa9); box-shadow:0 0 18px rgba(67,209,122,.45);}
    .scaling-level.tier-L1 .level-meta{color:#6bf2a2;}
    .sizing-info-tier.tier-L1 .color-swatch{background:linear-gradient(200deg, #43d17a, #29a35a);}

    .scaling-level.tier-L2{border-color:rgba(78,161,255,.5);}
    .scaling-level.tier-L2 .level-chip{background:linear-gradient(200deg, #4ea1ff, #276bff); box-shadow:0 8px 20px rgba(78,161,255,.5);}
    .scaling-level.tier-L2 .level-status{color:#4ea1ff;}
    .scaling-level.tier-L2 .xp-fill{background:linear-gradient(90deg, #4ea1ff, #72c3ff); box-shadow:0 0 18px rgba(78,161,255,.45);}
    .scaling-level.tier-L2 .level-meta{color:#74b9ff;}
    .sizing-info-tier.tier-L2 .color-swatch{background:linear-gradient(200deg, #4ea1ff, #276bff);}

    .scaling-level.tier-L3{border-color:rgba(255,212,71,.45);}
    .scaling-level.tier-L3 .level-chip{background:linear-gradient(200deg, #ffd447, #ffb400); box-shadow:0 8px 20px rgba(255,212,71,.45); color:#1a1604;}
    .scaling-level.tier-L3 .level-status{color:#ffd447;}
    .scaling-level.tier-L3 .xp-fill{background:linear-gradient(90deg, #ffd447, #ffe48a); box-shadow:0 0 18px rgba(255,212,71,.45);}
    .scaling-level.tier-L3 .level-meta{color:#ffe282;}
    .sizing-info-tier.tier-L3 .color-swatch{background:linear-gradient(200deg, #ffd447, #ffb400);}

    .scaling-level.tier-L4{border-color:rgba(183,107,255,.45);}
    .scaling-level.tier-L4 .level-chip{background:linear-gradient(200deg, #b76bff, #7d3aff); box-shadow:0 8px 22px rgba(183,107,255,.48);}
    .scaling-level.tier-L4 .level-status{color:#b76bff;}
    .scaling-level.tier-L4 .xp-fill{background:linear-gradient(90deg, #b76bff, #d3a4ff); box-shadow:0 0 18px rgba(183,107,255,.48);}
    .scaling-level.tier-L4 .level-meta{color:#c99cff;}
    .sizing-info-tier.tier-L4 .color-swatch{background:linear-gradient(200deg, #b76bff, #7d3aff);}

    .scaling-level.tier-L5{border-color:rgba(255,140,63,.45);}
    .scaling-level.tier-L5 .level-chip{background:linear-gradient(200deg, #ff8c3f, #ff5a00); box-shadow:0 8px 20px rgba(255,140,63,.45);}
    .scaling-level.tier-L5 .level-status{color:#ff8c3f;}
    .scaling-level.tier-L5 .xp-fill{background:linear-gradient(90deg, #ff8c3f, #ffb27a); box-shadow:0 0 18px rgba(255,140,63,.45);}
    .scaling-level.tier-L5 .level-meta{color:#ffae6e;}
    .sizing-info-tier.tier-L5 .color-swatch{background:linear-gradient(200deg, #ff8c3f, #ff5a00);}

    .scaling-level.tier-L6{border-color:rgba(255,90,107,.55);}
    .scaling-level.tier-L6 .level-chip{background:linear-gradient(200deg, #ff5a6b, #d6293e); box-shadow:0 8px 24px rgba(255,90,107,.5);}
    .scaling-level.tier-L6 .level-status{color:#ff5a6b;}
    .scaling-level.tier-L6 .xp-fill{background:linear-gradient(90deg, #ff5a6b, #ff8894); box-shadow:0 0 18px rgba(255,90,107,.5);}
    .scaling-level.tier-L6 .level-meta{color:#ff7c88;}
    .sizing-info-tier.tier-L6 .color-swatch{background:linear-gradient(200deg, #ff5a6b, #d6293e);}

    .checklist-editor{display:grid; gap:14px; max-height:420px; overflow:auto; margin:12px 0;}
    .checklist-editor-section{background:var(--card-2); border:1px solid var(--line); border-radius:12px; padding:14px; display:flex; flex-direction:column; gap:10px;}
    .checklist-editor-section header{display:flex; align-items:center; justify-content:space-between; gap:8px;}
    .checklist-editor-section header strong{text-transform:uppercase; font-size:13px; letter-spacing:.4px; color:#d5d8ff;}
    .checklist-editor-items{display:grid; gap:8px;}
    .checklist-editor-row{display:flex; align-items:center; gap:8px;}
    .checklist-editor-row input{flex:1; padding:8px 10px; border-radius:8px; border:1px solid var(--line); background:var(--bg-soft); color:var(--text);}
    .checklist-editor-row button{white-space:nowrap;}

    .scaling-advance-wrap{margin-top:16px; display:flex; flex-direction:column; gap:8px;}
    #scalingAdvanceBtn{position:relative; overflow:hidden; font-size:18px; font-weight:800; letter-spacing:.5px; text-transform:uppercase;}
    #scalingAdvanceBtn:disabled{background:linear-gradient(180deg, #2a2f58, #1a1f3d); color:#737ab3; border:1px solid rgba(115,122,179,.35); box-shadow:none; cursor:not-allowed;}
    #scalingAdvanceBtn.ready-glow{background:linear-gradient(180deg, #2bff88, #18a65a); color:#041d10; border:none; box-shadow:0 0 20px rgba(83,243,255,.45), 0 0 35px rgba(43,255,136,.45); animation:btnSpark 1.8s infinite ease-in-out;}
    #scalingAdvanceBtn.ready-glow::after{content:""; position:absolute; inset:-40%; background:conic-gradient(from 0deg, rgba(255,255,255,.65), rgba(255,255,255,0) 40%, rgba(255,255,255,.65) 80%, rgba(255,255,255,0) 100%); animation:btnSweep 2.2s infinite linear; mix-blend-mode:screen;}
    .scaling-advance-wrap .btn{width:100%;}

    .scaling-log-table-wrap{overflow:auto; max-height:520px; margin-top:12px;}
    #scalingFailTable th,#scalingFailTable td{text-align:left;}
    #scalingFailTable tbody tr{color:var(--red);}
    .fail-tags{display:flex; flex-wrap:wrap; gap:6px;}
    .fail-tag{padding:4px 8px; border-radius:999px; background:rgba(255,90,107,.18); color:#ffb4be; font-size:12px; font-weight:600;}

    .sizing-info-list{display:grid; gap:12px; max-height:360px; overflow:auto;}
    .sizing-info-tier{display:flex; align-items:center; gap:12px; padding:10px 12px; border-radius:12px; border:1px solid rgba(120,134,255,.2); background:linear-gradient(140deg, rgba(27,31,60,.85), rgba(13,16,33,.85)); box-shadow:0 8px 18px rgba(0,0,0,.3);}
    .sizing-info-tier .color-swatch{width:38px; height:38px; border-radius:10px; box-shadow:0 6px 16px rgba(0,0,0,.35); flex-shrink:0;}
    .sizing-info-tier .tier-details{display:flex; flex-direction:column; gap:2px;}
    .sizing-info-tier .tier-details strong{text-transform:uppercase; letter-spacing:.35px; font-size:13px;}
    .sizing-info-tier .tier-details span{font-size:12px; color:#aab2e6;}
    .sizing-info-tier.active{border-color:rgba(255,255,255,.35); box-shadow:0 10px 26px rgba(83,123,255,.35);}

    @keyframes ladderGlow{
      0%,100%{box-shadow:0 22px 38px rgba(61,169,235,.35), 0 0 22px rgba(117,255,205,.35);}
      50%{box-shadow:0 26px 44px rgba(61,169,235,.5), 0 0 34px rgba(117,255,205,.55);}
    }

    @keyframes btnSpark{
      0%,100%{box-shadow:0 0 20px rgba(83,243,255,.5), 0 0 35px rgba(43,255,136,.45);}
      50%{box-shadow:0 0 35px rgba(83,243,255,.8), 0 0 55px rgba(43,255,136,.6);}
    }
    @keyframes btnSweep{
      0%{transform:rotate(0deg);
      }
      100%{transform:rotate(360deg);
      }
    }

    /* Calendar screenshot overlay */
    .shot-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.7); z-index:100; display:none; align-items:center; justify-content:center; padding:20px }
    .shot-overlay.show{ display:flex }
    .shot-modal{ position:relative; max-width:96vw; max-height:92vh; outline:1px solid var(--line); border-radius:12px; box-shadow:var(--shadow); background:#0b0e22 }
    .shot-modal img{ display:block; max-width:96vw; max-height:92vh; width:auto; height:auto; object-fit:contain; border-radius:12px }
    .shot-close{ position:absolute; top:8px; right:8px; background:#1e2244; border:1px solid var(--line); color:#cfd2e6; border-radius:20px; width:32px; height:32px; font-size:18px; line-height:30px; text-align:center; cursor:pointer }
    .shot-close:hover{ background:#2a3066; }
  </style>
</head>
<body>

<!-- ========== TOP BAR ========== -->
  <header class="appbar" role="banner">
    <div class="appbar-inner">
      <div class="brand">
        <span>📊 Trading Tracker</span>
        <small id="fileBadge">Unsaved</small>
      </div>

      <!-- Tabs + Actions on one line -->
      <div class="controls-row">
        <div class="left" role="tablist" aria-label="Views">
          <div class="seg">
            <button class="active" id="tabBtn-backtest" role="tab" aria-selected="true" data-tab="backtest">Backtest</button>
            <button id="tabBtn-journal" role="tab" aria-selected="false" data-tab="journal">Journal</button>
            <button id="tabBtn-alltrades" role="tab" aria-selected="false" data-tab="alltrades">All Trades</button>
            <button id="tabBtn-calendar" role="tab" aria-selected="false" data-tab="calendar">Calendar</button>
            <button id="tabBtn-report" role="tab" aria-selected="false" data-tab="report">Report</button>
            <button id="tabBtn-analytics" role="tab" aria-selected="false" data-tab="analytics">Deep Analytics</button>
            <button id="tabBtn-scaling" role="tab" aria-selected="false" data-tab="scaling">Scaling</button>
            <button id="tabBtn-compare" role="tab" aria-selected="false" data-tab="compare">Compare</button>
          </div>
        </div>
        <div class="toolbar" style="position:relative">
          <button class="btn soft" id="openTagMgrBtn" title="Manage tags">Tags</button>

          <button class="btn blue" id="saveBtn" title="Save JSON (S)">Save <span class="kbd">S</span></button>
          <input class="sr" type="file" id="loadInput" accept=".json" />
          <button class="btn soft" id="loadBtn">Load</button>
          <!-- Export moved into Maintenance popover -->
          <!-- Hidden tools trigger and popover (maintenance) -->
          <div id="hiddenToolsWrap" style="position:relative; display:inline-block">
            <button class="icon-btn" id="hiddenToolsBtn" title="More tools">⋯</button>
            <div id="hiddenToolsPop" class="tag-popover" style="right:0; left:auto; top:32px; min-width:320px">
              <div style="font-weight:700; margin-bottom:6px">Maintenance</div>
              <div class="row" style="margin:6px 0; display:flex; gap:8px; align-items:center; justify-content:flex-start; flex-wrap:wrap">
                <button class="btn soft danger" id="resetAllBtn">Reset All</button>
                <button class="btn soft" id="resetDayBtn" title="Reset current day">Reset Day</button>
                <button class="btn soft" id="exportBtn" title="Export full CSV">Export CSV</button>
              </div>
              <div style="font-weight:700; margin:8px 0 4px">Merge Save Files</div>
              <div class="row" style="gap:6px; align-items:center">
                <input type="file" id="mergeFileA" accept=".json" style="width:48%" />
                <input type="file" id="mergeFileB" accept=".json" style="width:48%" />
              </div>
              <div class="row" style="justify-content:flex-end">
                <button class="btn" id="mergeGoBtn" title="Merge the two files and download">Merge & Download</button>
              </div>
              <div style="font-weight:700; margin:8px 0 4px">Screenshots Bundle (ZIP)</div>
              <div class="row" style="gap:8px; align-items:center; justify-content:flex-start">
                <button class="btn" id="exportBundleBtn" title="Export JSON + images as ZIP">Export Bundle (ZIP)</button>
                <input type="file" id="bundleInput" accept=".zip" style="display:none" />
                <button class="btn soft" id="loadBundleBtn" title="Load a ZIP bundle">Load Bundle</button>
              </div>
              <div style="font-weight:700; margin:8px 0 4px">Default Save Folder</div>
              <div class="row" style="gap:8px; align-items:center; justify-content:flex-start">
                <button class="btn soft" id="setDefaultDirBtn" title="Choose default folder for Save">Set Folder…</button>
                <button class="btn soft" id="clearDefaultDirBtn" title="Clear default folder">Clear</button>
                <span class="muted" id="defaultDirLabel">Not set</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Unit configuration panel moved into Report tab -->
  </header>

  <!-- ===== Tag Manager Modal ===== -->
  <div id="tagModalBackdrop" class="modal-backdrop" aria-hidden="true"></div>
  <div id="tagModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="tagMgrTitle">
    <h4 id="tagMgrTitle">Tag Manager</h4>
    <p class="muted" style="margin:4px 0 10px">Create, rename, and delete tags. Changes apply everywhere.</p>

    <div class="row">
      <label for="newTagInput">New tag</label>
      <input id="newTagInput" type="text" placeholder="e.g., A+ Setup" />
      <button class="btn" id="addTagBtn">Add</button>
    </div>

    <div class="row">
      <label for="renameFrom">Rename</label>
      <input id="renameFrom" type="text" placeholder="Old name" />
      <span>→</span>
      <input id="renameTo" type="text" placeholder="New name" />
      <button class="btn soft" id="renameTagBtn">Rename</button>
    </div>

    

    <div class="row">
      <div class="grow">
        <div class="muted" style="margin-bottom:6px">Existing tags</div>
        <div id="tagList" class="list" role="listbox" aria-label="Existing tags">
          <!-- populated by JS -->
        </div>
      </div>
      <div class="right">
        <button class="btn soft" id="closeTagMgrBtn">Close</button>
      </div>
    </div>
  </div>

  

  <!-- ========== MAIN ========== -->
  <main class="shell">

    <!-- QUICK ENTRY DOCK (Backtest only) -->
    <section class="quick-dock" id="quickDock" aria-label="Quick Entry">
      <!-- Date -->
      <div>
        <div class="dock-group" aria-label="Date control">
          <button class="icon-btn" id="prevDay" title="Previous day (←)">⟨</button>
          <input type="date" id="dateInput" aria-label="Selected date" style="flex:1" />
          <button class="icon-btn" id="nextDay" title="Next day (→)">⟩</button>
          <button class="btn soft" id="todayBtn" title="Jump to today">Today</button>
        </div>
        <div class="hint">Use ← / → to move days</div>
      </div>

      <!-- Setup + Quick Tags + Scenario -->
      <div>
        <div class="dock-group" aria-label="Setup">
          <span class="muted" style="padding-left:6px">Setup</span>
          <div id="setupSeg" class="seg" style="margin-left:6px"></div>
          <button class="icon-btn" id="setupManageBtn" title="Manage setups (max 6)">⚙️</button>
          <div class="tag-popover" id="setupManagePop" role="dialog" aria-label="Manage setups" style="min-width:320px">
            <div style="font-weight:700; margin-bottom:6px">Manage Setups</div>
            <div id="setupList" class="list" style="max-height:160px"></div>
            <div class="row" style="margin-top:8px">
              <input id="newSetupName" type="text" placeholder="New setup name" style="flex:1"/>
              <button class="btn" id="addSetupBtn">Add</button>
            </div>
            <div class="muted" id="setupHint" style="margin-top:6px">Up to 6 setups. Use keys 1–6 to switch.</div>
          </div>
        </div>
        <div class="chip-input" id="quickTagsBox" aria-label="Quick tags for new trades">
          <input id="quickTagInput" type="text" aria-label="Add quick tag" placeholder="Quick tag… press Enter to add" />
          <div class="scenario-inline">
            <span class="scenario-label">Scenario</span>
            <div id="scenarioSeg" class="seg"></div>
            <button class="btn soft small" id="copyScenarioBtn">Copy S1 → S2</button>
          </div>
        </div>
      </div>

      <!-- Win -->
      <div>
        <button class="btn big green" id="winBtn" title="Record Win (↑)">Win <span class="kbd">↑</span></button>
        <div class="hint" id="winHint">Adds +2R to today</div>
        <div class="rr-ctl" aria-label="Reward to Risk">
          <input type="number" id="rewardInput" class="rr-input" min="0" step="0.1" value="2" aria-label="Reward R"/>
        </div>
        <div class="rr-label">Reward</div>
      </div>

      <!-- Breakeven -->
      <div>
        <button class="btn big yellow" id="beBtn" title="Record Breakeven (B)">Breakeven <span class="kbd">B</span></button>
        <div class="hint" id="beHint">Adds 0R to today</div>
      </div>

      <!-- Lose -->
      <div>
        <button class="btn big red" id="loseBtn" title="Record Lose (↓)">Lose <span class="kbd">↓</span></button>
        <div class="hint" id="loseHint">Adds -1R to today</div>
        <div class="rr-ctl" aria-label="Reward to Risk">
          <span class="rr-sym">:</span>
          <input type="number" id="riskInput" class="rr-input" min="0" step="0.1" value="1" aria-label="Risk R"/>
        </div>
        <div class="rr-label">Risk</div>
      </div>
  </section>

    <!-- CALENDAR TAB -->
    <section id="tab-calendar" class="tabcontent stack" role="tabpanel" aria-labelledby="tabBtn-calendar">
      <!-- Filter Bar (Calendar) -->
      <div class="card filterbar" id="calFilterBar">
        <div class="row">
          <div style="display:flex; align-items:flex-end; gap:6px">
            <label for="calMonth">Month</label><br/>
            <button class="btn soft" id="calPrevMonth" title="Previous month">⟨</button>
            <input type="month" id="calMonth" />
            <button class="btn soft" id="calNextMonth" title="Next month">⟩</button>
          </div>
          <div>
            <label for="calSetupSel">Setup</label><br/>
            <select id="calSetupSel">
              <option value="">Any</option>
              <option>Breakout</option>
              <option>Reversal</option>
              <option>Engulfing</option>
            </select>
          </div>
          <div>
            <label for="calResultSel">Result</label><br/>
            <select id="calResultSel">
              <option value="">Any</option>
              <option value="W">Win</option>
              <option value="B">Breakeven</option>
              <option value="L">Loss</option>
            </select>
          </div>
          <div>
            <label for="calScenarioSel">Scenario</label><br/>
            <select id="calScenarioSel">
              <option value="S1">S1</option>
              <option value="S2">S2</option>
            </select>
          </div>
          <!-- TAG PICKER (compact) -->
          <div class="tag-picker" id="calTagPicker">
            <label>Tags</label><br/>
            <button type="button" class="btn soft tag-btn" id="calTagBtn" aria-haspopup="dialog" aria-expanded="false">Any</button>
            <select id="calTagsSel" multiple class="sr"></select>
            <div class="tag-popover" id="calTagPop" role="dialog" aria-label="Filter by tags">
              <input id="calTagSearch" class="search" type="text" placeholder="Search tags…" />
              <div id="calTagList" class="list" aria-label="Available tags"></div>
              <div class="tag-mode">
                <label><input type="radio" name="calTagMode" value="any" checked>Match Any</label>
                <label><input type="radio" name="calTagMode" value="all">Match All</label>
              </div>
              <footer>
                <button type="button" class="btn soft" id="calTagClear">Clear</button>
                <button type="button" class="btn" id="calTagDone">Done</button>
              </footer>
            </div>
          </div>
          <!-- EXCLUDE TAG PICKER (compact) -->
          <div class="tag-picker" id="calExTagPicker">
            <label>Exclude Tags</label><br/>
            <button type="button" class="btn soft tag-btn" id="calExTagBtn" aria-haspopup="dialog" aria-expanded="false">Any</button>
            <select id="calExTagsSel" multiple class="sr"></select>
            <div class="tag-popover" id="calExTagPop" role="dialog" aria-label="Exclude by tags">
              <input id="calExTagSearch" class="search" type="text" placeholder="Search tags…" />
              <div id="calExTagList" class="list" aria-label="Available tags"></div>
              <div class="tag-mode">
                <label><input type="radio" name="calExTagMode" value="any" checked>Match Any</label>
                <label><input type="radio" name="calExTagMode" value="all">Match All</label>
              </div>
              <footer>
                <button type="button" class="btn soft" id="calExTagClear">Clear</button>
                <button type="button" class="btn" id="calExTagDone">Done</button>
              </footer>
            </div>
          </div>
          <div>
            <label for="calTradesPerDay">Trades/Day (first N)</label><br/>
            <input type="number" id="calTradesPerDay" min="1" step="1" placeholder="All" style="width:120px" />
          </div>
          <div>
            <label for="calNthTrade">Nth Trade/Day</label><br/>
            <input type="number" id="calNthTrade" min="1" step="1" placeholder="—" style="width:120px" />
          </div>
          <div>
            <label for="calTrailToggle">Trail Profit</label><br/>
            <input type="checkbox" id="calTrailToggle" />
          </div>
          
          <div style="display:flex; gap:8px; align-items:flex-end">
            <button class="btn" id="calApply">Apply</button>
            <button class="btn soft" id="calClear">Clear</button>
          </div>
          <div style="margin-left:16px">
            <label>Unit Selection</label><br/>
            <div class="seg" aria-label="Units">
              <button id="calUnitR" class="active">Unit: R</button>
              <button id="calUnitDollarFlat">Unit: $ (flat)</button>
              <button id="calUnitDollarComp">Unit: $ (comp)</button>
              <button id="calUnitDollarCompSteps">Unit: $ (comp steps)</button>
              <button id="calUnitDollarCompDaily">Unit: $ (comp daily)</button>
            </div>
          </div>
        </div>
      </div>

    <!-- Calendar Sections (draggable) -->
      <style>
        .calendar{ background:var(--card); border:1px solid var(--line); border-radius:12px; padding:8px; }
        /* 5 weekdays + 1 weekly summary column */
        .cal-grid{ display:grid; grid-template-columns:repeat(6,1fr); gap:6px; align-items:stretch; }
        .cal-head{ color:var(--muted); font-size:12px; text-align:center; padding:6px 0; }
        .cal-cell{ min-height:92px; border:1px solid var(--line); border-radius:8px; padding:6px; background:var(--card-2); display:flex; flex-direction:column; gap:4px }
        .cal-cell .date{ font-weight:800; font-size:12px; color:#cfd2e6 }
        .cal-cell .daytype.win{ color:var(--green); font-weight:800 }
        .cal-cell .daytype.lose{ color:var(--red); font-weight:800 }
        .cal-week-cell{ position:relative; overflow:hidden; min-height:92px; border:2px solid #2b315d; border-radius:8px; padding:8px; background:#101542; color:#cfd2e6; font-size:12px; display:flex; flex-direction:column; gap:4px; transition:border-color .3s ease, box-shadow .3s ease, background .3s ease, color .3s ease }
        .cal-week-cell::after{ content:""; position:absolute; inset:0; pointer-events:none; opacity:0; transition:opacity .4s ease; }
        @keyframes calShimmer{ 0%{transform:translateX(-60%);} 50%{transform:translateX(60%);} 100%{transform:translateX(160%);} }
        .cal-week-cell.win{ border-color:rgba(39,190,105,.45); box-shadow:0 0 16px rgba(39,190,105,.25); }
        .cal-week-cell.win::after{ background:linear-gradient(120deg, rgba(39,190,105,0) 0%, rgba(255,255,255,0.38) 45%, rgba(39,190,105,0) 100%); opacity:.55; animation:calShimmer 3.5s ease-in-out infinite; }
        .cal-week-cell.be{ border-color:rgba(255,200,87,.35); box-shadow:0 0 14px rgba(255,200,87,.18); background:linear-gradient(135deg, rgba(255,200,87,.08), rgba(19,24,60,.95)); }
        .cal-week-cell.be::after{ background:radial-gradient(circle at top right, rgba(255,200,87,.28), rgba(255,200,87,0) 65%); opacity:.4; }
        .cal-week-cell.lose{ border-color:rgba(255,90,107,.25); box-shadow:0 0 8px rgba(255,90,107,.12); background:#0c1231; color:rgba(207,210,230,.85); }
        .cal-week-cell.lose::after{ background:radial-gradient(circle at bottom left, rgba(255,90,107,.18), rgba(255,90,107,0) 60%); opacity:.25; }
        .cal-week-title{ font-weight:900; letter-spacing:.3px; color:#9fb3ff; margin-bottom:2px; position:relative; z-index:1; }
        .cal-week-cell .stat{ display:block; font-size:11px; position:relative; z-index:1; }
        .cal-week-bar{ position:relative; width:100%; height:6px; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden; margin-top:auto }
        .cal-week-bar .fill{ position:absolute; top:0; bottom:0; border-radius:999px; }
        .cal-month-summary{ margin-top:8px; background:#1a1f42; border:1px solid var(--line); border-radius:10px; padding:10px; }
        .cal-month-summary .cal-streaks{ display:flex; gap:18px; flex-wrap:wrap; margin-top:12px; font-size:13px; color:var(--muted); }
        .cal-month-summary .cal-streaks span strong{ color:var(--text); font-weight:700; margin-left:4px; }
      </style>
      <div id="calSections" class="report-sections">
        <div class="card report-section" data-section="calgrid">
          <div class="calendar" id="calendar">
            <div class="cal-grid" id="calGrid"></div>
            <div class="cal-month-summary" id="calMonthSummary"></div>
          </div>
        </div>

        <!-- Rolling Win Rate (Calendar) -->
        <div class="card report-section" data-section="calrolling">
          <div class="chart-head" style="display:flex; align-items:center; gap:10px">
            <h3 style="margin:0">Rolling Win Rate (Month)</h3>
            <div class="spacer"></div>
            <div class="seg" id="calRollWinSeg" aria-label="Rolling window (calendar)">
              <button data-n="5">Last 5</button>
              <button data-n="10">Last 10</button>
              <button data-n="20" class="active">Last 20</button>
            </div>
            <div class="seg" id="calRollWinThreshWrap" aria-label="Threshold (calendar)" style="margin-left:8px; padding:4px 8px; display:flex; align-items:center; gap:6px">
              <span class="muted" style="font-size:12px">Thresh</span>
              <input type="number" id="calRollWinThresh" min="0" max="100" step="1" style="width:70px" />
              <span class="muted" style="font-size:12px">%</span>
            </div>
          </div>
          <div style="height:280px"><canvas id="calRollingWRChart" aria-label="Calendar rolling win rate"></canvas></div>
        </div>

        <!-- Setup Performance for selected month -->
        <div class="card report-section" data-section="calsetup" id="calSetupSection">
          <h3>Setup Performance</h3>
          <div id="calSetupCards" class="grid cols-3" style="margin-top:10px"></div>
        </div>
      </div>
    </section>

    <!-- JOURNAL TAB -->
    <section id="tab-journal" class="tabcontent stack" role="tabpanel" aria-labelledby="tabBtn-journal">
      <div class="card">
        <div class="journal-filter-bar">
          <div class="seg" id="journalModeSeg" role="tablist" aria-label="Journal views">
            <button data-mode="daily" class="active" aria-selected="true">Daily</button>
            <button data-mode="weekly" aria-selected="false">Weekly</button>
            <button data-mode="custom" aria-selected="false">Personal Journals</button>
          </div>
          <input type="search" id="journalSearch" placeholder="Search titles or notes…" aria-label="Search journal entries" />
          <div class="chip-input" id="journalTagFilterBox">
            <span class="sr" id="journalTagFilterLabel">Journal tag filter</span>
            <input type="text" id="journalTagFilterInput" aria-labelledby="journalTagFilterLabel" placeholder="Filter by tag & Enter" />
          </div>
          <button class="btn soft" id="journalClearFilters">Clear Filters</button>
        </div>
        <div id="journalModeControls" class="journal-custom-actions"></div>
        <div class="journal-layout">
          <div>
            <div id="journalList" class="journal-list" role="listbox" aria-label="Journal entries"></div>
            <div class="journal-empty" id="journalEmptyState">No entries yet. Use the controls above to create one.</div>
          </div>
          <div>
            <div id="journalStatsWrap" class="journal-stats"></div>
            <div class="card" id="journalDetailCard" style="margin-top:var(--gap)">
              <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px">
                <input type="text" id="journalEntryTitle" placeholder="Entry title" style="flex:1" />
                <button class="icon-btn" id="journalPinBtn" data-pinned="false" title="Pin entry" aria-pressed="false" aria-label="Pin entry" style="width:32px; height:32px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:18px;">☆</button>
              </div>
              <div class="journal-toolbar" id="journalMainToolbar">
                <label for="journalFontSize" class="sr">Font size</label>
                <select id="journalFontSize" aria-label="Font size">
                  <option value="14">14px</option>
                  <option value="16" selected>16px</option>
                  <option value="18">18px</option>
                  <option value="20">20px</option>
                  <option value="22">22px</option>
                </select>
                <button type="button" data-action="bold" title="Bold"><strong>B</strong></button>
                <button type="button" data-action="italic" title="Italic"><em>I</em></button>
                <button type="button" data-action="underline" title="Underline"><u>U</u></button>
                <button type="button" data-action="strike" title="Strikethrough"><span style="text-decoration:line-through">S</span></button>
                <button type="button" data-action="h1" title="Heading 1">H1</button>
                <button type="button" data-action="h2" title="Heading 2">H2</button>
                <button type="button" data-action="h3" title="Heading 3">H3</button>
                <button type="button" data-action="bullet" title="Bulleted list">• List</button>
                <button type="button" data-action="number" title="Numbered list">1. List</button>
                <button type="button" data-action="quote" title="Quote">❝</button>
                <button type="button" data-action="clear" title="Clear formatting">Tx</button>
              </div>
              <div id="journalEntryEditor" class="journal-editor" contenteditable="true" data-placeholder="Select or create an entry to start writing." aria-label="Journal entry"></div>
              <div class="journal-tags">
                <label for="journalTagInput" style="display:block; margin-bottom:6px">Tags</label>
                <div class="chip-input" id="journalTagBox">
                  <span class="sr" id="journalTagLabel">Journal entry tags</span>
                  <input type="text" id="journalTagInput" aria-labelledby="journalTagLabel" placeholder="Add tag and press Enter" />
                </div>
              </div>
              <div class="journal-meta" style="gap:8px; align-items:center; font-size:12px; color:var(--muted)">
                <div id="journalEntryInfo">No entry selected.</div>
              </div>
              <div id="journalScreenshotWrap" class="journal-screenshots"></div>
              <div class="journal-meta" style="justify-content:flex-end">
                <button class="btn soft" id="journalDuplicateBtn" title="Duplicate entry">Duplicate</button>
                <button class="btn soft danger" id="journalDeleteBtn" title="Delete entry">Delete</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- BACKTEST TAB -->
    <section id="tab-backtest" class="tabcontent active stack" role="tabpanel" aria-labelledby="tabBtn-backtest">
      <div class="grid cols-2" style="margin-top:12px">
        <!-- Left: Day stats -->
        <div class="grid">
          <div class="card">
            <h3 style="display:flex; align-items:center; justify-content:space-between">Day Stats (<span id="dayLabel">—</span>)
              <span style="display:flex; align-items:center; gap:8px; font-size:12px; color:var(--muted)">
                <label for="btTrailToggle">Trail Profit</label>
                <input type="checkbox" id="btTrailToggle" />
              </span>
            </h3>
            <div class="grid cols-3" style="margin-top:10px">
              <div class="kpi"><div class="label">Wins</div><div class="value" id="wins">0</div></div>
              <div class="kpi"><div class="label">Losses</div><div class="value" id="losses">0</div></div>
              <div class="kpi"><div class="label">Total</div><div class="value" id="total">0</div></div>
              <div class="kpi"><div class="label">Win Rate</div><div class="value" id="winRate">0%</div></div>
              <div class="kpi"><div class="label">Total R</div><div class="value" id="totalR">0.0R</div></div>
              <div class="kpi"><div class="label">Expectancy</div><div class="value" id="expectancy">0.00R</div></div>
            </div>
          </div>

          <div class="card" style="position:relative">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:12px">
              <div style="display:flex; align-items:center; gap:10px">
                <h3 style="margin:0">Daily Journal</h3>
                <button class="icon-btn" id="toggleDayJournalPin" data-pinned="false" title="Pin this entry" aria-label="Pin this entry" aria-pressed="false" style="width:32px; height:32px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:18px;">☆</button>
              </div>
              <button class="btn soft" id="openJournalFromBacktest" title="Open full journal view">Open Journal</button>
            </div>
            <input id="dayJournalTitle" type="text" placeholder="Add a title for today…" style="width:100%; margin-top:12px" />
            <div class="journal-toolbar" id="dayJournalToolbar">
              <label for="dayJournalFontSize" class="sr">Font size</label>
              <select id="dayJournalFontSize" aria-label="Font size">
                <option value="14">14px</option>
                <option value="16" selected>16px</option>
                <option value="18">18px</option>
                <option value="20">20px</option>
              </select>
              <button type="button" data-action="bold" title="Bold"><strong>B</strong></button>
              <button type="button" data-action="italic" title="Italic"><em>I</em></button>
              <button type="button" data-action="underline" title="Underline"><u>U</u></button>
              <button type="button" data-action="strike" title="Strikethrough"><span style="text-decoration:line-through">S</span></button>
              <button type="button" data-action="h1" title="Heading 1">H1</button>
              <button type="button" data-action="h2" title="Heading 2">H2</button>
              <button type="button" data-action="h3" title="Heading 3">H3</button>
              <button type="button" data-action="bullet" title="Bulleted list">• List</button>
              <button type="button" data-action="number" title="Numbered list">1. List</button>
              <button type="button" data-action="quote" title="Quote">❝</button>
            </div>
            <div id="dayJournalEditor" class="journal-editor" contenteditable="true" data-placeholder="Optional: context for today's trades…" aria-label="Daily journal entry"></div>
            <div class="journal-tags">
              <label for="dayJournalTagInput" style="display:block; margin-bottom:6px">Tags</label>
              <div class="chip-input" id="dayJournalTagBox">
                <span class="sr" id="dayJournalTagLabel">Daily journal tags</span>
                <input id="dayJournalTagInput" type="text" placeholder="Add tag and press Enter" aria-labelledby="dayJournalTagLabel" />
              </div>
            </div>
          </div>
        </div>

        <!-- Right: Today table -->
        <div class="card">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:12px">
            <h3 style="margin:0">Today Entries</h3>
            <button class="btn soft" id="scalingChecklistShortcut" title="Open scaling checklist for this day">Scaling Checklist</button>
          </div>
          <div style="overflow:auto; max-height:480px; margin-top:8px">
            <table id="todayTable" aria-label="Today table">
              <thead>
              <tr>
                <th>No.</th>
                <th>Setup</th>
                <th>Result</th>
                <th>R</th>
                <th>Trail R</th>
                <th>Tag</th>
                <th>Note</th>
                <th>Action</th>
              </tr>
              </thead>
              <tbody id="todayTableBody">
                <tr><td colspan="8" class="muted" style="text-align:center">No data for this day yet</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- Screenshot section -->
      <div class="card shot-card" style="margin-top:16px">
        <h3>Screenshot</h3>
        <div id="shotDrop" class="shot-drop" tabindex="0" aria-label="Paste area">
          <div>
            <div><strong>Click here</strong> and press <b>Ctrl/Cmd + V</b> to paste a screenshot</div>
            <div class="muted" style="margin-top:6px">Image is stored at full size and saved to the shots folder.</div>
          </div>
        </div>
        <img id="shotImg" class="shot-img" alt="Screenshot for this day" style="display:none" />
        <div class="shot-tools" id="shotTools" style="display:none">
          <button class="btn soft" id="openShot">Open in new tab</button>
          <button class="btn soft" id="clearShot">Clear Screenshot</button>
        </div>
      </div>
    </section>

<!-- ALL TRADES TAB -->
    <section id="tab-alltrades" class="tabcontent stack" role="tabpanel" aria-labelledby="tabBtn-alltrades">
      <!-- Filter bar -->
      <div class="card filterbar" id="atFilterBar">
        <div class="row">
          <div>
            <label for="atStartDate">From</label><br/>
            <input type="date" id="atStartDate" />
          </div>
          <div>
            <label for="atEndDate">To</label><br/>
            <input type="date" id="atEndDate" />
          </div>
          <div>
            <label for="atSetupSel">Setup</label><br/>
            <select id="atSetupSel">
              <option value="">Any</option>
              <option>Breakout</option>
              <option>Reversal</option>
              <option>Engulfing</option>
            </select>
          </div>
          <div>
            <label for="atResultSel">Result</label><br/>
            <select id="atResultSel">
              <option value="">Any</option>
              <option value="W">Win</option>
              <option value="B">Breakeven</option>
              <option value="L">Loss</option>
            </select>
          </div>
          <div>
            <label for="atDayTypeSel">Day Type</label><br/>
            <select id="atDayTypeSel" title="Based on full-day net R">
              <option value="">Any</option>
              <option value="Winning">Winning day</option>
              <option value="Losing">Losing day</option>
              <option value="Breakeven">Breakeven day</option>
            </select>
          </div>
          <div>
            <label for="atScenarioSel">Scenario</label><br/>
            <select id="atScenarioSel">
              <option value="S1">S1</option>
              <option value="S2">S2</option>
            </select>
          </div>
          <!-- TAG PICKER (compact) -->
          <div class="tag-picker" id="atTagPicker">
            <label>Tags</label><br/>
            <button type="button" class="btn soft tag-btn" id="atTagBtn" aria-haspopup="dialog" aria-expanded="false">Any</button>
            <select id="atTagsSel" multiple class="sr"></select>
            <div class="tag-popover" id="atTagPop" role="dialog" aria-label="Filter by tags">
              <input id="atTagSearch" class="search" type="text" placeholder="Search tags…" />
              <div id="atTagList" class="list" aria-label="Available tags"></div>
              <div class="tag-mode">
                <label><input type="radio" name="atTagMode" value="any" checked>Match Any</label>
                <label><input type="radio" name="atTagMode" value="all">Match All</label>
              </div>
              <footer>
                <button type="button" class="btn soft" id="atTagClear">Clear</button>
                <button type="button" class="btn" id="atTagDone">Done</button>
              </footer>
            </div>
          </div>
          <!-- EXCLUDE TAG PICKER (compact) -->
          <div class="tag-picker" id="atExTagPicker">
            <label>Exclude Tags</label><br/>
            <button type="button" class="btn soft tag-btn" id="atExTagBtn" aria-haspopup="dialog" aria-expanded="false">Any</button>
            <select id="atExTagsSel" multiple class="sr"></select>
            <div class="tag-popover" id="atExTagPop" role="dialog" aria-label="Exclude by tags">
              <input id="atExTagSearch" class="search" type="text" placeholder="Search tags…" />
              <div id="atExTagList" class="list" aria-label="Available tags"></div>
              <div class="tag-mode">
                <label><input type="radio" name="atExTagMode" value="any" checked>Match Any</label>
                <label><input type="radio" name="atExTagMode" value="all">Match All</label>
              </div>
              <footer>
                <button type="button" class="btn soft" id="atExTagClear">Clear</button>
                <button type="button" class="btn" id="atExTagDone">Done</button>
              </footer>
            </div>
          </div>

          <div>
            <label for="atTradesPerDay">Trades/Day (first N)</label><br/>
            <input type="number" id="atTradesPerDay" min="1" step="1" placeholder="All" style="width:120px" />
          </div>
          <div>
            <label for="atNthTrade">Nth Trade/Day</label><br/>
            <input type="number" id="atNthTrade" min="1" step="1" placeholder="—" style="width:120px" />
          </div>
          <div>
            <label for="atTrailToggle">Trail Profit</label><br/>
            <input type="checkbox" id="atTrailToggle" />
          </div>
          

          <div style="display:flex; gap:8px; align-items:flex-end">
            <button class="btn" id="atApply">Apply</button>
            <button class="btn soft" id="atClear">Clear</button>
          </div>
        </div>
      </div>

      <!-- Bulk actions -->
      <div class="bulkbar" id="atBulkBar" aria-label="Bulk actions">
        <button class="btn soft" id="atSelectAll">Select all</button>
        <button class="btn soft" id="atClearSel">Clear selection</button>
        <div class="spacer"></div>
        <input id="atBulkTagInput" type="text" placeholder="Tag to add/remove…" style="min-width:180px"/>
        <button class="btn" id="atBulkAddTag">Add tag</button>
        <button class="btn soft" id="atBulkRemoveTag">Remove tag</button>
        <button class="btn red" id="atBulkDelete">Delete selected</button>
        <button class="btn soft" id="atExport">Export All Trades CSV</button>
      </div>

      <!-- Two-pane layout -->
      <div class="alltrades-layout">
        <!-- Left: table -->
        <div class="card">
          <h3>All Trades <span id="atCount" class="muted"></span> <span id="atFilterStatus"></span></h3>
          <div class="tall-table" style="margin-top:8px">
            <table id="atTable" aria-label="All trades table">
              <thead>
                <tr>
                  <th class="col-select sticky"><input type="checkbox" id="atHeadCheck" title="Select page"/></th>
                  <th class="sticky">Date</th>
                  <th class="sticky">Setup</th>
                  <th class="sticky">Result</th>
                  <th class="sticky">R</th>
                  <th class="sticky">Tags</th>
                  <th class="col-pic sticky">Pic</th>
                </tr>
              </thead>
              <tbody id="atTbody">
                <tr><td colspan="7" class="muted" style="text-align:center">No trades yet</td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <!-- Right: preview pane -->
        <aside class="preview-pane" aria-live="polite">
          <div class="meta">
            <div>Preview</div>
            <div class="spacer"></div>
            <button class="btn soft" id="atOpenShot">Open</button>
            <button class="btn soft" id="atClearShot">Clear</button>
          </div>
          <div class="preview-holder" id="atPreviewHolder">
            <span class="muted">Hover a pic icon to preview screenshot</span>
          </div>
          <div id="atPrevMeta" class="muted" style="margin-top:8px"></div>
        </aside>
      </div>
    </section>

    <!-- REPORT TAB -->
    <section id="tab-report" class="tabcontent stack" role="tabpanel" aria-labelledby="tabBtn-report">
      <!-- Filter Bar -->
      <div class="card filterbar" id="reportFilterBar">
        <div class="row">
          <div>
            <label for="startDate">From</label><br/>
            <input type="date" id="startDate" />
          </div>

          <div>
            <label for="endDate">To</label><br/>
            <input type="date" id="endDate" />
          </div>

          <div>
            <label for="repSetupSel">Setup</label><br/>
            <select id="repSetupSel">
              <option value="">Any</option>
              <option>Breakout</option>
              <option>Reversal</option>
              <option>Engulfing</option>
            </select>
          </div>

          <div>
            <label for="repResultSel">Result</label><br/>
            <select id="repResultSel">
              <option value="">Any</option>
              <option value="W">Win</option>
              <option value="B">Breakeven</option>
              <option value="L">Loss</option>
            </select>
          </div>
          <div>
            <label for="repScenarioSel">Scenario</label><br/>
            <select id="repScenarioSel">
              <option value="S1">S1</option>
              <option value="S2">S2</option>
            </select>
          </div>

          <!-- TAG PICKER (compact) -->
          <div class="tag-picker" id="repTagPicker">
            <label>Tags</label><br/>
            <button type="button" class="btn soft tag-btn" id="repTagBtn" aria-haspopup="dialog" aria-expanded="false">Any</button>
            <select id="repTagsSel" multiple class="sr"></select>
            <div class="tag-popover" id="repTagPop" role="dialog" aria-label="Filter by tags">
              <input id="repTagSearch" class="search" type="text" placeholder="Search tags…" />
              <div id="repTagList" class="list" aria-label="Available tags"></div>
              <div class="tag-mode">
                <label><input type="radio" name="repTagMode" value="any" checked>Match Any</label>
                <label><input type="radio" name="repTagMode" value="all">Match All</label>
              </div>
              <footer>
                <button type="button" class="btn soft" id="repTagClear">Clear</button>
                <button type="button" class="btn" id="repTagDone">Done</button>
              </footer>
            </div>
          </div>
          <!-- EXCLUDE TAG PICKER (compact) -->
          <div class="tag-picker" id="repExTagPicker">
            <label>Exclude Tags</label><br/>
            <button type="button" class="btn soft tag-btn" id="repExTagBtn" aria-haspopup="dialog" aria-expanded="false">Any</button>
            <select id="repExTagsSel" multiple class="sr"></select>
            <div class="tag-popover" id="repExTagPop" role="dialog" aria-label="Exclude by tags">
              <input id="repExTagSearch" class="search" type="text" placeholder="Search tags…" />
              <div id="repExTagList" class="list" aria-label="Available tags"></div>
              <div class="tag-mode">
                <label><input type="radio" name="repExTagMode" value="any" checked>Match Any</label>
                <label><input type="radio" name="repExTagMode" value="all">Match All</label>
              </div>
              <footer>
                <button type="button" class="btn soft" id="repExTagClear">Clear</button>
                <button type="button" class="btn" id="repExTagDone">Done</button>
              </footer>
            </div>
          </div>

          <div>
            <label for="repTradesPerDay">Trades/Day (first N)</label><br/>
            <input type="number" id="repTradesPerDay" min="1" step="1" placeholder="All" style="width:120px" />
          </div>
          <div>
            <label for="repNthTrade">Nth Trade/Day</label><br/>
            <input type="number" id="repNthTrade" min="1" step="1" placeholder="—" style="width:120px" />
          </div>
          <div>
            <label for="repTrailToggle">Trail Profit</label><br/>
            <input type="checkbox" id="repTrailToggle" />
          </div>
          

          <div style="display:flex; gap:8px; align-items:flex-end">
            <button class="btn" id="applyRange">Apply</button>
            <button class="btn soft" id="clearRangeBtn">Clear</button>
          </div>

          <!-- Units selector (moved from header) placed after Apply/Clear) -->
          <div style="margin-left:16px">
            <label for="unitR">Unit Selection</label><br/>
            <div class="seg" aria-label="Units">
              <button id="unitR" class="active">Unit: R</button>
              <button id="unitDollarFlat">Unit: $ (flat)</button>
              <button id="unitDollarComp">Unit: $ (comp)</button>
              <button id="unitDollarCompSteps">Unit: $ (comp steps)</button>
              <button id="unitDollarCompDaily">Unit: $ (comp daily)</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Unit configuration panel (appears when $ modes selected) -->
      <div id="unitConfig" class="unit-config" aria-live="polite"></div>
      
      <!-- Draggable report sections wrapper -->
      <div id="reportSections" class="report-sections">

      <div class="card report-section" data-section="summary">
        <h3>Summary <span id="repFilterStatus"></span></h3>
        <div class="kpis" style="margin-top:10px">
          <div class="kpi"><div class="label">Total Trades (incl. BE)</div><div class="value" id="kpiTrades">0</div></div>
          <div class="kpi"><div class="label">Net Profit</div><div class="value" id="kpiNet">0R</div></div>
          <div class="kpi"><div class="label">Win Rate</div><div class="value" id="kpiWR">0%</div></div>
          <div class="kpi"><div class="label">Expectancy</div><div class="value" id="kpiExp">0R</div></div>
          <div class="kpi"><div class="label">Max Drawdown</div><div class="value" id="kpiDD">0R</div></div>
          <div class="kpi"><div class="label">Total Day Span</div><div class="value" id="kpiDaySpan">0</div></div>
          <div class="kpi"><div class="label">Total Month Span</div><div class="value" id="kpiMonthSpan">0</div></div>
          <div class="kpi"><div class="label">Total Quarter Span</div><div class="value" id="kpiQuarterSpan">0</div></div>
          <div class="kpi"><div class="label">Total Year Span</div><div class="value" id="kpiYearSpan">0</div></div>
          <div class="kpi"><div class="label">Avg Trades / Day</div><div class="value" id="kpiAvgPerDay">0.00</div></div>
          <div class="kpi"><div class="label">Profitable Days</div><div class="value" id="kpiProfDays">—</div></div>
          <div class="kpi"><div class="label">Profitable Weeks</div><div class="value" id="kpiProfWeeks">—</div></div>
          <div class="kpi"><div class="label">Profitable Months</div><div class="value" id="kpiProfMonths">—</div></div>
          <div class="kpi"><div class="label">Avg Win R</div><div class="value" id="kpiAvgWinR">0.00R</div></div>
          <div class="kpi"><div class="label">Avg Loss R</div><div class="value" id="kpiAvgLossR">0.00R</div></div>
        </div>
    </div>

      <div class="card report-section" data-section="profitConcentration">
        <div class="chart-head" style="display:flex; align-items:center; gap:10px">
          <h3 style="margin:0">Profit Concentration</h3>
          <div class="spacer"></div>
          <span class="muted" style="font-size:12px">Cumulative profit share vs trade count</span>
        </div>
        <div style="height:320px"><canvas id="profitConcentrationChart" aria-label="Profit concentration Pareto curve"></canvas></div>
        <div class="profit-concentration-summary" id="profitConcentrationSummary"></div>
      </div>

      <div class="card report-section" data-section="equity">
        <div class="chart-head" style="display:flex; align-items:center; gap:10px">
          <h3 style="margin:0" id="equityTitle">Cumulative Equity</h3>
          <div class="spacer"></div>
          <div class="seg" id="granSeg" aria-label="Granularity">
            <button class="active" data-gran="daily">Daily</button>
            <button data-gran="weekly">Weekly</button>
            <button data-gran="monthly">Monthly</button>
          </div>
        </div>
        <div style="height:360px"><canvas id="equityChart" aria-label="Equity chart"></canvas></div>
        <div class="grid cols-4" style="margin-top:12px">
          <div class="kpi"><div class="label">Starting Equity</div><div class="value" id="startEquity">0R</div></div>
          <div class="kpi"><div class="label">Current Equity</div><div class="value" id="currEquity">0R</div></div>
          <div class="kpi"><div class="label">Peak Equity</div><div class="value" id="peakEquity">0R</div></div>
          <div class="kpi"><div class="label">Max Drawdown</div><div class="value" id="chartDD">0R</div></div>
        </div>
      </div>

      <div class="card report-section" data-section="setup">
        <h3>Setup Performance</h3>
        <div id="setupCards" class="grid cols-3" style="margin-top:10px"></div>
      </div>

      <div class="card report-section" data-section="tagperf">
        <h3>Tag Performance</h3>
        <div style="overflow:auto; max-height:360px; margin-top:8px">
          <table aria-label="Tag performance">
            <thead>
              <tr>
                <th>Tag</th>
                <th>Trades</th>
                <th>Net</th>
                <th>Win Rate</th>
                <th>Expectancy</th>
              </tr>
            </thead>
            <tbody id="tagPerfBody">
              <tr><td colspan="5" class="muted" style="text-align:center">No tags</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Breakeven Summary -->
      <div class="card report-section" data-section="beSummary">
        <h3>Breakeven Summary</h3>
        <div class="grid cols-3" style="margin-top:10px">
          <div class="kpi"><div class="label">Breakeven Trades</div><div class="value" id="kpiBETrades">0</div></div>
          <div class="kpi"><div class="label">Breakeven Rate</div><div class="value" id="kpiBERate">0%</div></div>
          <div class="kpi"><div class="label">Top BE Setup</div><div class="value" id="kpiBETopSetup">—</div></div>
        </div>
      </div>

      <!-- Breakeven by Setup -->
      <div class="card report-section" data-section="beSetup">
        <h3>Breakeven by Setup</h3>
        <div style="overflow:auto; max-height:360px; margin-top:8px">
          <table aria-label="Breakeven by Setup">
            <thead>
              <tr>
                <th>Setup</th>
                <th>BE Trades</th>
                <th>BE % of Setup</th>
                <th>Total Trades</th>
              </tr>
            </thead>
            <tbody id="beSetupBody">
              <tr><td colspan="4" class="muted" style="text-align:center">No data</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Breakeven by Tag -->
      <div class="card report-section" data-section="beTag">
        <h3>Breakeven by Tag</h3>
        <div style="overflow:auto; max-height:360px; margin-top:8px">
          <table aria-label="Breakeven by Tag">
            <thead>
              <tr>
                <th>Tag</th>
                <th>BE Trades</th>
                <th>BE % of Tag</th>
                <th>Total Trades</th>
              </tr>
            </thead>
            <tbody id="beTagBody">
              <tr><td colspan="4" class="muted" style="text-align:center">No tags</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Breakeven Trend -->
      <div class="card report-section" data-section="beTrend">
        <div class="chart-head" style="display:flex; align-items:center; gap:10px">
          <h3 style="margin:0">Breakeven Trend</h3>
          <div class="spacer"></div>
          <div class="muted">Monthly BE %</div>
        </div>
        <div style="height:280px"><canvas id="beTrendChart" aria-label="Breakeven trend"></canvas></div>
      </div>

      <!-- Trade R Distribution (full row) -->
      <div class="card report-section" data-section="rDist">
        <h3>Trade R Distribution</h3>
        <div style="height:280px"><canvas id="rDistChart" aria-label="Trade R distribution"></canvas></div>
      </div>

      <!-- Rolling Win Rate (full row) -->
      <div class="card report-section" data-section="rollingWR">
          <div class="chart-head" style="display:flex; align-items:center; gap:10px">
            <h3 style="margin:0">Rolling Win Rate</h3>
            <div class="spacer"></div>
            <div class="seg" id="rollWinSeg" aria-label="Rolling window">
              <button data-n="5">Last 5</button>
              <button data-n="10">Last 10</button>
              <button data-n="20" class="active">Last 20</button>
            </div>
            <div class="seg" id="rollWinThreshWrap" aria-label="Threshold" style="margin-left:8px; padding:4px 8px; display:flex; align-items:center; gap:6px">
              <span class="muted" style="font-size:12px">Thresh</span>
              <input type="number" id="rollWinThresh" min="0" max="100" step="1" style="width:70px" />
              <span class="muted" style="font-size:12px">%</span>
            </div>
          </div>
        <div style="height:280px"><canvas id="rollingWRChart" aria-label="Rolling win rate"></canvas></div>
      </div>

      <div class="card report-section" data-section="weeklyNet">
        <div class="chart-head" style="display:flex; align-items:center; gap:10px">
          <h3 style="margin:0" id="periodNetTitle">Period Net</h3>
          <div class="spacer"></div>
          <div class="seg" id="periodNetSeg" aria-label="Period">
            <button class="active" data-period="weekly">Weekly</button>
            <button data-period="monthly">Monthly</button>
            <button data-period="quarterly">Quarterly</button>
          </div>
        </div>
        <div style="height:280px"><canvas id="weeklyNetChart" aria-label="Period net"></canvas></div>
      </div>

      <div class="card report-section" data-section="drawdownTime">
        <h3>Drawdown Over Time</h3>
        <div style="height:280px"><canvas id="ddTimeChart" aria-label="Drawdown over time"></canvas></div>
      </div>

      <div class="card report-section" data-section="topDrawdowns">
        <h3>Top Drawdown Periods</h3>
        <p class="muted" style="margin-top:4px">Ranked by depth with recovery stats. Uses current filters, trail settings, and units.</p>
        <div id="topDrawdownBody" style="margin-top:12px"></div>
      </div>

      <div class="grid cols-2 report-section" data-section="dailyPeriodic">
        <div class="card">
          <h3>Daily Outcomes</h3>
          <div class="grid cols-3" style="margin-top:8px">
            <div class="kpi"><div class="label">Winning Days</div><div class="value" id="winDays">0 (0%)</div></div>
            <div class="kpi"><div class="label">Losing Days</div><div class="value" id="loseDays">0 (0%)</div></div>
            <div class="kpi"><div class="label">Breakeven Days</div><div class="value" id="beDays">0 (0%)</div></div>
          </div>
        </div>

        <div class="card">
          <h3>Periodic Average</h3>
          <div class="grid cols-3" style="margin-top:8px">
            <div class="kpi"><div class="label">Daily Avg</div><div class="value" id="avgDaily">0R</div></div>
            <div class="kpi"><div class="label">Weekly Avg</div><div class="value" id="avgWeekly">0R</div></div>
            <div class="kpi"><div class="label">Monthly Avg</div><div class="value" id="avgMonthly">0R</div></div>
          </div>
        </div>
      </div>

      <div class="grid cols-2 report-section" data-section="streaksMonthly">
        <div class="card">
          <h3>Losing Streak Frequency (≥2) — by Trades</h3>
          <div style="overflow:auto; max-height:380px; margin-top:8px">
            <table id="streakTable">
              <thead><tr><th>Consecutive Losing Trades</th><th>Count</th></tr></thead>
              <tbody id="streakBody"><tr><td colspan="2" class="muted" style="text-align:center">No data</td></tr></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <h3>Monthly Performance</h3>
          <div style="overflow:auto; max-height:380px; margin-top:8px">
            <table id="monthlyTable">
              <thead>
                <tr><th>Month</th><th>Trades</th><th>Net</th><th>Win %</th><th>Exp</th><th>Max DD</th></tr>
              </thead>
              <tbody id="monthlyBody"><tr><td colspan="6" class="muted" style="text-align:center">No data</td></tr></tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- Weekday Performance (Mon–Fri) -->
      <div class="card report-section" data-section="weekday">
        <div class="chart-head" style="display:flex; align-items:center; gap:10px">
          <h3 style="margin:0">Weekday Performance</h3>
          <div class="spacer"></div>
          <div class="seg" id="weekdayViewSeg">
            <button data-view="table" class="active">Table</button>
            <button data-view="chart">Chart</button>
          </div>
        </div>
        <div id="weekdayTableWrap" style="overflow:auto; max-height:380px; margin-top:8px">
          <table id="weekdayTable">
            <thead>
              <tr><th>Day</th><th>Trades</th><th>Net</th><th>Win %</th><th>Exp</th></tr>
            </thead>
            <tbody id="weekdayBody"><tr><td colspan="5" class="muted" style="text-align:center">No data</td></tr></tbody>
          </table>
        </div>
        <div id="weekdayChartWrap" style="display:none; height:280px; margin-top:8px">
          <canvas id="weekdayNetChart" aria-label="Weekday Net R"></canvas>
        </div>
      </div>

      <!-- Calendar Month Performance (Jan–Dec across years) -->
      <div class="card report-section" data-section="calmonth">
        <div class="chart-head" style="display:flex; align-items:center; gap:10px">
          <h3 style="margin:0">Calendar Month Performance</h3>
          <div class="spacer"></div>
          <div class="seg" id="calMonthViewSeg">
            <button data-view="table" class="active">Table</button>
            <button data-view="chart">Chart</button>
          </div>
        </div>
        <div id="calMonthTableWrap" style="overflow:auto; max-height:380px; margin-top:8px">
          <table id="calMonthTable">
            <thead>
              <tr><th>Month</th><th>Trades</th><th>Net</th><th>Win %</th><th>Exp</th></tr>
            </thead>
            <tbody id="calMonthBody"><tr><td colspan="5" class="muted" style="text-align:center">No data</td></tr></tbody>
          </table>
        </div>
        <div id="calMonthChartWrap" style="display:none; height:280px; margin-top:8px">
          <canvas id="calMonthNetChart" aria-label="Calendar Month Net R"></canvas>
        </div>
      </div>

      <!-- Quarterly Performance (Q1–Q4 across years) -->
      <div class="card report-section" data-section="quarter">
        <div class="chart-head" style="display:flex; align-items:center; gap:10px">
          <h3 style="margin:0">Quarterly Performance</h3>
          <div class="spacer"></div>
          <div class="seg" id="quarterViewSeg">
            <button data-view="table" class="active">Table</button>
            <button data-view="chart">Chart</button>
          </div>
        </div>
        <div id="quarterTableWrap" style="overflow:auto; max-height:380px; margin-top:8px">
          <table id="quarterTable">
            <thead>
              <tr><th>Quarter</th><th>Trades</th><th>Net</th><th>Win %</th><th>Exp</th></tr>
            </thead>
            <tbody id="quarterBody"><tr><td colspan="5" class="muted" style="text-align:center">No data</td></tr></tbody>
          </table>
        </div>
        <div id="quarterChartWrap" style="display:none; height:280px; margin-top:8px">
          <canvas id="quarterNetChart" aria-label="Quarterly Expectancy"></canvas>
        </div>
      </div>
      </div> <!-- /reportSections -->
    </section>
<!-- ANALYTICS TAB -->
    <section id="tab-analytics" class="tabcontent stack" role="tabpanel" aria-labelledby="tabBtn-analytics">
      <!-- Run settings on top -->
      <div class="card" style="position:relative">
        <h3>Run Settings <span class="help" data-help="Choose the data window and simulation parameters. Use the Report filters if checked; otherwise all data is used.">?</span></h3>
        <div class="grid cols-3" style="margin-top:8px">
          <div>
            <label>Use Report Filter <span class="help" data-help="When enabled, analytics use the same filters selected in the Report tab (date range, setup, tags, etc.)">?</span></label><br/>
            <input type="checkbox" id="anaUseFilter" checked />
          </div>
          <div>
            <label>Trades Horizon <span class="help" data-help="How many trades to project in Monte Carlo simulations.">?</span></label>
            <input type="number" id="anaHorizon" min="1" step="1" value="100" style="width:100%">
          </div>
          <div>
            <label>Simulations <span class="help" data-help="Number of Monte Carlo paths to simulate. More increases stability at the cost of speed.">?</span></label>
            <input type="number" id="anaSims" min="100" step="100" value="10000" style="width:100%">
          </div>
        </div>

        <div class="grid cols-3" style="margin-top:8px">
          <div>
            <label>Block Size (streaks) <span class="help" data-help="Block bootstrap size to preserve streakiness. 1 = IID; larger values preserve losing/winning runs.">?</span></label>
            <input type="number" id="anaBlock" min="1" step="1" value="1" style="width:100%">
          </div>
          <div>
            <label>Bootstrap Resamples <span class="help" data-help="Number of bootstrap resamples to estimate expectancy confidence interval.">?</span></label>
            <input type="number" id="anaBoot" min="100" step="100" value="10000" style="width:100%">
          </div>
          <div>
            <label>Seed (optional) <span class="help" data-help="Fixes the random number generator for reproducible results.">?</span></label>
            <input type="number" id="anaSeed" step="1" style="width:100%">
          </div>
        </div>

        <div style="display:flex; align-items:center; gap:8px; margin-top:12px">
          <button class="btn blue" id="anaRun">Run Analytics</button>
          <button class="btn soft" id="anaClear">Clear Results</button>
          <span class="muted" id="anaStatus"></span>
        </div>

        <div class="progress" style="margin-top:10px"><div id="anaProg"></div></div>
        <div class="card" style="margin-top:12px; background:#1a1f42">
          <div class="code" id="anaMeta">—</div>
        </div>
      </div>

      <!-- Confidence full width -->
      <div class="card" style="position:relative">
        <h3>Confidence <span class="help" data-help="Bootstrap-based confidence for expectancy (R/trade) and Wilson interval for win rate.">?</span></h3>
        <div class="grid cols-2">
          <div>
            <div class="kpi"><div class="label">Expectancy (R/trade) — 95% Bootstrap CI</div><div class="value" id="ciExp">—</div></div>
            <div style="height:280px; margin-top:8px"><canvas id="bootChart"></canvas></div>
          </div>
          <div>
            <div class="kpi"><div class="label">Win Rate — 95% Wilson CI</div><div class="value" id="ciWR">—</div></div>
            <div class="muted" style="margin-top:6px">Wilson interval assumes IID; streakiness is modeled in Monte Carlo via block sampling.</div>
          </div>
        </div>
      </div>

      <!-- Monte Carlo full width -->
      <div class="card" style="position:relative">
        <h3>Monte Carlo Projections (in R) <span class="help" data-help="Simulate future trade paths from your historical outcomes. Fan shows percentile bands; histograms summarize final outcomes and max drawdowns.">?</span></h3>
        <div class="grid cols-2">
          <div style="height:320px"><canvas id="mcFan"></canvas></div>
          <div style="height:320px"><canvas id="mcFinalHist"></canvas></div>
        </div>
        <div class="grid cols-2" style="margin-top:8px">
          <div style="height:280px"><canvas id="mcDDHist"></canvas></div>
          <div class="grid">
            <div class="kpi"><div class="label">Mean Final Outcome</div><div class="value" id="mcMean">—</div></div>
            <div class="kpi"><div class="label">90% Range</div><div class="value" id="mcRange">—</div></div>
            <div class="kpi"><div class="label">Median Final Outcome</div><div class="value" id="mcMedian">—</div></div>
            <div class="kpi"><div class="label">Avg Max Drawdown</div><div class="value" id="mcAvgDD">—</div></div>
            <div class="kpi"><div class="label">DD 5–95%</div><div class="value" id="mcDDRange">—</div></div>
            <div class="kpi"><div class="label">Prob. Finish Negative</div><div class="value" id="mcNegProb">—</div></div>
          </div>
        </div>
        <div class="grid cols-2" style="margin-top:8px; align-items:end">
          <div>
            <label for="anaRuinThresh">Ruin threshold (R) <span class="help" data-help="Probability that maximum drawdown during the horizon exceeds this R threshold across simulations.">?</span></label><br/>
            <input type="number" id="anaRuinThresh" min="0" step="0.5" value="10" style="width:140px" />
          </div>
          <div class="kpi"><div class="label">P(hit ≥ threshold)</div><div class="value" id="mcRuinProb">—</div></div>
        </div>
      </div>
    </section>
    
    <section id="tab-scaling" class="tabcontent stack" role="tabpanel" aria-labelledby="tabBtn-scaling">
      <div class="grid scaling-layout">
        <div class="stack">
          <div class="card" id="scalingDailyCard">
            <div class="scaling-daily-header">
              <div class="scaling-daily-title">
                <h3>Daily Checklist</h3>
                <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                  <button class="btn soft small" id="scalingEditChecklistBtn">Edit Template</button>
                  <button class="btn soft small" id="scalingCheckAllBtn">Check All</button>
                </div>
              </div>
              <div class="scaling-date-control">
                <label for="scalingDateInput">Date</label>
                <input type="date" id="scalingDateInput" />
              </div>
            </div>
            <div class="scaling-daily-meta">
              <span>Trades (Scenario 1): <strong id="scalingTradesForDay">0</strong></span>
              <span>Completed: <strong id="scalingCompleteCount">0</strong></span>
              <span>Missed: <strong id="scalingMissCount">0</strong></span>
            </div>
            <div id="scalingChecklist" class="scaling-checklist" role="group" aria-label="Scaling daily checklist"></div>
            <div class="scaling-log-actions">
              <button class="btn blue big" id="scalingSaveLogBtn">Save Daily Log</button>
            </div>
            <div class="scaling-feedback" id="scalingLogFeedback"></div>
          </div>
        </div>

        <div class="stack">
          <div class="card" id="scalingLevelsCard">
            <div class="sizing-head">
              <div class="sizing-title">
                <h3>Sizing License</h3>
                <button class="icon-btn" id="sizingInfoBtn" title="View all license tiers" aria-label="View all sizing license tiers">?</button>
              </div>
              <div class="scaling-ladder-controls">
                <label for="scalingAnchorInput">Start date</label>
                <input type="date" id="scalingAnchorInput" />
              </div>
            </div>
            <div id="sizingCurrentCard" class="sizing-current" aria-live="polite"></div>
            <div class="scaling-ladder-status scaling-status" id="scalingStatusMessage">Log your first day to begin.</div>
            <div class="scaling-advance-wrap">
              <button class="btn big" id="scalingAdvanceBtn" disabled>Advance Level</button>
              <button class="btn soft" id="scalingResetBtn">Reset to L0</button>
            </div>
          </div>

          <div class="card" id="scalingHistoryCard">
            <div class="scaling-log-header">
              <h3>Fail Log</h3>
            </div>
            <div class="scaling-log-table-wrap">
              <table id="scalingFailTable" aria-label="Scaling fail log">
                <thead>
                  <tr>
                    <th>Date</th>
                    <th>Level</th>
                    <th>Trades</th>
                    <th>Misses</th>
                    <th>Missed Rules</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr><td colspan="6" class="muted">No failed days logged</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
      <div class="card" id="masteryCurveCard" style="margin-top:var(--block-gap)">
        <div class="chart-head" style="display:flex; align-items:center; gap:10px">
          <h3 style="margin:0">Mastery Curve</h3>
          <div class="spacer"></div>
          <div class="seg" id="masteryGranSeg" aria-label="Mastery granularity">
            <button class="active" data-gran="daily">Daily</button>
            <button data-gran="weekly">Weekly</button>
            <button data-gran="monthly">Monthly</button>
          </div>
        </div>
        <div style="height:320px"><canvas id="masteryCurveChart" aria-label="Mastery curve"></canvas></div>
      </div>
    </section>

    <div id="checklistModalBackdrop" class="modal-backdrop" aria-hidden="true"></div>
    <div id="checklistModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="checklistModalTitle">
      <h4 id="checklistModalTitle">Edit Checklist Template</h4>
      <p class="muted" id="checklistModalSubtitle" style="margin:4px 0 12px">Changes apply from <span id="checklistEffectiveLabel"></span> onward.</p>
      <div id="checklistEditorSections" class="checklist-editor"></div>
      <div class="row" style="justify-content:space-between; gap:10px; margin-top:12px; flex-wrap:wrap;">
        <button class="btn soft" id="checklistCancelBtn">Cancel</button>
        <div style="display:flex; gap:8px;">
          <button class="btn green" id="checklistSaveBtn">Save Template</button>
        </div>
      </div>
    </div>

    <div id="sizingInfoBackdrop" class="modal-backdrop" aria-hidden="true"></div>
    <div id="sizingInfoModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="sizingInfoTitle">
      <h4 id="sizingInfoTitle">Sizing License Tiers</h4>
      <p class="muted" style="margin:4px 0 12px">Progress through each tier by completing 20 compliant trade days with no more than one miss.</p>
      <div id="sizingInfoList" class="sizing-info-list"></div>
      <div class="row" style="justify-content:flex-end; gap:10px; margin-top:14px;">
        <button class="btn soft" id="sizingInfoClose">Close</button>
      </div>
    </div>

    <!-- COMPARE TAB -->
    <section id="tab-compare" class="tabcontent stack" role="tabpanel" aria-labelledby="tabBtn-compare">
      <div class="card compare-filter-card">
        <div style="display:flex; align-items:center; gap:12px; flex-wrap:wrap;">
          <h3 style="margin:0">Shared Filters</h3>
          <span class="muted" style="font-size:12px">Applies to both studies</span>
        </div>
        <div class="compare-filter-grid">
          <div>
            <label for="compareFilterStart">Start Date</label>
            <input type="date" id="compareFilterStart" />
          </div>
          <div>
            <label for="compareFilterEnd">End Date</label>
            <input type="date" id="compareFilterEnd" />
          </div>
          <div>
            <label for="compareFilterSetups">Setups (comma separated)</label>
            <input type="text" id="compareFilterSetups" placeholder="e.g. Breakout, Reversal" />
          </div>
          <div>
            <label>Outcomes</label>
            <div class="compare-outcome-checks">
              <label><input type="checkbox" value="W" class="compareFilterOutcome"> Win</label>
              <label><input type="checkbox" value="L" class="compareFilterOutcome"> Loss</label>
              <label><input type="checkbox" value="B" class="compareFilterOutcome"> Breakeven</label>
            </div>
          </div>
          <div>
            <label for="compareFilterIncludeTags">Include Tags</label>
            <input type="text" id="compareFilterIncludeTags" placeholder="e.g. London, Earnings" />
          </div>
          <div>
            <label for="compareFilterExcludeTags">Exclude Tags</label>
            <input type="text" id="compareFilterExcludeTags" placeholder="e.g. Friday" />
          </div>
        </div>
        <div class="btn-row" style="justify-content:flex-end;">
          <button class="btn soft" id="compareClearFilters">Clear</button>
          <button class="btn blue" id="compareApplyFilters">Apply Filters</button>
        </div>
      </div>

      <div class="compare-layout">
        <div class="card compare-slot" data-slot="left">
          <header>
            <h3>Study A</h3>
            <div class="muted" id="compareName-left">No dataset</div>
          </header>
          <div class="btn-row" role="group" aria-label="Study A load actions">
            <button class="btn soft" data-compare-action="use-current" data-slot="left">Use Current Data</button>
            <button class="btn soft" data-compare-action="load-json" data-slot="left">Load JSON…</button>
            <button class="btn soft" data-compare-action="load-bundle" data-slot="left">Load Bundle…</button>
            <button class="btn soft" data-compare-action="load-folder" data-slot="left">Load Folder…</button>
          </div>
          <input type="file" id="compareJson-left" data-slot="left" accept="application/json,.json" hidden>
          <input type="file" id="compareBundle-left" data-slot="left" accept="application/zip,.zip" hidden>
          <div class="compare-empty" id="compareEmpty-left">Load an exported study to begin.</div>
          <div class="compare-meta" id="compareMeta-left" hidden></div>
          <div>
            <div class="muted" style="font-size:12px">Top Setups</div>
            <div class="compare-tag-list" id="compareSetups-left"></div>
          </div>
        </div>

        <div class="card compare-slot" data-slot="right">
          <header>
            <h3>Study B</h3>
            <div class="muted" id="compareName-right">No dataset</div>
          </header>
          <div class="btn-row" role="group" aria-label="Study B load actions">
            <button class="btn soft" data-compare-action="use-current" data-slot="right">Use Current Data</button>
            <button class="btn soft" data-compare-action="load-json" data-slot="right">Load JSON…</button>
            <button class="btn soft" data-compare-action="load-bundle" data-slot="right">Load Bundle…</button>
            <button class="btn soft" data-compare-action="load-folder" data-slot="right">Load Folder…</button>
          </div>
          <input type="file" id="compareJson-right" data-slot="right" accept="application/json,.json" hidden>
          <input type="file" id="compareBundle-right" data-slot="right" accept="application/zip,.zip" hidden>
          <div class="compare-empty" id="compareEmpty-right">Load an exported study to begin.</div>
          <div class="compare-meta" id="compareMeta-right" hidden></div>
          <div>
            <div class="muted" style="font-size:12px">Top Setups</div>
            <div class="compare-tag-list" id="compareSetups-right"></div>
          </div>
        </div>
      </div>

      <div class="card compare-summary" style="margin-top:var(--block-gap)">
        <h3 style="margin:0">Comparison Summary</h3>
        <div class="compare-kpis" id="compareKpiWrap"></div>
        <div class="compare-note" id="compareDiffNote">Load two studies to see comparative analytics. Metrics use current trail mode settings.</div>
      </div>

      <div class="compare-charts" style="margin-top:var(--block-gap)">
        <div class="card compare-chart-card">
          <h3>Key Metrics</h3>
          <div class="compare-key-grid">
            <div class="compare-key-item">
              <strong>Net R</strong>
              <div class="mini-chart"><canvas id="compareKeyNetChart" aria-label="Net R comparison"></canvas></div>
            </div>
            <div class="compare-key-item">
              <strong>Expectancy (R/trade)</strong>
              <div class="mini-chart"><canvas id="compareKeyExpectChart" aria-label="Expectancy comparison"></canvas></div>
            </div>
            <div class="compare-key-item">
              <strong>Avg R/day</strong>
              <div class="mini-chart"><canvas id="compareKeyAvgChart" aria-label="Average R per day comparison"></canvas></div>
            </div>
            <div class="compare-key-item">
              <strong>Max Drawdown (|R|)</strong>
              <div class="mini-chart"><canvas id="compareKeyDDChart" aria-label="Max drawdown comparison"></canvas></div>
            </div>
          </div>
        </div>
        <div class="card compare-chart-card">
          <h3>Equity Over Time (R)</h3>
          <div class="chart-holder"><canvas id="compareEquityChart" aria-label="Equity comparison"></canvas></div>
        </div>
        <div class="card compare-chart-card">
          <h3>Top Setups Net R</h3>
          <div class="chart-holder"><canvas id="compareSetupChart" aria-label="Setup performance comparison"></canvas></div>
        </div>
        <div class="card compare-chart-card">
          <h3>Outcome Breakdown</h3>
          <div class="chart-holder"><canvas id="compareOutcomeChart" aria-label="Outcome breakdown comparison"></canvas></div>
        </div>
      </div>

      <div class="card compare-extended" id="compareExtendedCard">
        <h3 style="margin:0">Extended Metrics</h3>
        <div class="compare-table-scroll">
          <table class="compare-table" id="compareExtendedTable">
            <thead>
              <tr>
                <th>Metric</th>
                <th>Study A</th>
                <th>Study B</th>
                <th>Δ</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </section>
  </main>

  <!-- Toasts -->
  <div class="toast" id="toast"></div>

  <!-- Calendar Screenshot Overlay -->
  <div id="calShotOverlay" class="shot-overlay" aria-hidden="true">
    <div class="shot-modal" role="dialog" aria-modal="true" aria-label="Day Screenshot">
      <button class="shot-close" id="calShotClose" title="Close">×</button>
      <img id="calShotImg" alt="Day screenshot" />
    </div>
  </div>

<script>
  // ====== Constants & State ======
  let SETUPS = ["Breakout","Reversal","Engulfing"]; // configurable (max 6)
  const STORAGE_KEY = 'tt_desktop_v58';
  let currentDate = new Date().toISOString().slice(0,10);
  let currentSetup = SETUPS[0];
  const SCENARIOS = ["S1", "S2"];
  let activeScenario = "S1";
  let scenarioSelectionByDate = {};

  const SCALING_LEVELS = [
    { id:'L0', risk:0.5, label:'Simulator Pilot' },
    { id:'L1', risk:0.05, label:'Micro Test Pilot' },
    { id:'L2', risk:0.10, label:'Stability Operator' },
    { id:'L3', risk:0.20, label:'Risk Navigator' },
    { id:'L4', risk:0.30, label:'Velocity Controller' },
    { id:'L5', risk:0.40, label:'System Commander' },
    { id:'L6', risk:0.50, label:'Chief Operator' }
  ];
  const SCALING_TRADES_REQUIRED = 20;
  const DEFAULT_SCALING_SECTIONS = [
    {
      key:'readiness',
      title:'Physical & Mental Readiness',
      items:[
        { id:'sleep', label:'Sleep: Did I sleep before 23:00 yesterday?' },
        { id:'diet', label:'Diet: Did I eat clean, balanced meals and avoid alcohol yesterday?' },
        { id:'workout', label:'Workout: Did I complete a cardio session yesterday as planned?' },
        { id:'mindfulness', label:'Mindfulness: Did I meditate for 10 minutes before trading?' },
        { id:'environment', label:'Environment: Is my workspace clean, quiet, and distraction-free?' },
        { id:'emotional', label:'Emotional state: Do I feel calm, alert, and centered?' },
        { id:'market', label:"Market awareness: Did I review today's calendar for high-impact news?" },
        { id:'rehearsal', label:'Mental rehearsal: Did I visualize valid setups and traps before the open?' }
      ]
    },
    {
      key:'execution',
      title:'Execution Discipline',
      items:[
        { id:'system_match', label:'Did I only take trades that match my written system? (breakout/reversal/continuation as defined)' },
        { id:'marginal_pass', label:'Did I pass on marginal setups? (no huge opposing FVGs, no choppy OR bounds, etc.)' },
        { id:'candle_wait', label:'Did I wait for candle close before opening order panel?' },
        { id:'stop_pre_mark', label:'Did I pre-mark stop location before entry?' },
        { id:'calm_entry', label:'Did I enter calmly without rushing? (If I felt rushed, I should have skipped)' },
        { id:'alert_set', label:'Did I set alerts and look away after entry?' },
        { id:'trail_confirmed', label:'Did I trail only at confirmed swing points? (no premature BE moves)' },
        { id:'daily_stop', label:'Did I stop at -2R or 2 consecutive losses?' },
        { id:'time_gate', label:'Did I stop trading at 11:00 AM (or designated time gate)?' },
        { id:'avoid_flipping', label:'Did I avoid flipping trades?' },
        { id:'fomo_control', label:'Did I catch and dismiss FOMO thoughts without acting on them?' },
        { id:'loss_break', label:'After losses, did I take a break before next setup? (if felt pressure to "make it back")' }
      ]
    }
  ];
  const LEGACY_EXECUTION_IDS = Object.freeze([
    'system',
    'quality',
    'candle',
    'fomo',
    'revenge',
    'chasing',
    'sizing',
    'flips',
    'trail',
    'limits',
    'trend',
    'micromanage',
    'commentary',
    'builder'
  ]);
  const MASTERY_SECTION_KEYS = Object.freeze({ readiness:'readiness', execution:'execution' });
  const CHECKLIST_ID_PREFIX = 'chk_';
  function cloneChecklistSections(sections){
    return sections.map(section=>({
      key: section.key,
      title: section.title,
      items: Array.isArray(section.items)
        ? section.items.map(item=>({ id:item.id, label:item.label }))
        : []
    }));
  }
  function ensureChecklistIds(sections){
    if(!Array.isArray(sections)) return;
    sections.forEach(section=>{
      section.items = section.items.map(item=>{
        if(!item.id){ item.id = generateChecklistId(); }
        return item;
      });
    });
  }
  let scalingChecklistRevisions = [{ effectiveDate: null, sections: cloneChecklistSections(DEFAULT_SCALING_SECTIONS) }];
  ensureChecklistIds(scalingChecklistRevisions[0].sections);
  let scalingState = { anchorDate: null, logs:{}, advanceEvents:[] };
  let scalingComputed = {
    currentLevelIndex: 0,
    levelTrades: Array(SCALING_LEVELS.length).fill(0),
    readyToAdvance: false,
    history: [],
    failures: [],
    lastLogDate: null
  };
  let checklistDraft = null;
  let checklistDraftDate = null;

  function generateChecklistId(){
    return `${CHECKLIST_ID_PREFIX}${Math.random().toString(36).slice(2,8)}${Date.now().toString(36)}`;
  }

  function sortChecklistRevisions(){
    scalingChecklistRevisions.sort((a,b)=>{
      const aDate = a.effectiveDate || '';
      const bDate = b.effectiveDate || '';
      if(!aDate && !bDate) return 0;
      if(!aDate) return -1;
      if(!bDate) return 1;
      return aDate < bDate ? -1 : aDate > bDate ? 1 : 0;
    });
  }

  function ensureLatestExecutionChecklist(){
    if(!Array.isArray(scalingChecklistRevisions) || !Array.isArray(DEFAULT_SCALING_SECTIONS)) return;
    const executionDefault = DEFAULT_SCALING_SECTIONS.find(section=>section.key === 'execution');
    const newExecutionIds = executionDefault?.items?.map(item=>item.id) || [];
    if(!newExecutionIds.length) return;
    if(!scalingChecklistRevisions.length){
      scalingChecklistRevisions.push({
        effectiveDate: null,
        sections: cloneChecklistSections(DEFAULT_SCALING_SECTIONS)
      });
      return;
    }
    const newIdSet = new Set(newExecutionIds);
    let hasLegacy = false;
    let hasNew = false;
    scalingChecklistRevisions.forEach(rev=>{
      if(hasLegacy && hasNew) return;
      const executionSection = Array.isArray(rev?.sections)
        ? rev.sections.find(section=>section.key === 'execution')
        : null;
      if(!executionSection || !Array.isArray(executionSection.items)) return;
      if(executionSection.items.some(item=>newIdSet.has(item.id))){
        hasNew = true;
        return;
      }
      if(executionSection.items.length === LEGACY_EXECUTION_IDS.length
        && executionSection.items.every(item=>LEGACY_EXECUTION_IDS.includes(item.id))){
        hasLegacy = true;
      }
    });
    if(hasNew || !hasLegacy) return;
    const today = new Date().toISOString().slice(0,10);
    scalingChecklistRevisions.push({
      effectiveDate: today,
      sections: cloneChecklistSections(DEFAULT_SCALING_SECTIONS)
    });
  }

  function getChecklistSectionsForDate(date = null, opts = {}){
    sortChecklistRevisions();
    let sections = scalingChecklistRevisions.length
      ? scalingChecklistRevisions[0].sections
      : cloneChecklistSections(DEFAULT_SCALING_SECTIONS);
    if(date){
      for(const rev of scalingChecklistRevisions){
        if(!rev.effectiveDate || rev.effectiveDate <= date){
          sections = rev.sections;
        }
      }
    } else {
      sections = scalingChecklistRevisions[scalingChecklistRevisions.length-1]?.sections || sections;
    }
    return opts.clone ? cloneChecklistSections(sections) : sections;
  }

  function flattenChecklistIds(sections){
    const ids = [];
    sections.forEach(section=>{
      section.items.forEach(item=>{ ids.push(item.id); });
    });
    return ids;
  }

  function totalChecklistRulesForSections(sections){
    if(!Array.isArray(sections)) return 0;
    return sections.reduce((sum, section)=> sum + (section.items?.length || 0), 0);
  }

  function getChecklistSectionByKey(sections, key){
    if(!Array.isArray(sections) || !key) return null;
    return sections.find(section=> section && section.key === key) || null;
  }

  function countUncheckedForItems(checks, items){
    if(!Array.isArray(items) || !items.length) return 0;
    const map = checks && typeof checks === 'object' ? checks : {};
    let misses = 0;
    items.forEach(item=>{
      const id = item?.id;
      if(!id) return;
      if(!map[id]) misses += 1;
    });
    return misses;
  }

  function countLossesForDate(date){
    if(!date) return 0;
    const day = dailyData?.[date];
    if(!day || !Array.isArray(day._events)) return 0;
    let losses = 0;
    day._events.forEach(ev=>{
      if(getEventScenario(ev) === 'S1' && ev.outcome === 'L') losses += 1;
    });
    return losses;
  }

  function calculateMasteryDailySeries(){
    const logs = scalingState?.logs;
    if(!logs || typeof logs !== 'object') return [];
    const startDate = typeof scalingState?.anchorDate === 'string' && scalingState.anchorDate ? scalingState.anchorDate : null;
    const entries = Object.values(logs)
      .filter(log=> log && typeof log === 'object' && typeof log.date === 'string' && log.date)
      .sort((a,b)=> (a.date||'').localeCompare(b.date||''));
    const series = [];
    entries.forEach(log=>{
      const date = log.date;
      if(startDate && date < startDate) return;
      const sections = getChecklistSectionsForDate(date, {clone:false});
      const readinessSection = getChecklistSectionByKey(sections, MASTERY_SECTION_KEYS.readiness);
      const executionSection = getChecklistSectionByKey(sections, MASTERY_SECTION_KEYS.execution);
      const readinessMisses = countUncheckedForItems(log.checks, readinessSection?.items || []);
      const executionMisses = countUncheckedForItems(log.checks, executionSection?.items || []);
      const readinessTotal = readinessSection?.items?.length || 0;
      const executionTotal = executionSection?.items?.length || 0;
      const totalItems = readinessTotal + executionTotal;
      const readinessChecked = Math.max(0, readinessTotal - readinessMisses);
      const executionChecked = Math.max(0, executionTotal - executionMisses);
      const totalChecked = readinessChecked + executionChecked;
      if(totalItems > 0 && totalChecked === 0){
        return;
      }
      const totalMisses = readinessMisses + executionMisses;
      const lossCount = countLossesForDate(date);
      let score = 0;
      if(totalMisses >= 2 || readinessMisses >= 2 || executionMisses >= 2 || lossCount >= 2){
        score = -3;
      } else if(totalMisses >= 1){
        score = -1;
      } else {
        if(readinessSection?.items?.length && readinessMisses === 0) score += 1;
        if(executionSection?.items?.length && executionMisses === 0) score += 1;
      }
      series.push({ date, score, readinessMisses, executionMisses, totalMisses, lossCount });
    });
    return series;
  }

  function getMasteryCurveSeries(granularity = 'daily'){
    const daily = calculateMasteryDailySeries();
    masteryDailySeries = daily;
    if(!Array.isArray(daily) || daily.length === 0){
      return { labels: [], values: [] };
    }
    if(granularity === 'daily'){
      let cumulative = 0;
      const labels = [];
      const values = [];
      daily.forEach(entry=>{
        cumulative += entry.score;
        labels.push(dispDate(entry.date));
        values.push(cumulative);
      });
      return { labels, values };
    }
    const buckets = new Map();
    daily.forEach(entry=>{
      const date = entry.date;
      if(!date) return;
      const key = granularity === 'weekly'
        ? `${new Date(date).getUTCFullYear()}-W${String(weekKey(date)).padStart(2,'0')}`
        : date.slice(0,7);
      if(!key) return;
      if(!buckets.has(key)){
        buckets.set(key, { sum: 0, firstDate: date });
      }
      const bucket = buckets.get(key);
      bucket.sum += entry.score;
      if(date < bucket.firstDate) bucket.firstDate = date;
    });
    const sorted = Array.from(buckets.entries()).sort((a,b)=>{
      const da = a[1].firstDate;
      const db = b[1].firstDate;
      if(da < db) return -1;
      if(da > db) return 1;
      return 0;
    });
    let cumulative = 0;
    const labels = [];
    const values = [];
    sorted.forEach(([key, bucket])=>{
      cumulative += bucket.sum;
      labels.push(granularity === 'weekly' ? key : key.replace('-','/'));
      values.push(cumulative);
    });
    return { labels, values };
  }

  function renderMasteryCurve(){
    const canvas = document.getElementById('masteryCurveChart');
    if(!canvas){
      masteryCurveChart = null;
      return;
    }
    const ctx = canvas.getContext?.('2d');
    if(!ctx) return;
    if(!window.Chart){
      console.warn('Chart.js not available for mastery curve');
      return;
    }
    if(!masteryCurveChart){
      masteryCurveChart = new Chart(ctx, {
        type:'line',
        data:{ labels:[], datasets:[{ label:'Mastery Score', data:[], borderWidth:2, tension:.15, fill:true, pointRadius:0 }] },
        options:{
          responsive:true,
          maintainAspectRatio:false,
          plugins:{ legend:{ display:false } },
          scales:{
            x:{ grid:{ color:'#2b315d' } },
            y:{ grid:{ color:'#2b315d' }, title:{ display:true, text:'Score' } }
          }
        }
      });
    }
    const { labels, values } = getMasteryCurveSeries(masteryCurveGranularity);
    masteryCurveChart.data.labels = labels;
    masteryCurveChart.data.datasets[0].data = values;
    const lastVal = values.length ? values[values.length-1] : 0;
    let color = '#737ab3';
    if(values.length){
      color = lastVal > 0 ? '#27be69' : (lastVal < 0 ? '#ff5a6b' : '#ffc857');
    }
    masteryCurveChart.data.datasets[0].borderColor = color;
    masteryCurveChart.data.datasets[0].backgroundColor = color + '33';
    const labelBase = 'Mastery Score';
    const granLabel = masteryCurveGranularity === 'weekly' ? 'Weekly' : (masteryCurveGranularity === 'monthly' ? 'Monthly' : 'Daily');
    masteryCurveChart.data.datasets[0].label = `${labelBase} (${granLabel})`;
    masteryCurveChart.update();
  }

  function totalChecklistRulesForDate(date){
    return totalChecklistRulesForSections(getChecklistSectionsForDate(date));
  }

  function labelForChecklistId(id, date = null){
    if(!id) return '';
    const sections = getChecklistSectionsForDate(date, {clone:false});
    for(const section of sections){
      for(const item of section.items){
        if(item.id === id) return item.label;
      }
    }
    for(const rev of scalingChecklistRevisions){
      for(const section of rev.sections){
        for(const item of section.items){
          if(item.id === id) return item.label;
        }
      }
    }
    for(const section of DEFAULT_SCALING_SECTIONS){
      for(const item of section.items){
        if(item.id === id) return item.label;
      }
    }
    return id;
  }

  // Canonical store:
  // dailyData[date] = { note, screenshot?, _events:[{id,setup,outcome:'W'|'L',tags:[],t?,note?}] }
  let dailyData = {};
  let tagCatalog = [];
  // Journaling
  let journalData = { daily:{}, weekly:{}, custom:[], tags:[] };
  let journalMode = 'daily';
  let journalFilterTags = [];
  let journalSearchText = '';
  let selectedJournal = { type:'daily', key:null, entryId:null };
  let selectedCustomJournalId = null;
  let journalFontSize = 16;
  let dayJournalFontSize = 16;
  let journalUpdating = false;
  let quickTags = []; // tags to apply to NEW trades
  let currentFileName = null;

  // UI / report state
  let masteryCurveChart = null;
  let masteryCurveGranularity = 'daily';
  let masteryDailySeries = [];
  let equityChart = null, granularity = 'daily';
  let ddTimeChart = null;
  let rDistChart = null, rollingWRChart = null, weeklyNetChart = null, profitConcentrationChart = null;
  let weekdayNetBarChart = null, calMonthNetBarChart = null, quarterNetBarChart = null;
  let beTrendChart = null;
  let periodNetMode = 'weekly'; // 'weekly' | 'monthly' | 'quarterly'
  let rollingWinWindow = 20; // 5 | 10 | 20
  let rollingWinThresh = 20; // percent threshold for highlighting
  let calRollingWRChart = null;
  let calLayout = [];
  let unitMode = 'R', rValue = 1, flatStart = 0, compStart = 100000, compRiskPct = 0.3, compStepStart = 100000, compStepRiskPct = 0.3, compStepStepPct = 10, compDailyStart = 100000, compDailyRiskPct = 0.3;
  let reportLayout = [];
  let weekdayViewMode = 'table'; // 'table' | 'chart'
  let calMonthViewMode = 'table';
  let quarterViewMode = 'table';
  // When true, use ev.trailR override when provided
  let trailProfit = false;

  const compareSlotsState = {
    left: { label:'Study A', data:null, name:'', meta:null, stats:null },
    right: { label:'Study B', data:null, name:'', meta:null, stats:null }
  };
  const compareCharts = { key:{}, equity:null, setup:null, outcome:null };
  const compareColors = {
    left: { border:'#4ea1ff', background:'rgba(78,161,255,0.35)' },
    right: { border:'#35cc7a', background:'rgba(53,204,122,0.35)' }
  };
  let compareChartsDirty = false;
  let compareFilter = createDefaultCompareFilter();

  // Chart.js plugin to draw value labels atop bars for our two charts
  try{
    const valueLabelTargets = new Set([
      'weekdayNetChart','calMonthNetChart','quarterNetChart',
      'compareSetupChart','compareOutcomeChart',
      'compareKeyNetChart','compareKeyExpectChart','compareKeyAvgChart','compareKeyDDChart'
    ]);
    const valueLabelPlugin = {
      id: 'valueLabelPlugin',
      afterDatasetsDraw(chart){
        const id = chart?.canvas?.id;
        if(!id || !valueLabelTargets.has(id)) return;
        const formatLabel = (value)=>{
          switch(id){
            case 'weekdayNetChart':
            case 'calMonthNetChart':
            case 'quarterNetChart':
              return (unitMode==='flat' || unitMode==='comp' || unitMode==='compSteps' || unitMode==='compDaily') ? `$${Math.round(value)}` : `${fmt(value,2)}R`;
            case 'compareOutcomeChart':
              return `${fmt(value,0)}`;
            case 'compareKeyExpectChart':
            case 'compareKeyAvgChart':
              return `${fmt(value,3)}R`;
            case 'compareKeyDDChart':
              return `${fmt(Math.abs(value),2)}R`;
            default:
              return `${fmt(value,2)}R`;
          }
        };
        const {ctx} = chart; ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillStyle = '#cfd2e6';
        ctx.font = '12px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, system-ui, Avenir, Helvetica Neue, Arial, Noto Sans';
        chart.data.datasets.forEach((dataset, datasetIndex)=>{
          const meta = chart.getDatasetMeta(datasetIndex);
          if(!meta || meta.hidden) return;
          (dataset.data||[]).forEach((raw, idx)=>{
            if(raw===undefined || raw===null) return;
            const el = meta.data?.[idx]; if(!el) return;
            const v = Number(raw);
            if(!Number.isFinite(v)) return;
            const props = el.getProps(['x','y','base'], true);
            const label = formatLabel(v);
            if(!label) return;
            const positive = v >= 0;
            const offset = 6;
            const y = positive ? Math.min(props.y, props.base) - offset : Math.max(props.y, props.base) + offset + 6;
            ctx.fillText(label, props.x, y);
          });
        });
        ctx.restore();
      }
    };
    if(window.Chart && typeof Chart.register === 'function'){
      Chart.register(valueLabelPlugin);
    }
  }catch(e){ /* no-op */ }
  // Default Reward:Risk for new trades (R units)
  let rrReward = 2, rrRisk = 1;
  let reportStartDate = null, reportEndDate = null;
  let repSetup = '', repResult = '', repTags = [], repTagsAll = false;
  // Exclude tags (Report)
  let repExTags = [], repExTagsAll = false;
  let repTradesLimit = null; // first N trades per day (Report)
  let repNthTrade = null; // only the Nth trade per day (Report)
  // All Trades filter state
  let atStartDate = null, atEndDate = null, atSetup = '', atResult = '', atDayType = '', atTags = [], atTagsAll = false;
  // Exclude tags (All Trades)
  let atExTags = [], atExTagsAll = false;
  let atTradesLimit = null; // first N trades per day (All Trades)
  let atNthTrade = null; // only the Nth trade per day (All Trades)
  

  // Calendar state
  let calMonth = new Date().toISOString().slice(0,7); // YYYY-MM
  let calSetup = '', calResult = '', calTags = [], calTagsAll = false;
  // Exclude tags (Calendar)
  let calExTags = [], calExTagsAll = false;
  let calTradesLimit = null;
  let calNthTrade = null; // only the Nth trade per day (Calendar)
  

  const undoStack = [];

  // Analytics
  let anaWorker = null, anaCacheKey = null;
  let anaBootChart = null, mcFanChart = null, mcFinalHistChart = null, mcDDHistChart = null;
  let anaLastDDs = null, anaRuinThresh = 10; // for ruin probability quick calc

  // ====== Utilities ======
  const $ = (s)=>document.querySelector(s);
  const $$ = (s)=>document.querySelectorAll(s);
  const fmt = (n,d=2)=>Number(n).toFixed(d);
  const clamp = (x,a,b)=>Math.max(a, Math.min(b, x));
  const mean = (arr)=> (Array.isArray(arr) && arr.length) ? arr.reduce((a,b)=>a+b,0)/arr.length : 0;
  const stdDev = (arr)=>{
    if(!Array.isArray(arr) || arr.length===0) return 0;
    const m = mean(arr);
    const variance = arr.reduce((acc,v)=> acc + Math.pow(v-m,2),0)/arr.length;
    return Math.sqrt(variance);
  };
  const median = (arr)=>{
    if(!Array.isArray(arr) || arr.length===0) return 0;
    const sorted = arr.slice().sort((a,b)=>a-b);
    const mid = Math.floor(sorted.length/2);
    if(sorted.length%2===0) return (sorted[mid-1]+sorted[mid])/2;
    return sorted[mid];
  };
  const groupWinLoss = (events)=>{
    let wins=0, losses=0;
    (events||[]).forEach(ev=>{
      const outcome = effectiveOutcome(ev);
      if(outcome==='W') wins++;
      else if(outcome==='L') losses++;
    });
    return {wins, losses, total: wins+losses};
  };
  function createDefaultCompareFilter(){
    return { start:null, end:null, setups:[], outcomes:[], includeTags:[], excludeTags:[] };
  }
  function parseListInput(str, normalizer){
    if(!str || typeof str !== 'string') return [];
    const items = str.split(',').map(s=> s.trim()).filter(Boolean);
    if(typeof normalizer === 'function') return items.map(normalizer).filter(Boolean);
    return items.filter(Boolean);
  }
  function normalizeSetupName(name){
    if(!name) return '';
    return name.trim().toLowerCase();
  }
  function eventMatchesCompareFilters(ev, setupsFilter, outcomesFilter, includeTagsFilter, excludeTagsFilter){
    const setupName = normalizeSetupName(ev?.setup || '');
    if(setupsFilter.length && !setupsFilter.includes(setupName)) return false;
    const outcomeEff = ev ? effectiveOutcome(ev) : '';
    const outcome = (outcomeEff || ev?.outcome || '').toString().trim().toUpperCase();
    if(outcomesFilter.length && !outcomesFilter.includes(outcome)) return false;
    const tags = Array.isArray(ev?.tags) ? ev.tags.map(normalizeTag).filter(Boolean) : [];
    if(includeTagsFilter.length && !includeTagsFilter.every(tag=> tags.includes(tag))) return false;
    if(excludeTagsFilter.length && excludeTagsFilter.some(tag=> tags.includes(tag))) return false;
    return true;
  }
  function compareFilterActive(){
    if(!compareFilter) return false;
    const f = compareFilter;
    if(f.start || f.end) return true;
    if(Array.isArray(f.setups) && f.setups.length) return true;
    if(Array.isArray(f.outcomes) && f.outcomes.length) return true;
    if(Array.isArray(f.includeTags) && f.includeTags.length) return true;
    if(Array.isArray(f.excludeTags) && f.excludeTags.length) return true;
    return false;
  }

  // ===== Scaling System =====
  function scalingTimestampForDate(date){
    if(!date) return Date.now();
    const stamp = new Date(`${date}T00:00:00`).getTime();
    return Number.isFinite(stamp) ? stamp : Date.now();
  }

  function getScenarioTradeCountForDate(date, scenario='S1'){
    if(!date) return 0;
    const day = dailyData?.[date];
    if(!day) return 0;
    const events = eventsForScenario(day, scenario);
    return Array.isArray(events) ? events.length : 0;
  }

  function renderScalingChecklistForDate(date){
    const wrap = document.getElementById('scalingChecklist');
    if(!wrap) return [];
    wrap.innerHTML = '';
    const sections = getChecklistSectionsForDate(date, {clone:true});
    sections.forEach(section=>{
      const block = document.createElement('div');
      block.className = 'scaling-checklist-section';
      block.setAttribute('data-section-key', section.key);
      const title = document.createElement('h4');
      title.textContent = section.title;
      block.appendChild(title);
      const list = document.createElement('div');
      list.className = 'scaling-checklist-list';
      section.items.forEach(item=>{
        const row = document.createElement('label');
        row.className = 'scaling-check-item';
        row.setAttribute('data-item-id', item.id);
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = `scalingCheck-${section.key}-${item.id}`;
        input.setAttribute('data-check-key', item.id);
        const text = document.createElement('span');
        text.textContent = item.label;
        row.appendChild(input);
        row.appendChild(text);
        list.appendChild(row);
      });
      block.appendChild(list);
      wrap.appendChild(block);
    });
    return sections;
  }

  function collectScalingChecklist(){
    const wrap = document.getElementById('scalingChecklist');
    const checks = {};
    if(!wrap) return checks;
    wrap.querySelectorAll('input[type="checkbox"]').forEach(cb=>{
      const key = cb.getAttribute('data-check-key');
      if(key) checks[key] = cb.checked;
    });
    return checks;
  }

  function updateScalingChecklistSummary(source, sections){
    let completed = null;
    let misses = null;
    let total = Number.isFinite(source?.total) ? source.total : null;
    const expectedTotal = sections ? totalChecklistRulesForSections(sections) : null;
    let usedSource = false;
    if(source && Number.isFinite(source.completed) && Number.isFinite(source.misses)){
      if(expectedTotal != null && Number.isFinite(source.total) && source.total !== expectedTotal){
        // Template changed since this log was recorded; recompute from current checklist
      } else {
        completed = source.completed;
        misses = source.misses;
        total = Number.isFinite(source.total) ? source.total : expectedTotal;
        usedSource = true;
      }
    }
    if(!usedSource){
      const checks = collectScalingChecklist();
      completed = Object.values(checks).filter(Boolean).length;
      if(total == null){
        const wrap = document.getElementById('scalingChecklist');
        const domCount = wrap ? wrap.querySelectorAll('input[type="checkbox"]').length : null;
        const activeDate = document.getElementById('scalingDateInput')?.value || currentDate;
        total = domCount != null ? domCount : totalChecklistRulesForSections(sections || getChecklistSectionsForDate(activeDate));
      }
      misses = total - completed;
    }
    if(total == null) total = completed + (misses ?? 0);
    if(!Number.isFinite(completed)) completed = 0;
    if(!Number.isFinite(misses)) misses = 0;
    if(misses < 0) misses = 0;
    const completeEl = document.getElementById('scalingCompleteCount');
    if(completeEl) completeEl.textContent = completed;
    const missEl = document.getElementById('scalingMissCount');
    if(missEl) missEl.textContent = misses;
    return { completed, misses };
  }

  function updateScalingTradesForDate(date){
    const trades = getScenarioTradeCountForDate(date || '');
    const tradesEl = document.getElementById('scalingTradesForDay');
    if(tradesEl) tradesEl.textContent = trades;
    return trades;
  }

  function loadScalingChecklistForDate(date){
    const wrap = document.getElementById('scalingChecklist');
    if(!wrap) return;
    const dateInput = document.getElementById('scalingDateInput');
    if(dateInput && date) dateInput.value = date;
    const sections = renderScalingChecklistForDate(date);
    const log = (scalingState.logs && date) ? scalingState.logs[date] : null;
    const checks = log && log.checks ? log.checks : {};
    wrap.querySelectorAll('input[type="checkbox"]').forEach(cb=>{
      const key = cb.getAttribute('data-check-key');
      cb.checked = !!checks[key];
    });
    updateScalingChecklistSummary(log, sections);
    updateScalingTradesForDate(date);
    const feedback = document.getElementById('scalingLogFeedback');
    if(feedback){
      if(log){
        const total = Number.isFinite(log.total) ? log.total : totalChecklistRulesForSections(sections);
        const completedVal = Number.isFinite(log.completed) ? log.completed : Object.values(checks).filter(Boolean).length;
        const missesVal = Number.isFinite(log.misses) ? log.misses : (total - completedVal);
        const tradesVal = Number.isFinite(log.trades) ? log.trades : 0;
        feedback.innerHTML = `<strong>${dispDate(log.date)}</strong> - ${completedVal}/${total} rules, ${missesVal} misses, ${tradesVal} trades.`;
      } else {
        feedback.textContent = '';
      }
    }
  }

  function getScalingTimelineItems(){
    const items = [];
    if(scalingState && scalingState.logs){
      Object.keys(scalingState.logs).sort().forEach(date=>{
        if(!date) return;
        const entry = scalingState.logs[date];
        if(!entry) return;
        const stamp = Number.isFinite(entry.timestamp) ? entry.timestamp : scalingTimestampForDate(date);
        entry.timestamp = stamp;
        items.push({ type:'log', timestamp: stamp, data: entry });
      });
    }
    if(Array.isArray(scalingState?.advanceEvents)){
      scalingState.advanceEvents.forEach(evt=>{
        if(!evt) return;
        const stamp = Number.isFinite(evt.timestamp) ? evt.timestamp : Date.now();
        evt.timestamp = stamp;
        items.push({ type:'advance', timestamp: stamp, data: evt });
      });
    }
    items.sort((a,b)=>{
      if(a.timestamp === b.timestamp){
        if(a.type === b.type) return 0;
        return a.type === 'log' ? -1 : 1;
      }
      return a.timestamp - b.timestamp;
    });
    return items;
  }

  function recomputeScalingState(){
    const levels = SCALING_LEVELS.length;
    const levelTrades = Array(levels).fill(0);
    let levelIndex = 0;
    let readyToAdvance = false;
    let lastLogDate = null;
    const history = [];
    const failures = [];
    const timeline = getScalingTimelineItems();
    timeline.forEach(item=>{
      if(item.type === 'log'){
        const log = item.data;
        lastLogDate = log.date || lastLogDate;
        const storedLevel = Number.isFinite(log.level) ? clamp(log.level, 0, levels-1) : null;
        const startLevel = storedLevel!=null ? storedLevel : levelIndex;
        levelIndex = startLevel;
        let outcome = 'pass';
        let action = 'progress';
        const tradesLogged = Number.isFinite(log.trades) ? log.trades : 0;
        const completedRules = Number.isFinite(log.completed) ? log.completed : 0;
        const totalRules = Number.isFinite(log.total) ? log.total : totalChecklistRulesForDate(log.date || null);
        const checks = log.checks || {};
        const sectionsForLog = getChecklistSectionsForDate(log.date || null);
        const idsForLog = flattenChecklistIds(sectionsForLog);
        const misses = Number.isFinite(log.misses) ? log.misses : Math.max(0, totalRules - completedRules);
        if(misses >= 2){
          outcome = 'fail';
          if(startLevel > 0){
            const newLevel = startLevel - 1;
            for(let i=newLevel; i<levels; i++) levelTrades[i] = 0;
            levelIndex = newLevel;
            action = 'downgrade';
          } else {
            for(let i=0; i<levels; i++) levelTrades[i] = 0;
            levelIndex = 0;
            action = 'reset';
          }
          readyToAdvance = false;
          const missedKeys = idsForLog.filter(key=> !checks[key]);
          failures.push({
            date: log.date,
            timestamp: item.timestamp,
            levelBefore: startLevel,
            levelAfter: levelIndex,
            misses,
            missedKeys,
            trades: tradesLogged,
            action
          });
        } else {
          levelTrades[startLevel] += tradesLogged;
          if(levelTrades[startLevel] < 0) levelTrades[startLevel] = 0;
          readyToAdvance = levelTrades[startLevel] >= SCALING_TRADES_REQUIRED;
          action = readyToAdvance ? 'ready' : 'progress';
        }
        history.push({
          type:'log',
          date: log.date,
          timestamp: item.timestamp,
          levelBefore: startLevel,
          levelAfter: levelIndex,
          tradesLogged,
          tradesAtLevel: levelTrades[levelIndex],
          misses,
          completedRules,
          totalRules,
          outcome,
          action,
          missedKeys: idsForLog.filter(key=> !checks[key])
        });
      } else if(item.type === 'advance'){
        if(levelIndex < levels - 1){
          const from = levelIndex;
          const to = Math.min(Number.isFinite(item.data?.to) ? item.data.to : from + 1, levels - 1);
          if(levelTrades[from] < SCALING_TRADES_REQUIRED) levelTrades[from] = SCALING_TRADES_REQUIRED;
          for(let i=from+1; i<levels; i++) levelTrades[i] = 0;
          levelIndex = to;
          levelTrades[levelIndex] = 0;
          readyToAdvance = false;
          history.push({
            type:'advance',
            date: item.data?.date || lastLogDate,
            timestamp: item.timestamp,
            from,
            to
          });
        }
      }
    });
    if(levelIndex >= SCALING_LEVELS.length - 1) readyToAdvance = false;
    scalingComputed = { currentLevelIndex: levelIndex, levelTrades, readyToAdvance, history, failures, lastLogDate };
  }

  function serializeScalingState(){
    const logs = {};
    if(scalingState && scalingState.logs){
      Object.keys(scalingState.logs).forEach(date=>{
        const entry = scalingState.logs[date];
        if(!entry) return;
        const totalRules = Number.isFinite(entry.total)
          ? entry.total
          : totalChecklistRulesForDate(date);
        logs[date] = {
          date,
          checks: entry.checks ? {...entry.checks} : {},
          completed: Number.isFinite(entry.completed) ? entry.completed : 0,
          misses: Number.isFinite(entry.misses) ? entry.misses : 0,
          trades: Number.isFinite(entry.trades) ? entry.trades : 0,
          total: totalRules,
          level: Number.isFinite(entry.level) ? clamp(entry.level, 0, SCALING_LEVELS.length-1) : 0,
          timestamp: Number.isFinite(entry.timestamp) ? entry.timestamp : scalingTimestampForDate(date)
        };
      });
    }
    const advanceEvents = Array.isArray(scalingState?.advanceEvents)
      ? scalingState.advanceEvents.map(evt=>({
          timestamp: Number.isFinite(evt?.timestamp) ? evt.timestamp : Date.now(),
          date: typeof evt?.date === 'string' && evt.date ? evt.date : null,
          from: Number.isFinite(evt?.from) ? evt.from : null,
          to: Number.isFinite(evt?.to) ? evt.to : null
        }))
      : [];
    const checklists = scalingChecklistRevisions.map(rev=>({
      effectiveDate: rev.effectiveDate || null,
      sections: cloneChecklistSections(rev.sections)
    }));
    return {
      anchorDate: scalingState?.anchorDate || null,
      logs,
      advanceEvents,
      checklists
    };
  }

  function deserializeScalingState(raw){
    const state = { anchorDate: null, logs:{}, advanceEvents:[] };
    if(!raw || typeof raw !== 'object') return state;
    if(typeof raw.anchorDate === 'string' && raw.anchorDate) state.anchorDate = raw.anchorDate;
    if(raw.logs && typeof raw.logs === 'object'){
      Object.keys(raw.logs).forEach(date=>{
        const entry = raw.logs[date];
        const entryObj = entry && typeof entry === 'object' ? entry : {};
        const checks = entryObj.checks && typeof entryObj.checks === 'object' ? {...entryObj.checks} : {};
        const completed = Number.isFinite(entryObj.completed) ? entryObj.completed : Object.values(checks).filter(Boolean).length;
        const total = Number.isFinite(entryObj.total) ? entryObj.total : totalChecklistRulesForDate(date);
        const misses = Number.isFinite(entryObj.misses) ? entryObj.misses : (total - completed);
        const trades = Number.isFinite(entryObj.trades) ? entryObj.trades : 0;
        const timestamp = Number.isFinite(entryObj.timestamp) ? entryObj.timestamp : scalingTimestampForDate(date);
        const level = Number.isFinite(entryObj.level) ? clamp(entryObj.level, 0, SCALING_LEVELS.length-1) : 0;
        state.logs[date] = { date, checks, completed, misses, trades, total, timestamp, level };
      });
    }
    if(Array.isArray(raw.advanceEvents)){
      state.advanceEvents = raw.advanceEvents.map(evt=>({
        timestamp: Number.isFinite(evt?.timestamp) ? evt.timestamp : Date.now(),
        date: typeof evt?.date === 'string' && evt.date ? evt.date : null,
        from: Number.isFinite(evt?.from) ? evt.from : null,
        to: Number.isFinite(evt?.to) ? evt.to : null
      }));
    }
    if(Array.isArray(raw.checklists)){
      scalingChecklistRevisions = raw.checklists.map(rev=>({
        effectiveDate: typeof rev?.effectiveDate === 'string' && rev.effectiveDate ? rev.effectiveDate : null,
        sections: cloneChecklistSections(Array.isArray(rev?.sections) ? rev.sections : DEFAULT_SCALING_SECTIONS)
      }));
      ensureLatestExecutionChecklist();
      scalingChecklistRevisions.forEach(rev=> ensureChecklistIds(rev.sections));
      sortChecklistRevisions();
    } else {
      scalingChecklistRevisions = [{ effectiveDate:null, sections: cloneChecklistSections(DEFAULT_SCALING_SECTIONS) }];
    }
    return state;
  }

  function applyLoadedScalingState(raw){
    scalingState = deserializeScalingState(raw);
    recomputeScalingState();
    updateScalingUI();
    const targetDate = document.getElementById('scalingDateInput')?.value || currentDate;
    loadScalingChecklistForDate(targetDate);
    refreshScalingTradeCountIfNeeded();
  }

  function updateScalingAnchorUI(){
    const anchorInput = document.getElementById('scalingAnchorInput');
    if(anchorInput && anchorInput.value !== (scalingState.anchorDate || '')){
      anchorInput.value = scalingState.anchorDate || '';
    }
  }

  function renderScalingLevelList(){
    const currentContainer = document.getElementById('sizingCurrentCard');
    if(currentContainer) currentContainer.innerHTML = '';

    const totalLevels = SCALING_LEVELS.length;
    const currentIdx = clamp(scalingComputed.currentLevelIndex || 0, 0, totalLevels - 1);
    const currentLevel = SCALING_LEVELS[currentIdx] || SCALING_LEVELS[0];
    const nextLevel = currentIdx < totalLevels - 1 ? SCALING_LEVELS[currentIdx + 1] : null;
    const tradesAtLevel = Number(scalingComputed.levelTrades?.[currentIdx]) || 0;
    const remainingTrades = Math.max(0, SCALING_TRADES_REQUIRED - Math.min(tradesAtLevel, SCALING_TRADES_REQUIRED));
    const isFinalTier = currentIdx === totalLevels - 1;

    if(currentContainer){
      const node = document.createElement('div');
      node.className = 'scaling-level active';
      node.classList.add(`tier-L${currentIdx}`);
      if(scalingComputed.readyToAdvance && !isFinalTier) node.classList.add('ready');
      node.setAttribute('aria-current','true');

      const head = document.createElement('div');
      head.className = 'level-head';

      const chip = document.createElement('span');
      chip.className = 'level-chip';
      chip.textContent = currentLevel.id;

      const nameWrap = document.createElement('div');
      nameWrap.className = 'level-name';
      const nameTitle = document.createElement('strong');
      nameTitle.textContent = currentLevel.label;
      const nameSub = document.createElement('span');
      nameSub.textContent = `${fmt(currentLevel.risk,2)}% risk per trade`;
      nameWrap.appendChild(nameTitle);
      nameWrap.appendChild(nameSub);

      const status = document.createElement('span');
      status.className = 'level-status';
      status.textContent = isFinalTier ? 'Full Size' : (scalingComputed.readyToAdvance ? 'Ready' : 'Active');

      head.appendChild(chip);
      head.appendChild(nameWrap);
      head.appendChild(status);

      const meta = document.createElement('div');
      meta.className = 'level-meta';
      const spanCurrent = document.createElement('span');
      spanCurrent.textContent = 'Current';
      const spanTrades = document.createElement('span');
      spanTrades.textContent = isFinalTier ? `${tradesAtLevel} trades` : `${Math.min(tradesAtLevel, SCALING_TRADES_REQUIRED)}/${SCALING_TRADES_REQUIRED} trades`;
      meta.appendChild(spanCurrent);
      meta.appendChild(spanTrades);
      if(isFinalTier){
        const maxSpan = document.createElement('span');
        maxSpan.textContent = 'Max tier';
        meta.appendChild(maxSpan);
      } else {
        const remainSpan = document.createElement('span');
        remainSpan.textContent = remainingTrades > 0 ? `${remainingTrades} remaining` : 'Ready to level';
        meta.appendChild(remainSpan);
      }

      const xpTrack = document.createElement('div');
      xpTrack.className = 'xp-track';
      const xpFill = document.createElement('div');
      xpFill.className = 'xp-fill';
      xpFill.style.width = isFinalTier ? '100%' : `${clamp(tradesAtLevel / SCALING_TRADES_REQUIRED, 0, 1) * 100}%`;
      xpTrack.appendChild(xpFill);

      node.appendChild(head);
      node.appendChild(meta);
      node.appendChild(xpTrack);
      currentContainer.appendChild(node);
    }

    const infoTiers = document.querySelectorAll('#sizingInfoList .sizing-info-tier');
    infoTiers.forEach((row, idx)=>{
      if(idx === currentIdx){ row.classList.add('active'); }
      else { row.classList.remove('active'); }
    });

    const statusEl = document.getElementById('scalingStatusMessage');
    if(statusEl){
      statusEl.classList.remove('ready','fail','reset');
      let statusText = 'Log your first day to begin.';
      if(scalingComputed.history.length){
        const lastLog = [...scalingComputed.history].reverse().find(row=> row.type === 'log');
        if(lastLog && lastLog.outcome === 'fail'){
          const targetLevelId = SCALING_LEVELS[lastLog.levelAfter]?.id || 'L0';
          const missWord = lastLog.misses === 1 ? 'miss' : 'misses';
          if(lastLog.action === 'reset'){
            statusEl.classList.add('reset');
            statusText = `${lastLog.misses} ${missWord} - Reset to L0.`;
          } else {
            statusEl.classList.add('fail');
            statusText = `${lastLog.misses} ${missWord} - Downgraded to ${targetLevelId}.`;
          }
        } else if(scalingComputed.readyToAdvance && !isFinalTier){
          const nextId = SCALING_LEVELS[currentIdx + 1].id;
          statusEl.classList.add('ready');
          statusText = `Ready to advance to ${nextId}. Click Advance Level to confirm.`;
        } else {
          statusText = isFinalTier
            ? `Maintain discipline at ${currentLevel.id}.`
            : (remainingTrades > 0
                ? `${remainingTrades} trades remaining at ${currentLevel.id}. Stay within 1 miss per day.`
                : `Maintain discipline at ${currentLevel.id}.`);
        }
      }
      statusEl.textContent = statusText;
    }

    const advanceBtn = document.getElementById('scalingAdvanceBtn');
    if(advanceBtn){
      if(isFinalTier){
        advanceBtn.disabled = true;
        advanceBtn.classList.remove('ready-glow');
        advanceBtn.textContent = 'At Full Size';
      } else if(scalingComputed.readyToAdvance){
        advanceBtn.disabled = false;
        advanceBtn.classList.add('ready-glow');
        advanceBtn.textContent = `Advance to ${SCALING_LEVELS[currentIdx + 1].id}`;
      } else {
        advanceBtn.disabled = true;
        advanceBtn.classList.remove('ready-glow');
        advanceBtn.textContent = 'Advance Level';
      }
    }
  }

  function renderScalingFailLog(){
    const table = document.getElementById('scalingFailTable');
    if(!table) return;
    const body = table.querySelector('tbody');
    if(!body) return;
    body.innerHTML = '';
    const failures = (scalingComputed.failures || []).slice().sort((a,b)=> b.timestamp - a.timestamp);
    if(!failures.length){
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 6;
      td.className = 'muted';
      td.textContent = 'No failed days logged';
      tr.appendChild(td);
      body.appendChild(tr);
      return;
    }
    failures.forEach(fail=>{
      const tr = document.createElement('tr');
      const levelId = SCALING_LEVELS[fail.levelBefore]?.id || 'L0';
      const targetId = SCALING_LEVELS[fail.levelAfter]?.id || 'L0';
      const actionText = fail.action === 'reset' ? 'Reset to L0' : `Downgraded to ${targetId}`;
      const missedLabels = (fail.missedKeys || []).map(key=> labelForChecklistId(key, fail.date));
      const missedHTML = missedLabels.length
        ? `<div class="fail-tags">${missedLabels.map(label=> `<span class="fail-tag">${label}</span>`).join('')}</div>`
        : '<span class="muted">No details</span>';
      tr.innerHTML = `
        <td>${dispDate(fail.date)}</td>
        <td>${levelId}</td>
        <td>${fail.trades ?? 0}</td>
        <td>${fail.misses ?? 0}</td>
        <td>${missedHTML}</td>
        <td>${actionText}</td>`;
      body.appendChild(tr);
    });
  }

  function updateScalingUI(){
    updateScalingAnchorUI();
    renderScalingLevelList();
    renderScalingFailLog();
    renderMasteryCurve();
  }

  function renderSizingInfoList(){
    const list = document.getElementById('sizingInfoList');
    if(!list) return;
    list.innerHTML = '';
    const activeIdx = clamp(scalingComputed.currentLevelIndex || 0, 0, SCALING_LEVELS.length-1);
    SCALING_LEVELS.forEach((level, idx)=>{
      const row = document.createElement('div');
      row.className = 'sizing-info-tier';
      row.classList.add(`tier-L${idx}`);
      if(idx === activeIdx){
        row.classList.add('active');
        row.setAttribute('aria-current','true');
      }

      const swatch = document.createElement('div');
      swatch.className = 'color-swatch';

      const details = document.createElement('div');
      details.className = 'tier-details';
      const title = document.createElement('strong');
      title.textContent = `${level.id} · ${level.label}`;
      const sub = document.createElement('span');
      sub.textContent = `${fmt(level.risk,2)}% risk per trade`;
      details.appendChild(title);
      details.appendChild(sub);

      row.appendChild(swatch);
      row.appendChild(details);
      list.appendChild(row);
    });
  }

  function openSizingInfo(){
    renderSizingInfoList();
    document.getElementById('sizingInfoBackdrop')?.classList.add('show');
    document.getElementById('sizingInfoModal')?.classList.add('show');
  }

  function closeSizingInfo(){
    document.getElementById('sizingInfoBackdrop')?.classList.remove('show');
    document.getElementById('sizingInfoModal')?.classList.remove('show');
  }

  function renderChecklistEditor(){
    const container = document.getElementById('checklistEditorSections');
    if(!container) return;
    container.innerHTML = '';
    if(!Array.isArray(checklistDraft)) return;
    checklistDraft.forEach(section=>{
      const sec = document.createElement('div');
      sec.className = 'checklist-editor-section';
      sec.setAttribute('data-section-key', section.key);
      const header = document.createElement('header');
      const title = document.createElement('strong');
      title.textContent = section.title;
      const addBtn = document.createElement('button');
      addBtn.className = 'btn soft small';
      addBtn.textContent = 'Add Item';
      addBtn.setAttribute('data-checklist-add', section.key);
      header.appendChild(title);
      header.appendChild(addBtn);
      sec.appendChild(header);

      const list = document.createElement('div');
      list.className = 'checklist-editor-items';
      section.items.forEach(item=>{
        const row = document.createElement('div');
        row.className = 'checklist-editor-row';
        row.setAttribute('data-item-id', item.id);
        const input = document.createElement('input');
        input.type = 'text';
        input.value = item.label;
        input.setAttribute('data-checklist-input', item.id);
        input.setAttribute('data-section-key', section.key);
        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn soft small';
        removeBtn.textContent = 'Remove';
        removeBtn.setAttribute('data-checklist-remove', item.id);
        removeBtn.setAttribute('data-section-key', section.key);
        row.appendChild(input);
        row.appendChild(removeBtn);
        list.appendChild(row);
      });
      sec.appendChild(list);
      container.appendChild(sec);
    });
  }

  function openChecklistEditor(){
    checklistDraftDate = document.getElementById('scalingDateInput')?.value || currentDate;
    checklistDraft = getChecklistSectionsForDate(checklistDraftDate, {clone:true});
    ensureChecklistIds(checklistDraft);
    const label = document.getElementById('checklistEffectiveLabel');
    if(label) label.textContent = dispDate(checklistDraftDate);
    renderChecklistEditor();
    document.getElementById('checklistModalBackdrop')?.classList.add('show');
    document.getElementById('checklistModal')?.classList.add('show');
  }

  function closeChecklistEditor(){
    document.getElementById('checklistModalBackdrop')?.classList.remove('show');
    document.getElementById('checklistModal')?.classList.remove('show');
    checklistDraft = null;
    checklistDraftDate = null;
  }

  function checklistEditorHandleKeydown(e){
    if(e.key !== 'Escape') return;
    let handled = false;
    if(document.getElementById('checklistModal')?.classList.contains('show')){
      closeChecklistEditor();
      handled = true;
    }
    if(document.getElementById('sizingInfoModal')?.classList.contains('show')){
      closeSizingInfo();
      handled = true;
    }
    if(handled) e.preventDefault();
  }

  function applyChecklistRevision(){
    if(!checklistDraft || !checklistDraftDate){ closeChecklistEditor(); return; }
    const sanitized = cloneChecklistSections(checklistDraft).map(section=>({
      key: section.key,
      title: section.title,
      items: section.items
        .map(item=> ({ id: item.id || generateChecklistId(), label: String(item.label || '').trim() }))
        .filter(item=> item.label)
    }));
    ensureChecklistIds(sanitized);
    const effectiveDate = checklistDraftDate;
    scalingChecklistRevisions = scalingChecklistRevisions.filter(rev=> rev.effectiveDate !== effectiveDate);
    scalingChecklistRevisions.push({ effectiveDate, sections: sanitized });
    sortChecklistRevisions();
    recomputeScalingState();
    updateScalingUI();
    loadScalingChecklistForDate(effectiveDate);
    saveLocal();
    if(typeof showToast === 'function') showToast('Checklist template updated');
    closeChecklistEditor();
  }

  function checklistEditorHandleInput(e){
    const target = e.target;
    if(!checklistDraft) return;
    if(target.matches('[data-checklist-input]')){
      const id = target.getAttribute('data-checklist-input');
      const sectionKey = target.getAttribute('data-section-key');
      const section = checklistDraft.find(sec=> sec.key===sectionKey);
      if(!section) return;
      const item = section.items.find(it=> it.id===id);
      if(item) item.label = target.value;
    }
  }

  function checklistEditorHandleClick(e){
    const target = e.target;
    if(!checklistDraft) return;
    if(target.matches('[data-checklist-add]')){
      const key = target.getAttribute('data-checklist-add');
      const section = checklistDraft.find(sec=> sec.key===key);
      if(section){
        section.items.push({ id: generateChecklistId(), label:'New checklist item' });
        renderChecklistEditor();
        requestAnimationFrame(()=>{
          const input = document.querySelector(`.checklist-editor-section[data-section-key="${key}"] .checklist-editor-row:last-child input`);
          if(input){ input.focus(); input.select(); }
        });
      }
      e.preventDefault();
      return;
    }
    if(target.matches('[data-checklist-remove]')){
      const key = target.getAttribute('data-section-key');
      const id = target.getAttribute('data-checklist-remove');
      const section = checklistDraft.find(sec=> sec.key===key);
      if(section){
        section.items = section.items.filter(it=> it.id!==id);
        renderChecklistEditor();
      }
      e.preventDefault();
      return;
    }
  }

  function refreshScalingTradeCountIfNeeded(){
    const dateInput = document.getElementById('scalingDateInput');
    if(dateInput && dateInput.value){
      updateScalingTradesForDate(dateInput.value);
    }
  }

  function handleScalingAnchorChange(){
    const anchorInput = document.getElementById('scalingAnchorInput');
    if(!anchorInput) return;
    scalingState.anchorDate = anchorInput.value || null;
    updateScalingAnchorUI();
    saveLocal();
  }

  function handleScalingSaveLog(){
    const dateInput = document.getElementById('scalingDateInput');
    const targetDate = dateInput && dateInput.value ? dateInput.value : currentDate;
    if(!targetDate){ alert('Select a date to save.'); return; }
    const checks = collectScalingChecklist();
    const sections = getChecklistSectionsForDate(targetDate);
    const totalRules = totalChecklistRulesForSections(sections);
    const completed = Object.values(checks).filter(Boolean).length;
    const misses = totalRules - completed;
    const trades = getScenarioTradeCountForDate(targetDate);
    scalingState.logs = scalingState.logs || {};
    const prevLog = scalingState.logs[targetDate];
    const baseStamp = scalingTimestampForDate(targetDate);
    const timestamp = prevLog && Number.isFinite(prevLog.timestamp)
      ? prevLog.timestamp
      : Math.max(Date.now(), baseStamp);
    const levelAtSave = prevLog && Number.isFinite(prevLog.level)
      ? clamp(prevLog.level, 0, SCALING_LEVELS.length-1)
      : clamp(scalingComputed.currentLevelIndex || 0, 0, SCALING_LEVELS.length-1);
    scalingState.logs[targetDate] = {
      date: targetDate,
      checks,
      completed,
      misses,
      trades,
      total: totalRules,
      level: levelAtSave,
      timestamp
    };
    recomputeScalingState();
    updateScalingUI();
    loadScalingChecklistForDate(targetDate);
    if(typeof showToast === 'function') showToast(`Scaling log saved for ${dispDate(targetDate)}`);
    saveLocal();
  }

  function handleScalingReset(){
    if(!confirm('Reset scaling progression to L0?')) return;
    scalingState.logs = {};
    scalingState.advanceEvents = [];
    recomputeScalingState();
    updateScalingUI();
    const dateInput = document.getElementById('scalingDateInput');
    const targetDate = dateInput && dateInput.value ? dateInput.value : currentDate;
    loadScalingChecklistForDate(targetDate);
    if(typeof showToast === 'function') showToast('Scaling reset to L0');
    saveLocal();
  }

  function getScalingEventDate(){
    const dateInput = document.getElementById('scalingDateInput');
    if(dateInput && dateInput.value) return dateInput.value;
    if(scalingComputed.lastLogDate) return scalingComputed.lastLogDate;
    return currentDate;
  }

  function handleScalingAdvance(){
    if(!scalingComputed.readyToAdvance) return;
    if(scalingComputed.currentLevelIndex >= SCALING_LEVELS.length - 1) return;
    const advanceBtnEl = document.getElementById('scalingAdvanceBtn');
    if(advanceBtnEl) advanceBtnEl.disabled = true;
    const from = scalingComputed.currentLevelIndex;
    const to = Math.min(from + 1, SCALING_LEVELS.length - 1);
    const eventDate = getScalingEventDate();
    const baseTs = scalingTimestampForDate(eventDate || currentDate);
    const eventTimestamp = Math.max(Date.now(), baseTs + 12 * 60 * 60 * 1000);
    const evt = {
      timestamp: eventTimestamp,
      date: eventDate,
      from,
      to
    };
    if(!Array.isArray(scalingState.advanceEvents)) scalingState.advanceEvents = [];
    scalingState.advanceEvents.push(evt);
    recomputeScalingState();
    updateScalingUI();
    if(typeof showToast === 'function') showToast(`Advanced to ${SCALING_LEVELS[to].id}`);
    saveLocal();
  }

  function openScalingForDate(date){
    const target = date || currentDate;
    loadScalingChecklistForDate(target);
    updateScalingTradesForDate(target);
    switchTab('scaling');
  }

  function setupScalingTab(){
    const anchorInput = document.getElementById('scalingAnchorInput');
    if(anchorInput) anchorInput.addEventListener('change', handleScalingAnchorChange);
    const dateInput = document.getElementById('scalingDateInput');
    if(dateInput){
      dateInput.value = currentDate;
      dateInput.addEventListener('change', ()=>{
        const val = dateInput.value;
        if(val) loadScalingChecklistForDate(val);
      });
    }
    const checkAllBtn = document.getElementById('scalingCheckAllBtn');
    if(checkAllBtn){
      checkAllBtn.addEventListener('click', ()=>{
        const wrap = document.getElementById('scalingChecklist');
        if(!wrap) return;
        wrap.querySelectorAll('input[type="checkbox"]').forEach(cb=>{ cb.checked = true; });
        updateScalingChecklistSummary();
        if(typeof showToast === 'function') showToast('All checklist items checked');
      });
    }
    const editBtn = document.getElementById('scalingEditChecklistBtn');
    if(editBtn){
      editBtn.addEventListener('click', openChecklistEditor);
    }
    const checklist = document.getElementById('scalingChecklist');
    if(checklist) checklist.addEventListener('change', ()=> updateScalingChecklistSummary());
    const saveBtn = document.getElementById('scalingSaveLogBtn');
    if(saveBtn) saveBtn.addEventListener('click', handleScalingSaveLog);
    const resetBtn = document.getElementById('scalingResetBtn');
    if(resetBtn) resetBtn.addEventListener('click', handleScalingReset);
    const advanceBtn = document.getElementById('scalingAdvanceBtn');
    if(advanceBtn) advanceBtn.addEventListener('click', handleScalingAdvance);
    const shortcut = document.getElementById('scalingChecklistShortcut');
    if(shortcut) shortcut.addEventListener('click', ()=> openScalingForDate(currentDate));
    const masterySeg = document.getElementById('masteryGranSeg');
    if(masterySeg){
      masterySeg.querySelectorAll('button').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const gran = btn.getAttribute('data-gran');
          if(!gran || gran === masteryCurveGranularity) return;
          masteryCurveGranularity = gran;
          masterySeg.querySelectorAll('button').forEach(other=>{
            other.classList.toggle('active', other === btn);
          });
          renderMasteryCurve();
        });
      });
    }
    document.getElementById('checklistCancelBtn')?.addEventListener('click', closeChecklistEditor);
    document.getElementById('checklistModalBackdrop')?.addEventListener('click', closeChecklistEditor);
    document.getElementById('checklistSaveBtn')?.addEventListener('click', applyChecklistRevision);
    const editorContainer = document.getElementById('checklistEditorSections');
    if(editorContainer){
      editorContainer.addEventListener('input', checklistEditorHandleInput);
      editorContainer.addEventListener('click', checklistEditorHandleClick);
    }
    document.getElementById('sizingInfoBtn')?.addEventListener('click', openSizingInfo);
    document.getElementById('sizingInfoClose')?.addEventListener('click', closeSizingInfo);
    document.getElementById('sizingInfoBackdrop')?.addEventListener('click', closeSizingInfo);
    document.getElementById('checklistModal')?.addEventListener('click', e=> e.stopPropagation());
    document.getElementById('sizingInfoModal')?.addEventListener('click', e=> e.stopPropagation());
    document.addEventListener('keydown', checklistEditorHandleKeydown);
    renderSizingInfoList();
    recomputeScalingState();
    updateScalingUI();
    loadScalingChecklistForDate(currentDate);
  }
  // Global helpers for image + thin data building (used by directory mode)
  function abToBase64(buf){
    const bytes = new Uint8Array(buf); const chunk = 0x8000; let binary = '';
    for(let i=0;i<bytes.length;i+=chunk){ binary += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk)); }
    return btoa(binary);
  }
  function dataURLToUint8(dataUrl){
    const m = /^data:([^;]+);base64,(.*)$/.exec(dataUrl||'');
    if(!m) return {mime:'application/octet-stream', bin:new Uint8Array()};
    const mime = m[1]; const b64 = m[2];
    const raw = atob(b64);
    const arr = new Uint8Array(raw.length);
    for(let i=0;i<raw.length;i++) arr[i] = raw.charCodeAt(i);
    return {mime, bin: arr};
  }
  function extForMime(mime){
    if(!mime) return 'png';
    if(mime.includes('png')) return 'png';
    if(mime.includes('jpeg') || mime.includes('jpg')) return 'jpg';
    if(mime.includes('webp')) return 'webp';
    return 'png';
  }
  function buildThinDataWithRefs(){
    // No screenshot filename references; infer shots as shots/YYYY-MM-DD.<ext>
    const thin = {};
    for(const d of Object.keys(dailyData).sort()){
      const day = dailyData[d]||{};
      const out = { note: day.note||'', _events: Array.isArray(day._events)? day._events.map(ev=>({...ev})) : [] };
      thin[d]=out;
    }
    return thin;
  }

  function normalizeImportedDailyData(obj){
    if(!obj || typeof obj !== 'object') return {};
    let src = {};
    if(obj.data && typeof obj.data === 'object') src = obj.data;
    else if(obj.dailyData && typeof obj.dailyData === 'object') src = obj.dailyData;
    else if(typeof obj === 'object'){
      const keys = Object.keys(obj);
      const looksLikeDaily = keys.length>0 && keys.every(k=> /^\d{4}-\d{2}-\d{2}$/.test(k));
      if(looksLikeDaily) src = obj;
    }
    const out = {};
    for(const date of Object.keys(src)){ 
      if(!/^\d{4}-\d{2}-\d{2}$/.test(date)) continue;
      const day = src[date] || {};
      let events = Array.isArray(day._events) ? day._events.map(ev=> ({...ev})) : [];
      if(events.length===0){
        for(const [setup, val] of Object.entries(day)){
          if(['note','_events','screenshot','screenshotFile'].includes(setup)) continue;
          const info = val || {};
          const wins = Number(info.wins ?? info.win ?? info.w ?? 0);
          const losses = Number(info.losses ?? info.loss ?? info.l ?? 0);
          const reward = Number(info.r ?? info.reward ?? info.rewardR ?? 2);
          const risk = Number(info.risk ?? info.riskR ?? 1);
          for(let i=0;i<wins;i++){
            events.push({ id:`${date}-${setup}-W-${i+1}`, setup, outcome:'W', rewardR: Number.isFinite(reward)? reward : 2, riskR: Number.isFinite(risk)? Math.abs(risk) : 1, tags:[] });
          }
          for(let i=0;i<losses;i++){
            events.push({ id:`${date}-${setup}-L-${i+1}`, setup, outcome:'L', rewardR: Number.isFinite(reward)? reward : 2, riskR: Number.isFinite(risk)? Math.abs(risk) : 1, tags:[] });
          }
        }
      }
      const normEvents = [];
      events.forEach((ev, idx)=>{
        const copy = {...ev};
        const setup = typeof copy.setup === 'string' && copy.setup.trim() ? copy.setup.trim().slice(0,60) : 'Setup';
        copy.setup = setup;
        let outcome = (copy.outcome ?? copy.result ?? '').toString().toUpperCase();
        if(outcome.startsWith('W')) outcome = 'W';
        else if(outcome.startsWith('L')) outcome = 'L';
        else if(outcome.startsWith('B')) outcome = 'B';
        else outcome = 'B';
        copy.outcome = outcome;
        const reward = Number(copy.rewardR ?? copy.reward ?? copy.r ?? copy.rMultiple ?? 2);
        const risk = Number(copy.riskR ?? copy.risk ?? copy.lossRisk ?? 1);
        copy.rewardR = Number.isFinite(reward) ? reward : 2;
        copy.riskR = Number.isFinite(risk) ? Math.abs(risk) : 1;
        if(copy.outcome==='L' && copy.riskR<=0) copy.riskR = Math.abs(copy.riskR)||1;
        if(copy.outcome==='W' && copy.rewardR<=0) copy.rewardR = Math.abs(copy.rewardR)||2;
        if(!Array.isArray(copy.tags)) copy.tags = [];
        copy.tags = copy.tags.map(normalizeTag).filter(Boolean);
        if(typeof copy.note !== 'string') copy.note = '';
        if(copy.trailR !== undefined){
          const tr = Number(copy.trailR);
          if(!Number.isFinite(tr)) delete copy.trailR;
        }
        if(!copy.id || typeof copy.id !== 'string') copy.id = `${date}-${idx}-${Math.random().toString(36).slice(2,8)}`;
        normEvents.push(copy);
      });
      const clean = {
        note: typeof day.note === 'string' ? day.note : '',
        _events: normEvents
      };
      if(day.screenshot) clean.screenshot = day.screenshot;
      if(day.screenshotFile) clean.screenshotFile = day.screenshotFile;
      out[date] = clean;
      deriveAggregatesForDay(clean);
    }
    return out;
  }

  async function parseCompareJsonFile(file){
    if(!file) throw new Error('No file selected');
    const text = await file.text();
    let parsed;
    try{
      parsed = JSON.parse(text);
    }catch(err){
      throw new Error('Invalid JSON file');
    }
    const data = normalizeImportedDailyData(parsed);
    if(Object.keys(data).length===0) throw new Error('JSON missing recognizable daily data');
    const nameCandidate = typeof parsed.fileName === 'string' ? parsed.fileName.trim() : '';
    const name = nameCandidate || (file.name ? file.name.replace(/\.[^/.]+$/, '') : 'JSON Study');
    return {
      data,
      name,
      meta:{ source:'json', fileName:file.name, savedAt: parsed.savedAt || null }
    };
  }

  async function parseCompareBundleFile(file){
    if(typeof JSZip === 'undefined') throw new Error('Bundle support unavailable (JSZip missing)');
    const zip = await JSZip.loadAsync(file);
    const entry = zip.file('data.json') || zip.file('backtest.json') || zip.file('manifest.json');
    if(!entry) throw new Error('Bundle missing data.json');
    let parsed;
    try{
      parsed = JSON.parse(await entry.async('string'));
    }catch(err){
      throw new Error('Bundle contains invalid JSON');
    }
    const data = normalizeImportedDailyData(parsed);
    const dates = Object.keys(data);
    for(const d of dates){
      const day = data[d];
      if(!day) continue;
      let found = null;
      const candidates = [`shots/${d}.png`, `shots/${d}.jpg`, `shots/${d}.jpeg`, `shots/${d}.webp`];
      for(const path of candidates){
        const f = zip.file(path);
        if(f){ found = {path, file:f}; break; }
      }
      if(!found && day.screenshotFile){
        const fallback = zip.file(day.screenshotFile);
        if(fallback) found = {path: day.screenshotFile, file: fallback};
      }
      if(found){
        try{
          const b64 = await found.file.async('base64');
          const ext = found.path.split('.').pop().toLowerCase();
          const mime = ext==='jpg'||ext==='jpeg' ? 'image/jpeg' : (ext==='webp' ? 'image/webp' : 'image/png');
          day.screenshot = `data:${mime};base64,${b64}`;
        }catch(_){ /* ignore */ }
      }
    }
    const nameCandidate = typeof parsed.fileName === 'string' ? parsed.fileName.trim() : '';
    const name = nameCandidate || (file.name ? file.name.replace(/\.[^/.]+$/, '') : 'Bundle Study');
    return {
      data,
      name,
      meta:{ source:'bundle', fileName:file.name, savedAt: parsed.savedAt || null }
    };
  }

  async function parseCompareDirectoryHandle(dir){
    if(!dir) throw new Error('No folder selected');
    let fileHandle;
    try{
      fileHandle = await dir.getFileHandle('data.json');
    }catch(err){
      throw new Error('Folder missing data.json');
    }
    const file = await fileHandle.getFile();
    let parsed;
    try{
      parsed = JSON.parse(await file.text());
    }catch(err){
      throw new Error('Folder contains invalid data.json');
    }
    const data = normalizeImportedDailyData(parsed);
    let shotsDir = null;
    try{
      shotsDir = await dir.getDirectoryHandle('shots');
    }catch(_){ shotsDir=null; }
    if(shotsDir){
      for(const d of Object.keys(data)){
        const day = data[d];
        if(!day) continue;
        const extensions = ['png','jpg','jpeg','webp'];
        let matched = false;
        for(const ext of extensions){
          try{
            const fh = await shotsDir.getFileHandle(`${d}.${ext}`);
            const blob = await fh.getFile();
            const buf = await blob.arrayBuffer();
            const mime = ext==='jpg'||ext==='jpeg' ? 'image/jpeg' : (ext==='webp' ? 'image/webp' : 'image/png');
            const b64 = abToBase64(buf);
            day.screenshot = `data:${mime};base64,${b64}`;
            matched = true;
            break;
          }catch(_){ /* try next */ }
        }
        if(!matched && day.screenshotFile){
          const name = day.screenshotFile.split('/').pop();
          if(name){
            const ext = name.split('.').pop()?.toLowerCase() || 'png';
            try{
              const fh = await shotsDir.getFileHandle(name);
              const blob = await fh.getFile();
              const buf = await blob.arrayBuffer();
              const mime = ext==='jpg'||ext==='jpeg' ? 'image/jpeg' : (ext==='webp' ? 'image/webp' : 'image/png');
              const b64 = abToBase64(buf);
              day.screenshot = `data:${mime};base64,${b64}`;
            }catch(_){ /* ignore */ }
          }
        }
      }
    }
    const nameCandidate = typeof parsed.fileName === 'string' ? parsed.fileName.trim() : '';
    const name = nameCandidate || dir.name || 'Folder Study';
    return {
      data,
      name,
      meta:{ source:'folder', dirName: dir.name || null, savedAt: parsed.savedAt || null }
    };
  }

  function snapshotCompareFromCurrent(){
    const clone = filteredClone(dailyData || {}, { scenario: currentScenarioKey() });
    for(const d of Object.keys(clone)){
      const day = clone[d];
      if(!day) continue;
      if(!Array.isArray(day._events)) day._events = Array.isArray(day._events) ? day._events : [];
      deriveAggregatesForDay(day);
    }
    const name = currentFileName ? `${currentFileName} (Current)` : 'Current Dataset';
    return {
      data: clone,
      name,
      meta:{ source:'current', savedAt: new Date().toISOString() }
    };
  }

  function resetCompareSlot(slot){
    if(!compareSlotsState[slot]) return;
    compareSlotsState[slot].data = null;
    compareSlotsState[slot].name = '';
    compareSlotsState[slot].meta = null;
    compareSlotsState[slot].stats = null;
  }

  function applyCompareSlot(slot, payload){
    if(!compareSlotsState[slot]) return;
    const target = compareSlotsState[slot];
    target.data = payload?.data || null;
    target.name = payload?.name || target.label;
    target.meta = payload?.meta || null;
    target.stats = payload?.stats || null;
  }

  function computeCompareStats(data, filter = compareFilter){
    if(!data || typeof data !== 'object') return null;
    const dates = Object.keys(data).filter(d=> /^\d{4}-\d{2}-\d{2}$/.test(d)).sort();
    if(dates.length===0) return null;

    const active = filter || createDefaultCompareFilter();
    const start = active?.start ? String(active.start) : null;
    const end = active?.end ? String(active.end) : null;
    const setupsFilter = Array.isArray(active?.setups) ? active.setups.map(normalizeSetupName).filter(Boolean) : [];
    const outcomesFilter = Array.isArray(active?.outcomes) ? active.outcomes.map(v=> v.toString().trim().toUpperCase()).filter(Boolean) : [];
    const includeTagsFilter = Array.isArray(active?.includeTags) ? active.includeTags.map(normalizeTag).filter(Boolean) : [];
    const excludeTagsFilter = Array.isArray(active?.excludeTags) ? active.excludeTags.map(normalizeTag).filter(Boolean) : [];

    let wins=0, losses=0, breakevens=0, trades=0;
    let netR=0;
    let totalPositive=0, totalNegative=0;
    let eq=0, peak=0, maxDD=0;
    let bestDay=-Infinity, worstDay=Infinity, bestDayDate=null, worstDayDate=null;
    let positiveDays=0, negativeDays=0, beDays=0;
    let totalRisk=0, totalReward=0, riskCount=0, rewardCount=0;
    let streakWin=0, streakLoss=0, bestWinStreak=0, worstLossStreak=0;
    const tradeRs=[];
    const equitySeries=[];
    const dailyNet = {};
    const setupMap = new Map();
    const filteredDates = [];

    dates.forEach(date=>{
      if(start && date < start) return;
      if(end && date > end) return;
      const day = data[date] || {};
      const events = Array.isArray(day._events) ? day._events : [];
      const kept = [];
      events.forEach(ev=>{
        if(eventMatchesCompareFilters(ev, setupsFilter, outcomesFilter, includeTagsFilter, excludeTagsFilter)){
          kept.push(ev);
        }
      });
      if(kept.length===0) return;
      filteredDates.push(date);
      let dayR = 0;
      kept.forEach((ev)=>{
        const r = eventR(ev);
        if(!Number.isFinite(r)) return;
        dayR += r;
        tradeRs.push(r);
        netR += r;
        trades++;
        const outcome = effectiveOutcome(ev);
        if(outcome==='W'){
          wins++;
          const rw = Number(ev.rewardR ?? 2);
          if(Number.isFinite(rw)) { totalReward += rw; rewardCount++; }
          totalPositive += r>0 ? r : 0;
          streakWin++;
          streakLoss = 0;
          if(streakWin>bestWinStreak) bestWinStreak = streakWin;
        } else if(outcome==='L'){
          losses++;
          const rl = Number(ev.riskR ?? 1);
          if(Number.isFinite(rl)) { totalRisk += Math.abs(rl); riskCount++; }
          totalNegative += r<0 ? r : 0;
          streakLoss++;
          streakWin = 0;
          if(streakLoss>worstLossStreak) worstLossStreak = streakLoss;
        } else {
          breakevens++;
          streakWin = 0;
          streakLoss = 0;
        }
        const setup = typeof ev.setup === 'string' && ev.setup.trim() ? ev.setup.trim() : 'Unlabeled';
        if(!setupMap.has(setup)) setupMap.set(setup, {wins:0, losses:0, breakevens:0, trades:0, netR:0});
        const agg = setupMap.get(setup);
        agg.trades++;
        agg.netR += r;
        if(outcome==='W') agg.wins++;
        else if(outcome==='L') agg.losses++;
        else agg.breakevens++;
      });
      dailyNet[date] = dayR;
      if(dayR>0) positiveDays++;
      else if(dayR<0) negativeDays++;
      else beDays++;
      if(dayR>bestDay){ bestDay = dayR; bestDayDate = date; }
      if(dayR<worstDay){ worstDay = dayR; worstDayDate = date; }
      eq += dayR;
      equitySeries.push({date, value:eq});
      if(eq>peak) peak = eq;
      const dd = peak - eq;
      if(dd>maxDD) maxDD = dd;
    });

    if(trades===0) return null;

    if(!Number.isFinite(bestDay)) bestDay = 0;
    if(!Number.isFinite(worstDay)) worstDay = 0;
    const expectancy = netR / trades;
    const countedWinsLosses = wins + losses;
    const winRate = countedWinsLosses ? (wins / countedWinsLosses * 100) : 0;
    const lossRate = (losses / trades) * 100;
    const breakevenRate = (breakevens / trades) * 100;
    const avgRPerDay = filteredDates.length ? netR / filteredDates.length : 0;
    const avgRisk = riskCount ? totalRisk / riskCount : 0;
    const avgReward = rewardCount ? totalReward / rewardCount : 0;
    const profitFactor = totalNegative !== 0 ? (totalPositive / Math.abs(totalNegative)) : (totalPositive>0 ? Infinity : 0);
    const tradeStd = stdDev(tradeRs);
    const nonZeroTrades = tradeRs.filter(r=> r!==0);
    const tradeMedian = nonZeroTrades.length ? median(nonZeroTrades) : median(tradeRs);
    const dailyMedian = median(Object.values(dailyNet));
    const positiveDayPct = filteredDates.length ? (positiveDays / filteredDates.length * 100) : 0;
    const winLossRatio = losses>0 ? (wins / losses) : (wins>0 ? Infinity : 0);
    const avgWinR = wins ? totalPositive / wins : 0;
    const avgLossR = losses ? Math.abs(totalNegative) / losses : 0;
    const payoffRatio = avgRisk>0 ? (avgReward / avgRisk) : (avgReward>0 ? Infinity : 0);
    const outcome = {wins, losses, breakevens};
    const setupStats = Array.from(setupMap.entries()).map(([name, val])=>{
      const wr = val.trades ? (val.wins/val.trades*100) : 0;
      return {...val, name, winRate: wr};
    }).sort((a,b)=> b.netR - a.netR);

    const equityMap = {};
    equitySeries.forEach(p=>{ equityMap[p.date] = p.value; });

    return {
      trades,
      wins,
      losses,
      breakevens,
      netR,
      expectancy,
      winRate,
      lossRate,
      breakevenRate,
      avgRPerDay,
      avgRisk,
      avgReward,
      profitFactor,
      winLossRatio,
      payoffRatio,
      maxDrawdown: maxDD,
      bestDay,
      bestDayDate,
      worstDay,
      worstDayDate,
      positiveDays,
      negativeDays,
      beDays,
      positiveDayPct,
      tradeStd,
      tradeMedian,
      dailyMedian,
      avgWinR,
      avgLossR,
      bestWinStreak,
      worstLossStreak,
      equitySeries,
      equityMap,
      dailyNet,
      outcome,
      setupStats,
      totalDays: filteredDates.length
    };
  }

  function readCompareFilterFromUI(){
    const start = document.getElementById('compareFilterStart')?.value || null;
    const end = document.getElementById('compareFilterEnd')?.value || null;
    const setups = parseListInput(document.getElementById('compareFilterSetups')?.value || '', s=> s.trim()).filter(Boolean);
    const outcomes = Array.from(document.querySelectorAll('.compareFilterOutcome:checked')).map(el=> el.value.toString().toUpperCase());
    const includeTags = parseListInput(document.getElementById('compareFilterIncludeTags')?.value || '', normalizeTag);
    const excludeTags = parseListInput(document.getElementById('compareFilterExcludeTags')?.value || '', normalizeTag);
    return {
      start: start || null,
      end: end || null,
      setups,
      outcomes,
      includeTags,
      excludeTags
    };
  }

  function syncCompareFilterUI(){
    const startEl = document.getElementById('compareFilterStart'); if(startEl) startEl.value = compareFilter.start || '';
    const endEl = document.getElementById('compareFilterEnd'); if(endEl) endEl.value = compareFilter.end || '';
    const setupsEl = document.getElementById('compareFilterSetups'); if(setupsEl) setupsEl.value = (compareFilter.setups||[]).join(', ');
    const includeEl = document.getElementById('compareFilterIncludeTags'); if(includeEl) includeEl.value = (compareFilter.includeTags||[]).join(', ');
    const excludeEl = document.getElementById('compareFilterExcludeTags'); if(excludeEl) excludeEl.value = (compareFilter.excludeTags||[]).join(', ');
    const outcomes = Array.isArray(compareFilter.outcomes) ? compareFilter.outcomes : [];
    document.querySelectorAll('.compareFilterOutcome').forEach(cb=>{
      const val = cb.value.toString().toUpperCase();
      cb.checked = outcomes.includes(val);
    });
  }

  function applyCompareFilterFromUI(){
    compareFilter = readCompareFilterFromUI();
    syncCompareFilterUI();
    recalculateCompareStats();
    refreshCompareView();
    showToast('Compare filters applied');
  }

  function clearCompareFilters(){
    compareFilter = createDefaultCompareFilter();
    syncCompareFilterUI();
    recalculateCompareStats();
    refreshCompareView();
    showToast('Compare filters cleared');
  }

  function renderCompareSlot(slot){
    const state = compareSlotsState[slot];
    if(!state) return;
    const nameEl = document.getElementById(`compareName-${slot}`);
    const emptyEl = document.getElementById(`compareEmpty-${slot}`);
    const metaEl = document.getElementById(`compareMeta-${slot}`);
    const setupsEl = document.getElementById(`compareSetups-${slot}`);
    const hasRawData = !!state.data;
    const hasStats = !!state.stats;
    const displayName = state.name || state.label;
    if(nameEl){
      if(hasStats){
        nameEl.textContent = displayName;
        nameEl.classList.remove('muted');
      }else if(hasRawData){
        nameEl.textContent = `${displayName} (no matches)`;
        nameEl.classList.add('muted');
      }else{
        nameEl.textContent = 'No dataset';
        nameEl.classList.add('muted');
      }
    }
    if(emptyEl){
      if(hasStats){
        emptyEl.hidden = true;
      }else{
        emptyEl.hidden = false;
        emptyEl.textContent = hasRawData ? 'No trades match the current filters.' : 'Load an exported study to begin.';
      }
    }
    if(metaEl){
      if(hasStats){
        const stats = state.stats;
        const meta = state.meta || {};
        const info = [];
        if(meta.source){
          const srcMap = {current:'Current workspace', json:'Imported JSON', bundle:'Bundle (ZIP)', folder:'Exported folder'};
          info.push(`<div><strong>Source:</strong> ${srcMap[meta.source] || meta.source}</div>`);
        }
        if(meta.fileName) info.push(`<div><strong>File:</strong> ${meta.fileName}</div>`);
        if(meta.dirName) info.push(`<div><strong>Folder:</strong> ${meta.dirName}</div>`);
        if(meta.savedAt){
          let saved = meta.savedAt;
          try{
            const d = new Date(meta.savedAt);
            if(!Number.isNaN(d.getTime())) saved = d.toLocaleString();
          }catch(_){ /* ignore */ }
          info.push(`<div><strong>Saved:</strong> ${saved}</div>`);
        }
        info.push(`<div><strong>Trades:</strong> ${stats.trades}</div>`);
        info.push(`<div><strong>Net R:</strong> ${fmt(stats.netR,2)}R</div>`);
        info.push(`<div><strong>Win Rate:</strong> ${fmt(stats.winRate,1)}%</div>`);
        info.push(`<div><strong>Expectancy:</strong> ${fmt(stats.expectancy,2)}R/trade</div>`);
        info.push(`<div><strong>Avg R/day:</strong> ${fmt(stats.avgRPerDay,2)}R</div>`);
        info.push(`<div><strong>Max DD:</strong> ${fmt(stats.maxDrawdown,2)}R</div>`);
        info.push(`<div><strong>Positive Days:</strong> ${stats.positiveDays}/${stats.totalDays}</div>`);
        if(stats.bestDayDate){
          info.push(`<div><strong>Best Day:</strong> ${fmt(stats.bestDay,2)}R on ${dispDate(stats.bestDayDate)}</div>`);
        }
        if(stats.worstDayDate){
          info.push(`<div><strong>Worst Day:</strong> ${fmt(stats.worstDay,2)}R on ${dispDate(stats.worstDayDate)}</div>`);
        }
        metaEl.innerHTML = info.join('');
        metaEl.hidden = false;
      } else {
        metaEl.innerHTML = '';
        metaEl.hidden = true;
      }
    }
    if(setupsEl){
      setupsEl.innerHTML = '';
      if(hasStats){
        const items = state.stats.setupStats.slice(0,5);
        if(items.length===0){
          setupsEl.innerHTML = '<span class="muted" style="font-size:12px">No setup data</span>';
        } else {
          items.forEach(item=>{
            const net = `${item.netR>=0?'+':''}${fmt(item.netR,2)}R`;
            const wr = `${fmt(item.winRate,1)}% WR`;
            const el = document.createElement('span');
            el.className = 'compare-tag';
            el.textContent = `${item.name} · ${net} · ${wr}`;
            setupsEl.appendChild(el);
          });
        }
      } else {
        setupsEl.innerHTML = '<span class="muted" style="font-size:12px">—</span>';
      }
    }
  }

  function formatCompareMetricValue(value, metric){
    if(value===null || value===undefined) return '—';
    if(metric.unit==='drawdown') value = Math.abs(value);
    if(metric.unit==='percent') return `${fmt(value,1)}%`;
    if(metric.unit==='r') return `${fmt(value,2)}R`;
    if(metric.unit==='ratio'){
      if(!Number.isFinite(value)) return '∞';
      return fmt(value,2);
    }
    if(metric.unit==='count') return `${Math.round(value)}`;
    return fmt(value,2);
  }

  function updateCompareSummary(){
    const wrap = document.getElementById('compareKpiWrap');
    const note = document.getElementById('compareDiffNote');
    if(!wrap) return;
    wrap.innerHTML='';
    const left = compareSlotsState.left.stats;
    const right = compareSlotsState.right.stats;
    const hasLeft = !!left;
    const hasRight = !!right;
    const leftLoaded = !!compareSlotsState.left.data;
    const rightLoaded = !!compareSlotsState.right.data;
    if(!hasLeft && !hasRight){
      if(note){
        if(compareFilterActive() && (leftLoaded || rightLoaded)){
          note.textContent = 'No trades match the current shared filters. Adjust filters to compare results.';
        }else{
          note.textContent = 'Load two studies to see comparative analytics. Metrics respect the global trailing profit toggle.';
        }
      }
      renderCompareExtendedTable([], left, right, hasLeft, hasRight, leftLoaded, rightLoaded);
      return;
    }
    if(note){
      let text;
      if(hasLeft && hasRight){
        text = 'Δ is calculated as Study A minus Study B.';
      }else if(!hasLeft && leftLoaded){
        text = 'Study A has no trades matching the current filters.';
      }else if(!hasRight && rightLoaded){
        text = 'Study B has no trades matching the current filters.';
      }else{
        text = 'Load the second study to unlock comparisons.';
      }
      if(compareFilterActive()) text += ' Shared filters active.';
      note.textContent = text;
    }
    const metrics = [
      {key:'netR', label:'Net R', unit:'r', better:'higher'},
      {key:'winRate', label:'Win Rate', unit:'percent', better:'higher'},
      {key:'expectancy', label:'Expectancy', unit:'r', better:'higher'},
      {key:'trades', label:'Trades', unit:'count', better:'higher'},
      {key:'avgRPerDay', label:'Avg R/Day', unit:'r', better:'higher'},
      {key:'profitFactor', label:'Profit Factor', unit:'ratio', better:'higher'},
      {key:'maxDrawdown', label:'Max Drawdown', unit:'drawdown', better:'lower'},
      {key:'positiveDayPct', label:'Positive Days', unit:'percent', better:'higher'},
      {key:'tradeMedian', label:'Median R/Trade', unit:'r', better:'higher'},
      {key:'tradeStd', label:'Std Dev (R)', unit:'r', better:'lower'},
      {key:'avgReward', label:'Avg Reward (R)', unit:'r', better:'higher'},
      {key:'avgRisk', label:'Avg Risk (R)', unit:'r', better:'lower'},
      {key:'payoffRatio', label:'Payoff Ratio', unit:'ratio', better:'higher'},
      {key:'dailyMedian', label:'Median Day (R)', unit:'r', better:'higher'},
      {key:'bestWinStreak', label:'Best Win Streak', unit:'count', better:'higher'},
      {key:'worstLossStreak', label:'Worst Loss Streak', unit:'count', better:'lower'}
    ];
    metrics.forEach(metric=>{
      const card = document.createElement('div');
      card.className = 'compare-kpi';
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = metric.label;
      const values = document.createElement('div');
      values.className = 'values';
      const leftVal = document.createElement('span');
      leftVal.textContent = `A ${hasLeft ? formatCompareMetricValue(left[metric.key], metric) : '—'}`;
      const rightVal = document.createElement('span');
      rightVal.textContent = `B ${hasRight ? formatCompareMetricValue(right[metric.key], metric) : '—'}`;
      values.appendChild(leftVal);
      values.appendChild(rightVal);
      card.appendChild(label);
      card.appendChild(values);
      const diffEl = document.createElement('div');
      diffEl.className = 'diff';
      if(hasLeft && hasRight){
        let aVal = left[metric.key];
        let bVal = right[metric.key];
        if(metric.unit==='drawdown'){ aVal = Math.abs(aVal); bVal = Math.abs(bVal); }
        let diff = null;
        if(metric.unit==='ratio' && (!Number.isFinite(aVal) || !Number.isFinite(bVal))){
          diff = null;
        } else {
          diff = aVal - bVal;
        }
        if(diff===null){
          diffEl.textContent = 'Δ —';
        } else {
          const formatted = formatCompareMetricValue(Math.abs(diff), metric);
          const prefix = diff>=0 ? '+' : '−';
          let pctText = '—';
          if(bVal === 0){
            if(aVal === 0){ pctText = '0%'; }
            else { pctText = '∞%'; }
          }else{
            const pct = (diff / Math.abs(bVal)) * 100;
            pctText = Number.isFinite(pct) ? `${pct>=0?'+':''}${fmt(pct,1)}%` : '∞%';
          }
          diffEl.textContent = `Δ ${prefix}${formatted.replace(/^[-+]/,'')} (${pctText})`;
          const improved = metric.better==='higher' ? diff>0 : diff<0;
          const worsened = metric.better==='higher' ? diff<0 : diff>0;
          if(improved) diffEl.classList.add('positive');
          else if(worsened) diffEl.classList.add('negative');
        }
      } else {
        diffEl.textContent = 'Δ —';
      }
      card.appendChild(diffEl);
      wrap.appendChild(card);
    });

    const extendedMetrics = [
      ...metrics,
      {key:'lossRate', label:'Loss Rate', unit:'percent', better:'lower'},
      {key:'breakevenRate', label:'Breakeven Rate', unit:'percent', better:'lower'},
      {key:'winLossRatio', label:'Win/Loss Ratio', unit:'ratio', better:'higher'},
      {key:'bestDay', label:'Best Day (R)', unit:'r', better:'higher'},
      {key:'worstDay', label:'Worst Day (R)', unit:'r', better:'higher'}
    ];
    renderCompareExtendedTable(extendedMetrics, left, right, hasLeft, hasRight, leftLoaded, rightLoaded);
  }

  function renderCompareExtendedTable(defs, left, right, hasLeft, hasRight, leftLoaded, rightLoaded){
    const table = document.getElementById('compareExtendedTable');
    if(!table) return;
    const tbody = table.querySelector('tbody');
    if(!tbody) return;
    tbody.innerHTML='';
    if(!hasLeft && !hasRight){
      const row = document.createElement('tr');
      const cell = document.createElement('td');
      cell.colSpan = 4;
      cell.className = 'muted';
      if(compareFilterActive() && (leftLoaded || rightLoaded)){
        cell.textContent = 'No trades match the current filters.';
      }else{
        cell.textContent = 'Load studies to view metrics.';
      }
      row.appendChild(cell);
      tbody.appendChild(row);
      return;
    }
    defs.forEach(metric=>{
      const row = document.createElement('tr');
      const labelCell = document.createElement('td');
      labelCell.textContent = metric.label;
      labelCell.className = 'metric-label';
      row.appendChild(labelCell);

      const leftCell = document.createElement('td');
      if(hasLeft){
        leftCell.textContent = formatCompareMetricValue(left?.[metric.key], metric);
      }else{
        leftCell.textContent = leftLoaded ? 'No matches' : '—';
        if(leftLoaded) leftCell.classList.add('muted');
      }
      row.appendChild(leftCell);

      const rightCell = document.createElement('td');
      if(hasRight){
        rightCell.textContent = formatCompareMetricValue(right?.[metric.key], metric);
      }else{
        rightCell.textContent = rightLoaded ? 'No matches' : '—';
        if(rightLoaded) rightCell.classList.add('muted');
      }
      row.appendChild(rightCell);

      const diffCell = document.createElement('td');
      if(hasLeft && hasRight){
        let aVal = left?.[metric.key];
        let bVal = right?.[metric.key];
        if(metric.unit==='drawdown'){ aVal = Math.abs(aVal); bVal = Math.abs(bVal); }
        let diff = null;
        if(metric.unit==='ratio' && (!Number.isFinite(aVal) || !Number.isFinite(bVal))){
          diff = null;
        } else {
          diff = aVal - bVal;
        }
        if(diff===null){
          diffCell.textContent = '—';
        } else {
          const formatted = formatCompareMetricValue(Math.abs(diff), metric);
          const prefix = diff>=0 ? '+' : '−';
          let pctText = '—';
          if(bVal === 0){
            if(aVal === 0){ pctText = '0%'; }
            else { pctText = '∞%'; }
          }else{
            const pct = (diff / Math.abs(bVal)) * 100;
            pctText = Number.isFinite(pct) ? `${pct>=0?'+':''}${fmt(pct,1)}%` : '∞%';
          }
          diffCell.textContent = `${prefix}${formatted.replace(/^[-+]/,'')} (${pctText})`;
          const improved = metric.better==='higher' ? diff>0 : diff<0;
          const worsened = metric.better==='higher' ? diff<0 : diff>0;
          if(improved) diffCell.classList.add('diff-positive');
          else if(worsened) diffCell.classList.add('diff-negative');
        }
      }else{
        diffCell.textContent = '—';
      }
      row.appendChild(diffCell);
      tbody.appendChild(row);
    });
  }

  function updateCompareCharts(force=false){
    const left = compareSlotsState.left.stats;
    const right = compareSlotsState.right.stats;
    const hasLeft = !!left;
    const hasRight = !!right;

    const tab = document.getElementById('tab-compare');
    const isVisible = tab && tab.classList.contains('active');
    if(!isVisible && !force){
      compareChartsDirty = (hasLeft || hasRight);
      return;
    }
    compareChartsDirty = false;

    Object.values(compareCharts.key||{}).forEach(chart=>{ try{ chart?.destroy(); }catch(_){}});
    compareCharts.key = {};
    const keyDefs = [
      {
        id:'compareKeyNetChart',
        title:'Net R',
        unit:'r',
        accessor:(stats)=> stats?.netR ?? null,
        formatter:(v)=> `${fmt(v,2)}R`
      },
      {
        id:'compareKeyExpectChart',
        title:'Expectancy',
        unit:'r',
        accessor:(stats)=> stats?.expectancy ?? null,
        formatter:(v)=> `${fmt(v,3)}R`
      },
      {
        id:'compareKeyAvgChart',
        title:'Avg R/day',
        unit:'r',
        accessor:(stats)=> stats?.avgRPerDay ?? null,
        formatter:(v)=> `${fmt(v,3)}R`
      },
      {
        id:'compareKeyDDChart',
        title:'Max Drawdown',
        unit:'r',
        accessor:(stats)=> stats ? -Math.abs(stats.maxDrawdown||0) : null,
        formatter:(v)=> `${fmt(Math.abs(v),2)}R`
      }
    ];
    keyDefs.forEach(def=>{
      const canvas = document.getElementById(def.id);
      if(!canvas) return;
      const ctx = canvas.getContext('2d');
      const valLeftRaw = def.accessor(left);
      const valRightRaw = def.accessor(right);
      const values = [];
      if(hasLeft) values.push(valLeftRaw);
      if(hasRight) values.push(valRightRaw);
      if(values.length===0) return;
      const finiteVals = values.filter(v=> Number.isFinite(v));
      let min = 0, max = 0;
      if(finiteVals.length){
        min = Math.min(...finiteVals, 0);
        max = Math.max(...finiteVals, 0);
        if(min===max){
          const pad = (Math.abs(min) || 1) * 0.2;
          min -= pad;
          max += pad;
        }else{
          const pad = (max - min) * 0.15;
          min -= pad;
          max += pad;
        }
      }else{
        min = -1;
        max = 1;
      }
      const datasets = [];
      if(hasLeft){
        datasets.push({
          label: compareSlotsState.left.name || compareSlotsState.left.label,
          data:[valLeftRaw],
          backgroundColor: compareColors.left.background,
          borderColor: compareColors.left.border,
          borderWidth:1
        });
      }
      if(hasRight){
        datasets.push({
          label: compareSlotsState.right.name || compareSlotsState.right.label,
          data:[valRightRaw],
          backgroundColor: compareColors.right.background,
          borderColor: compareColors.right.border,
          borderWidth:1
        });
      }
      compareCharts.key[def.id] = new Chart(ctx, {
        type:'bar',
        data:{ labels:[def.title], datasets },
        options:{
          animation:false,
          responsive:true,
          maintainAspectRatio:false,
          scales:{
            x:{ stack:false },
            y:{
              min,
              max,
              ticks:{ callback:(v)=> def.formatter(v) }
            }
          },
          plugins:{
            legend:{ display:true },
            tooltip:{
              callbacks:{
                label(context){
                  return `${context.dataset.label}: ${def.formatter(context.raw)}`;
                }
              }
            }
          }
        }
      });
    });

    const equityCanvas = document.getElementById('compareEquityChart');
    if(compareCharts.equity){ compareCharts.equity.destroy(); compareCharts.equity=null; }
    if(equityCanvas && (hasLeft || hasRight)){
      const labels = Array.from(new Set([
        ...(hasLeft ? left.equitySeries.map(p=>p.date) : []),
        ...(hasRight ? right.equitySeries.map(p=>p.date) : [])
      ])).sort();
      const datasets = [];
      if(hasLeft){
        let current = 0;
        const serie = labels.map(date=>{
          if(Object.prototype.hasOwnProperty.call(left.equityMap, date)) current = left.equityMap[date];
          return current;
        });
        datasets.push({
          label: compareSlotsState.left.name || compareSlotsState.left.label,
          data: serie,
          fill:false,
          borderColor: compareColors.left.border,
          backgroundColor: compareColors.left.border,
          borderWidth:2,
          tension:0.15,
          spanGaps:true
        });
      }
      if(hasRight){
        let current = 0;
        const serie = labels.map(date=>{
          if(Object.prototype.hasOwnProperty.call(right.equityMap, date)) current = right.equityMap[date];
          return current;
        });
        datasets.push({
          label: compareSlotsState.right.name || compareSlotsState.right.label,
          data: serie,
          fill:false,
          borderColor: compareColors.right.border,
          backgroundColor: compareColors.right.border,
          borderWidth:2,
          tension:0.15,
          spanGaps:true
        });
      }
      const ctx = equityCanvas.getContext('2d');
      compareCharts.equity = new Chart(ctx, {
        type:'line',
        data:{ labels, datasets },
        options:{
          animation:false,
          responsive:true,
          maintainAspectRatio:false,
          scales:{
            y:{ ticks:{ callback:(v)=> `${fmt(v,2)}R` } }
          }
        }
      });
    }

    const setupCanvas = document.getElementById('compareSetupChart');
    if(compareCharts.setup){ compareCharts.setup.destroy(); compareCharts.setup=null; }
    if(setupCanvas && (hasLeft || hasRight)){
      const map = new Map();
      if(hasLeft){
        left.setupStats.forEach(item=>{
          if(!map.has(item.name)) map.set(item.name, {name:item.name, left:0, right:0});
          map.get(item.name).left = item.netR;
        });
      }
      if(hasRight){
        right.setupStats.forEach(item=>{
          if(!map.has(item.name)) map.set(item.name, {name:item.name, left:0, right:0});
          map.get(item.name).right = item.netR;
        });
      }
      const list = Array.from(map.values()).map(item=>{
        return {...item, weight: Math.max(Math.abs(item.left||0), Math.abs(item.right||0))};
      }).sort((a,b)=> b.weight - a.weight).slice(0,6);
      const labels = list.map(item=> item.name);
      const leftData = list.map(item=> item.left || 0);
      const rightData = list.map(item=> item.right || 0);
      const ctx = setupCanvas.getContext('2d');
      compareCharts.setup = new Chart(ctx, {
        type:'bar',
        data:{
          labels,
          datasets:[
            hasLeft ? {
              label: compareSlotsState.left.name || compareSlotsState.left.label,
              data: leftData,
              backgroundColor: compareColors.left.background,
              borderColor: compareColors.left.border,
              borderWidth:1
            } : null,
            hasRight ? {
              label: compareSlotsState.right.name || compareSlotsState.right.label,
              data: rightData,
              backgroundColor: compareColors.right.background,
              borderColor: compareColors.right.border,
              borderWidth:1
            } : null
          ].filter(Boolean)
        },
        options:{
          animation:false,
          responsive:true,
          maintainAspectRatio:false,
          scales:{ y:{ beginAtZero:true, ticks:{ callback:(v)=> `${fmt(v,2)}R` } } }
        }
      });
    }

    const outcomeCanvas = document.getElementById('compareOutcomeChart');
    if(compareCharts.outcome){ compareCharts.outcome.destroy(); compareCharts.outcome=null; }
    if(outcomeCanvas && (hasLeft || hasRight)){
      const labels = ['Wins','Losses','Breakevens'];
      const datasets = [];
      if(hasLeft){
        datasets.push({
          label: compareSlotsState.left.name || compareSlotsState.left.label,
          data: [left.wins, left.losses, left.breakevens],
          backgroundColor: compareColors.left.background,
          borderColor: compareColors.left.border,
          borderWidth:1
        });
      }
      if(hasRight){
        datasets.push({
          label: compareSlotsState.right.name || compareSlotsState.right.label,
          data: [right.wins, right.losses, right.breakevens],
          backgroundColor: compareColors.right.background,
          borderColor: compareColors.right.border,
          borderWidth:1
        });
      }
      const ctx = outcomeCanvas.getContext('2d');
      compareCharts.outcome = new Chart(ctx, {
        type:'bar',
        data:{ labels, datasets },
        options:{
          animation:false,
          responsive:true,
          maintainAspectRatio:false,
          scales:{ y:{ beginAtZero:true, ticks:{ precision:0 } } }
        }
      });
    }
  }

  function refreshCompareView(){
    renderCompareSlot('left');
    renderCompareSlot('right');
    updateCompareSummary();
    updateCompareCharts();
  }

  function commitComparePayload(slot, payload, successMessage){
    if(!compareSlotsState[slot]) throw new Error('Unknown slot');
    if(!payload || !payload.data) throw new Error('No data provided');
    const stats = computeCompareStats(payload.data);
    const hasTrades = Object.values(payload.data||{}).some(day=> Array.isArray(day?._events) && day._events.length>0);
    if(!stats && !hasTrades) throw new Error('Study contains no trades to analyse');
    payload.stats = stats || null;
    applyCompareSlot(slot, payload);
    refreshCompareView();
    if(!stats && hasTrades){
      showToast('No trades match the current filters. Dataset loaded.');
    }else if(successMessage){
      showToast(successMessage);
    }
  }

  async function handleCompareAction(slot, action){
    if(!compareSlotsState[slot]) return;
    try{
      if(action==='use-current'){
        if(Object.keys(dailyData||{}).length===0){ alert('Current dataset is empty. Record or load trades first.'); return; }
        const payload = snapshotCompareFromCurrent();
        commitComparePayload(slot, payload, `${compareSlotsState[slot].label} linked to current dataset`);
        return;
      }
      if(action==='load-json'){
        const input = document.getElementById(`compareJson-${slot}`);
        if(input){ input.value=''; input.click(); }
        return;
      }
      if(action==='load-bundle'){
        const input = document.getElementById(`compareBundle-${slot}`);
        if(input){ input.value=''; input.click(); }
        return;
      }
      if(action==='load-folder'){
        if(!window.showDirectoryPicker){ alert('Directory load requires a Chromium browser. Use Load Bundle (ZIP) instead.'); return; }
        const dir = await window.showDirectoryPicker({ id:`tt_compare_${slot}`, mode:'read', startIn:'downloads' });
        const payload = await parseCompareDirectoryHandle(dir);
        commitComparePayload(slot, payload, `${compareSlotsState[slot].label} loaded from folder`);
        return;
      }
    }catch(err){
      if(err && err.name==='AbortError') return;
      alert(err?.message || 'Failed to load study');
    }
  }

  function setupCompareTab(){
    syncCompareFilterUI();
    document.getElementById('compareApplyFilters')?.addEventListener('click', (e)=>{ e.preventDefault(); applyCompareFilterFromUI(); });
    document.getElementById('compareClearFilters')?.addEventListener('click', (e)=>{ e.preventDefault(); clearCompareFilters(); });
    document.querySelectorAll('.compare-filter-card input').forEach(inp=>{
      inp.addEventListener('keydown', (e)=>{
        if(e.key==='Enter'){
          e.preventDefault();
          applyCompareFilterFromUI();
        }
      });
    });
    document.querySelectorAll('[data-compare-action]').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const slot = btn.getAttribute('data-slot');
        const action = btn.getAttribute('data-compare-action');
        if(!slot || !action) return;
        await handleCompareAction(slot, action);
      });
    });
    ['left','right'].forEach(slot=>{
      const jsonInput = document.getElementById(`compareJson-${slot}`);
      if(jsonInput){
        jsonInput.addEventListener('change', async (e)=>{
          const file = e.target.files && e.target.files[0];
          try{
            if(file){
              const payload = await parseCompareJsonFile(file);
              commitComparePayload(slot, payload, `${compareSlotsState[slot].label} loaded from JSON`);
            }
          }catch(err){
            alert(err?.message || 'Failed to parse JSON');
          }finally{
            e.target.value='';
          }
        });
      }
      const bundleInput = document.getElementById(`compareBundle-${slot}`);
      if(bundleInput){
        bundleInput.addEventListener('change', async (e)=>{
          const file = e.target.files && e.target.files[0];
          try{
            if(file){
              const payload = await parseCompareBundleFile(file);
              commitComparePayload(slot, payload, `${compareSlotsState[slot].label} loaded from bundle`);
            }
          }catch(err){
            alert(err?.message || 'Failed to read bundle');
          }finally{
            e.target.value='';
          }
        });
      }
    });
    refreshCompareView();
  }

  function recalculateCompareStats(){
    let changed = false;
    ['left','right'].forEach(slot=>{
      const state = compareSlotsState[slot];
      if(state?.data){
        const stats = computeCompareStats(state.data);
        state.stats = stats;
        changed = true;
      }
    });
    if(changed){
      refreshCompareView();
    }
  }

  // ====== Journal Utilities ======
  function ensureJournalStructure(){
    if(!journalData || typeof journalData !== 'object') journalData = {daily:{}, weekly:{}, custom:[], tags:[]};
    if(!journalData.daily || typeof journalData.daily !== 'object') journalData.daily = {};
    if(!journalData.weekly || typeof journalData.weekly !== 'object') journalData.weekly = {};
    if(!Array.isArray(journalData.custom)) journalData.custom = [];
    if(!Array.isArray(journalData.tags)) journalData.tags = [];
    journalData.custom = journalData.custom.filter(j=> !!j).map(j=>{
      const norm = {...j};
      if(!norm.id) norm.id = `jc_${Math.random().toString(36).slice(2,9)}`;
      if(!norm.name) norm.name = 'Untitled Journal';
      if(!norm.createdAt) norm.createdAt = new Date().toISOString();
      if(!Array.isArray(norm.entries)) norm.entries = [];
      norm.entries = norm.entries.filter(e=> !!e).map(e=> makeJournalEntry(e));
      return norm;
    });
    return journalData;
  }

  function makeJournalEntry(extra={}){
    return {
      id: extra.id || `je_${Math.random().toString(36).slice(2,10)}`,
      title: typeof extra.title==='string' ? extra.title.slice(0,120) : '',
      content: typeof extra.content==='string' ? extra.content : '',
      tags: Array.isArray(extra.tags) ? extra.tags.map(normalizeTag).filter(Boolean) : [],
      mood: Number.isFinite(parseInt(extra.mood,10)) ? clamp(parseInt(extra.mood,10), 1, 5) : 3,
      pinned: !!extra.pinned,
      createdAt: extra.createdAt || new Date().toISOString(),
      updatedAt: extra.updatedAt || new Date().toISOString()
    };
  }

  function normalizeTag(tag){ return typeof tag==='string' ? tag.trim().replace(/\s+/g,' ').slice(0,32) : ''; }

  function ensureJournalTag(tag){
    const t = normalizeTag(tag);
    if(!t) return null;
    ensureJournalStructure();
    if(!journalData.tags.includes(t)) journalData.tags.push(t);
    journalData.tags.sort((a,b)=> a.localeCompare(b));
    return t;
  }

  function removeTagFromJournal(tag){
    const t = normalizeTag(tag);
    if(!t) return;
    ensureJournalStructure();
    journalData.tags = journalData.tags.filter(x=> x!==t);
  }

  function stripHTML(html){
    if(!html) return '';
    const tmp = document.createElement('div');
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || '';
  }

  function weekIdFromDate(dateStr){
    if(!dateStr) return null;
    const date = new Date(`${dateStr}T00:00:00Z`);
    if(Number.isNaN(date.getTime())) return null;
    const year = date.getUTCFullYear();
    const wk = weekKey(date.toISOString().slice(0,10));
    return `${year}-W${String(wk).padStart(2,'0')}`;
  }

  function getWeekRange(weekId){
    if(!weekId || !weekId.includes('-W')) return {start:null, end:null};
    const [y, wRaw] = weekId.split('-W');
    const year = parseInt(y,10);
    const week = parseInt(wRaw,10);
    if(!Number.isFinite(year) || !Number.isFinite(week)) return {start:null, end:null};
    const simple = new Date(Date.UTC(year,0,1 + (week-1)*7));
    const dow = simple.getUTCDay() || 7;
    const start = new Date(simple);
    start.setUTCDate(simple.getUTCDate() + 1 - dow);
    const end = new Date(start);
    end.setUTCDate(start.getUTCDate()+6);
    return {start: start.toISOString().slice(0,10), end: end.toISOString().slice(0,10)};
  }

  function datesForWeek(weekId){
    const {start, end} = getWeekRange(weekId);
    if(!start || !end) return [];
    const dates=[];
    const s = new Date(`${start}T00:00:00Z`);
    const e = new Date(`${end}T00:00:00Z`);
    for(let d=new Date(s); d<=e; d.setUTCDate(d.getUTCDate()+1)){
      dates.push(d.toISOString().slice(0,10));
    }
    return dates;
  }

  function computeStatsForDates(dates){
    const unique = Array.from(new Set(dates || [])).filter(Boolean);
    let wins=0, losses=0, breakevens=0, trades=0, netR=0;
    unique.forEach(date=>{
      const day = dailyData[date];
      if(!day) return;
      (day._events||[]).forEach(ev=>{
        trades++;
        const outcome = effectiveOutcome(ev);
        if(outcome==='W') wins++;
        else if(outcome==='L') losses++;
        else breakevens++;
        netR += eventR(ev);
      });
    });
    const expectancy = trades? netR/trades : 0;
    const winRate = trades? (wins/trades*100) : 0;
    const avgRPerDay = unique.length? netR/unique.length : 0;
    return {wins, losses, breakevens, trades, netR, expectancy, winRate, avgRPerDay, days: unique.length};
  }

  function collectAllJournalTags(){
    ensureJournalStructure();
    const set = new Set();
    Object.values(journalData.daily||{}).forEach(e=> (e?.tags||[]).forEach(t=> set.add(normalizeTag(t))));
    Object.values(journalData.weekly||{}).forEach(e=> (e?.tags||[]).forEach(t=> set.add(normalizeTag(t))));
    journalData.custom.forEach(j=> (j.entries||[]).forEach(e=> (e.tags||[]).forEach(t=> set.add(normalizeTag(t)))));
    journalData.tags = Array.from(set).filter(Boolean).sort((a,b)=> a.localeCompare(b));
    return journalData.tags;
  }

  function ensureDailyJournal(date){
    ensureJournalStructure();
    if(!date) return null;
    const key = date.slice(0,10);
    if(!journalData.daily[key]){
      const day = dailyData[key];
      const text = day?.note || '';
      let html = '';
      if(text){
        const div = document.createElement('div');
        div.textContent = text;
        html = div.innerHTML.replace(/\n/g,'<br>');
      }
      const entry = makeJournalEntry({
        title: dispDate(key),
        content: html,
        mood: 3
      });
      entry.date = key;
      journalData.daily[key] = entry;
    }
    const entry = journalData.daily[key];
    if(entry && !entry.date) entry.date = key;
    return entry;
  }

  function ensureWeeklyJournal(weekId){
    ensureJournalStructure();
    if(!weekId) return null;
    if(!journalData.weekly[weekId]){
      const {start, end} = getWeekRange(weekId);
      const entry = makeJournalEntry({
        title: `Week ${weekId}`,
        mood: 3
      });
      entry.week = weekId;
      entry.start = start;
      entry.end = end;
      journalData.weekly[weekId] = entry;
    } else {
      const entry = journalData.weekly[weekId];
      if(!entry.week) entry.week = weekId;
      const {start, end} = getWeekRange(weekId);
      if(!entry.start) entry.start = start;
      if(!entry.end) entry.end = end;
    }
    return journalData.weekly[weekId];
  }

  function getCustomJournal(id){
    ensureJournalStructure();
    if(!id) return journalData.custom[0] || null;
    return journalData.custom.find(j=> j.id===id) || null;
  }

  function addCustomJournal(name){
    ensureJournalStructure();
    const journal = {
      id: `jc_${Math.random().toString(36).slice(2,9)}`,
      name: name && name.trim() ? name.trim().slice(0,80) : 'Personal Journal',
      createdAt: new Date().toISOString(),
      entries: []
    };
    journalData.custom.push(journal);
    return journal;
  }

  function createCustomEntry(journal, tpl={}){
    if(!journal) return null;
    const entry = makeJournalEntry(tpl);
    journal.entries.unshift(entry);
    return entry;
  }

  function deleteCustomEntry(journal, entryId){
    if(!journal) return;
    journal.entries = journal.entries.filter(e=> e.id !== entryId);
  }

  function addTagToEntry(entry, tag){
    if(!entry) return false;
    const t = ensureJournalTag(tag);
    if(!t) return false;
    if(!Array.isArray(entry.tags)) entry.tags = [];
    if(!entry.tags.includes(t)) entry.tags.push(t);
    entry.tags = entry.tags.map(normalizeTag).filter(Boolean).sort((a,b)=> a.localeCompare(b));
    return true;
  }

  function removeTagFromEntry(entry, tag){
    if(!entry || !Array.isArray(entry.tags)) return;
    const t = normalizeTag(tag);
    entry.tags = entry.tags.filter(x=> x!==t);
  }

  function renderChipList(box, tags, onRemove){
    if(!box) return;
    [...box.querySelectorAll('.chip')].forEach(n=> n.remove());
    const input = box.querySelector('input');
    const anchor = input || box.lastChild;
    (tags||[]).forEach(tag=>{
      const chip = document.createElement('span');
      chip.className = 'chip';
      if(onRemove){
        chip.innerHTML = `${tag} <span class="xbtn" data-tag-remove="${tag}">×</span>`;
      }else{
        chip.textContent = tag;
      }
      box.insertBefore(chip, anchor);
    });
    if(onRemove){
      box.querySelectorAll('[data-tag-remove]').forEach(btn=>{
        btn.onclick = ()=> onRemove(btn.getAttribute('data-tag-remove'));
      });
    }
  }

  function countWords(text){
    if(!text) return 0;
    return text.trim().split(/\s+/).filter(Boolean).length;
  }
  function dispDate(s){ if(!s) return '—'; if(s.includes('T')) s=s.slice(0,10); const p=s.split('-'); return p.length===3? `${p[0]}/${p[1]}/${p[2]}` : s.replaceAll('-','/'); }
  function pushUndo(fn){ undoStack.push(fn); if(undoStack.length>20) undoStack.shift(); }
  function showToast(msg, undoFn){
    const box = $('#toast'); if(!box) return;
    const t = document.createElement('div'); t.className='t'; t.textContent=msg;
    if(undoFn){ const u=document.createElement('span'); u.className='undo'; u.textContent='Undo'; u.onclick=()=>{ try{undoFn();} finally{box.removeChild(t);} }; t.appendChild(u); }
    box.appendChild(t); setTimeout(()=>{ if(t.isConnected) box.removeChild(t); }, 2800);
  }

  // Safe deep clone that avoids JSON stringify blow-ups with large screenshots
  function deepCloneData(obj){
    if(typeof structuredClone === 'function'){
      try { return structuredClone(obj); } catch(_){}
    }
    const seen = new WeakMap();
    const cloneInner = (val)=>{
      if(val===null || typeof val !== 'object') return val;
      if(seen.has(val)) return seen.get(val);
      if(Array.isArray(val)){
        const arr = new Array(val.length);
        seen.set(val, arr);
        for(let i=0;i<val.length;i++) arr[i] = cloneInner(val[i]);
        return arr;
      }
      const out = {};
      seen.set(val, out);
      for(const k of Object.keys(val)) out[k] = cloneInner(val[k]);
      return out;
    };
    return cloneInner(obj);
  }

  // ====== Large Data Persistence (IndexedDB for screenshots) ======
  // We use IndexedDB to persist screenshots across refresh, since localStorage cannot hold large images.
  function getDatasetKey(){ return currentFileName ? `file:${currentFileName}` : 'unsaved'; }
  function openShotsDB(){
    return new Promise((resolve, reject)=>{
      const req = indexedDB.open('tt_large_v1', 2);
      req.onupgradeneeded = ()=>{
        const db = req.result;
        if(!db.objectStoreNames.contains('shots')){
          const os = db.createObjectStore('shots', { keyPath:'key' });
          os.createIndex('by_dataset', 'dataset');
        }
        if(!db.objectStoreNames.contains('prefs')){
          db.createObjectStore('prefs', { keyPath:'k' });
        }
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }
  function idbPutShot(date, dataUrl){
    return openShotsDB().then(db=> new Promise((resolve,reject)=>{
      const tx = db.transaction('shots','readwrite');
      const store = tx.objectStore('shots');
      const key = `${getDatasetKey()}|${date}`;
      store.put({ key, dataset:getDatasetKey(), date, dataUrl, updatedAt: Date.now() });
      tx.oncomplete = ()=> resolve(true);
      tx.onerror = ()=> reject(tx.error);
    }));
  }
  function idbDeleteShot(date){
    return openShotsDB().then(db=> new Promise((resolve,reject)=>{
      const tx = db.transaction('shots','readwrite');
      tx.objectStore('shots').delete(`${getDatasetKey()}|${date}`);
      tx.oncomplete = ()=> resolve(true);
      tx.onerror = ()=> reject(tx.error);
    }));
  }
  // Prefs helpers (store FileSystemDirectoryHandle etc.)
  function idbSetPref(k, v){
    return openShotsDB().then(db=> new Promise((resolve,reject)=>{
      const tx = db.transaction('prefs','readwrite');
      tx.objectStore('prefs').put({k, v});
      tx.oncomplete = ()=> resolve(true);
      tx.onerror = ()=> reject(tx.error);
    }));
  }
  function idbGetPref(k){
    return openShotsDB().then(db=> new Promise((resolve,reject)=>{
      const tx = db.transaction('prefs','readonly');
      const req = tx.objectStore('prefs').get(k);
      req.onsuccess = ()=> resolve(req.result ? req.result.v : null);
      req.onerror = ()=> reject(req.error);
    }));
  }
  function idbDeletePref(k){
    return openShotsDB().then(db=> new Promise((resolve,reject)=>{
      const tx = db.transaction('prefs','readwrite');
      tx.objectStore('prefs').delete(k);
      tx.oncomplete = ()=> resolve(true);
      tx.onerror = ()=> reject(tx.error);
    }));
  }
  function idbGetAllShotsForDataset(){
    return openShotsDB().then(db=> new Promise((resolve,reject)=>{
      const out = new Map();
      const tx = db.transaction('shots','readonly');
      const idx = tx.objectStore('shots').index('by_dataset');
      const req = idx.getAll(getDatasetKey());
      req.onsuccess = ()=>{ (req.result||[]).forEach(r=>{ out.set(r.date, r.dataUrl); }); resolve(out); };
      req.onerror = ()=> reject(req.error);
    }));
  }
  function idbClearDatasetShots(){
    return openShotsDB().then(db=> new Promise((resolve,reject)=>{
      const tx = db.transaction('shots','readwrite');
      const idx = tx.objectStore('shots').index('by_dataset');
      const req = idx.getAll(getDatasetKey());
      req.onsuccess = ()=>{
        const store = tx.objectStore('shots');
        (req.result||[]).forEach(rec=> store.delete(rec.key));
      };
      tx.oncomplete = ()=> resolve(true);
      tx.onerror = ()=> reject(tx.error);
    }));
  }
  function attachShotsFromDB(){
    return idbGetAllShotsForDataset().then(map=>{
      for(const d of Object.keys(dailyData)){
        if(map.has(d)){
          // Respect explicit cleared flag
          if(dailyData[d]?.screenshotCleared) continue;
          if(!dailyData[d]) dailyData[d] = {note:'', _events:[]};
          dailyData[d].screenshot = map.get(d);
        }
      }
    }).catch(()=>{});
  }
  function persistShotsForCurrentData(){
    const promises = [];
    for(const d of Object.keys(dailyData)){
      const shot = dailyData[d]?.screenshot; if(shot) promises.push(idbPutShot(d, shot));
    }
    return Promise.allSettled(promises);
  }

  // ====== Safe day access ======
  function getDay(date){ return dailyData[date] || null; }
  function touchDay(date){
    if(!dailyData[date]) dailyData[date] = { note:'', _events:[] };
    if(!('_events' in dailyData[date])) dailyData[date]._events = [];
    if(dailyData[date].note===undefined) dailyData[date].note='';
    return dailyData[date];
  }

  // ====== Tag helpers (FIXED) ======
  function ensureTag(name){
    const t = (name||'').trim(); if(!t) return null;
    if(!tagCatalog.includes(t)) tagCatalog.push(t);
    return t;
  }

  function getAllTagsFromData(){
    const set = new Set();
    // Add from catalog first
    tagCatalog.forEach(t => set.add(t));
    // Then scan all events
    for(const d of Object.keys(dailyData)){
      const day = dailyData[d];
      if(day._events && Array.isArray(day._events)){
        day._events.forEach(ev => {
          if(ev.tags && Array.isArray(ev.tags)){
            ev.tags.forEach(t => set.add(t));
          }
        });
      }
    }
    return Array.from(set).sort((a,b) => a.localeCompare(b));
  }

  function syncTagCatalog(){
    tagCatalog = getAllTagsFromData();
  }

  function addTagsToEvent(ev, tags){
    if(!ev.tags) ev.tags=[];
    tags.forEach(tag=>{
      const t = ensureTag(tag);
      if(t && !ev.tags.includes(t)) ev.tags.push(t);
    });
  }

  function removeTagsFromEvent(ev, tags){
    if(!ev.tags) return;
    ev.tags = ev.tags.filter(x=> !tags.includes(x));
  }

  function getEventScenario(ev){
    const s = ev?.scenario;
    return SCENARIOS.includes(s) ? s : 'S1';
  }

  function eventsForScenario(day, scenario = null){
    const events = day && Array.isArray(day._events) ? day._events : [];
    if(!scenario) return events;
    return events.filter(ev => getEventScenario(ev) === scenario);
  }

  function currentScenarioKey(){
    return SCENARIOS.includes(activeScenario) ? activeScenario : 'S1';
  }

  function syncScenarioSelects(){
    const key = currentScenarioKey();
    ['calScenarioSel','atScenarioSel','repScenarioSel'].forEach(id=>{
      const el = document.getElementById(id);
      if(el && el.value !== key){ el.value = key; }
    });
  }

  function renderScenarioButtons(){
    const seg = document.getElementById('scenarioSeg');
    if(seg){
      seg.innerHTML = '';
      const key = currentScenarioKey();
      SCENARIOS.forEach((name)=>{
        const b = document.createElement('button');
        b.setAttribute('data-scenario', name);
        b.textContent = name;
        const isActive = key===name;
        if(isActive) b.classList.add('active');
        b.setAttribute('aria-pressed', isActive ? 'true':'false');
        b.onclick = ()=> changeScenario(name);
        seg.appendChild(b);
      });
    }
    const hint = document.getElementById('scenarioHint');
    if(hint){
      hint.textContent = currentScenarioKey()==='S1' ? 'Default to S1 for new days' : 'Recording trades for S2';
    }
  }

  function syncScenarioControls(){
    renderScenarioButtons();
    syncScenarioSelects();
  }

  function changeScenario(next, opts={}){
    const target = SCENARIOS.includes(next) ? next : 'S1';
    const changed = activeScenario !== target;
    activeScenario = target;
    scenarioSelectionByDate[currentDate] = target;
    if(!opts.skipSync) syncScenarioControls();
    if(changed && !opts.skipRefresh){
      updateBacktestView();
      updateCalendarView();
      renderAllTrades();
      updateReportView();
      recalculateCompareStats();
    }
    if(!opts.skipSave) saveLocal();
  }

  function copyScenarioFromS1(){
    if(currentScenarioKey()!=='S2'){
      showToast('Switch to S2 to copy trades');
      return;
    }
    const day = getDay(currentDate);
    const source = eventsForScenario(day, 'S1');
    if(!source || source.length===0){
      showToast('No S1 trades to copy');
      return;
    }
    const snapshot = deepCloneData(dailyData);
    pushUndo(()=>{
      dailyData = snapshot;
      syncTagCatalog();
      updateBacktestView();
      updateCalendarView();
      renderAllTrades();
      updateReportView();
      recalculateCompareStats();
      saveLocal();
    });
    const targetDay = touchDay(currentDate);
    targetDay._events = (targetDay._events||[]).filter(ev => getEventScenario(ev) !== 'S2');
    source.forEach(ev=>{
      const clone = {...ev};
      clone.id = newEventId(currentDate);
      clone.scenario = 'S2';
      clone.tags = Array.isArray(ev.tags) ? ev.tags.slice() : [];
      if(ev.note!==undefined) clone.note = ev.note;
      if(ev.trailR!==undefined) clone.trailR = ev.trailR;
      targetDay._events.push(clone);
    });
    deriveAggregatesForDay(targetDay);
    syncTagCatalog();
    updateBacktestView();
    updateCalendarView();
    renderAllTrades();
    updateReportView();
    recalculateCompareStats();
    saveLocal();
    showToast(`Copied ${source.length} trade${source.length===1?'':'s'} to S2`);
  }

  // ====== Derived aggregates ======
  function deriveAggregatesForDay(day){
    // wipe known per-setup keys first
    for(const k of Object.keys(day)){
      if(['note','_events','screenshot'].includes(k)) continue;
      if(SETUPS.includes(k)) delete day[k];
    }
    const acc = {};
    for(const ev of eventsForScenario(day)){
      if(!acc[ev.setup]) acc[ev.setup] = {wins:0, losses:0, r:0};
      const rWin = Number(ev.rewardR ?? 2);
      const rLose = Number(ev.riskR ?? 1);
      if(ev.outcome==='W') { acc[ev.setup].wins++; acc[ev.setup].r += (isFinite(rWin)? rWin : 2); }
      else if(ev.outcome==='L') { acc[ev.setup].losses++; acc[ev.setup].r -= (isFinite(rLose)? rLose : 1); }
      else { /* Breakeven */ }
    }
    for(const s of Object.keys(acc)) day[s]=acc[s];
  }

  function computeDayType(day, scenario = null){
    let r=0;
    const events = eventsForScenario(day, scenario);
    for(const ev of events){
      r += eventR(ev);
    }
    return r>0? 'Winning' : r<0? 'Losing' : 'Breakeven';
  }

  // Event R helper with optional trail override
  function eventR(ev){
    const rw = Number(ev.rewardR ?? 2);
    const rl = Number(ev.riskR ?? 1);
    if(trailProfit){
      const tr = Number(ev.trailR);
      if(Number.isFinite(tr)) return tr;
    }
    if(ev.outcome==='W'){
      return (Number.isFinite(rw)? rw : 2);
    }
    if(ev.outcome==='L') return -(Number.isFinite(rl)? rl : 1);
    return 0; // Breakeven
  }

  function effectiveOutcome(ev){
    if(trailProfit){
      const val = eventR(ev);
      if(val>0) return 'W';
      if(val<0) return 'L';
      return 'B';
    }
    return ev.outcome;
  }

  // ====== Enhanced Migration ======
  function migrateIfNeeded(){
    let changed=false;

    // First pass: ensure _events exists and migrate old counts
    for(const d of Object.keys(dailyData)){
      const day = dailyData[d];
      if(!day._events) { day._events=[]; changed=true; }
      
      // Migrate old per-setup counts if _events is empty
      if(day._events.length===0){
        for(const [k,v] of Object.entries(day)){
          if(['note','_events','screenshot'].includes(k)) continue;
          if(SETUPS.includes(k) && (v.wins||v.losses)){
            const w = Number(v.wins||0), l = Number(v.losses||0);
            for(let i=0;i<w;i++) {
              day._events.push({
                id:`${d}-${k}-W-${i+1}`,
                setup:k,
                outcome:'W',
                tags:[],  // Initialize with empty tags
                rewardR: 2,
                riskR: 1
              });
            }
            for(let i=0;i<l;i++) {
              day._events.push({
                id:`${d}-${k}-L-${i+1}`,
                setup:k,
                outcome:'L',
                tags:[],  // Initialize with empty tags
                rewardR: 2,
                riskR: 1
              });
            }
            changed=true;
          }
        }
      }
      
      // Ensure all events have tags array
      for(const ev of day._events){
        if(!ev.tags) { ev.tags = []; changed = true; }
        if(!ev.id) { ev.id = `${d}-${Math.random().toString(36).slice(2,8)}`; changed = true; }
        // Ensure RR fields exist on events
        if(ev.rewardR===undefined) { ev.rewardR = 2; changed = true; }
        if(ev.riskR===undefined) { ev.riskR = 1; changed = true; }
        if(!SCENARIOS.includes(ev.scenario)) { ev.scenario = 'S1'; changed = true; }
      }
      
      deriveAggregatesForDay(day);
      if(day.note===undefined) day.note='';
    }
    
    // Sync tag catalog with actual data
    syncTagCatalog();
    
    ensureJournalStructure();
    seedJournalFromDailyData();
    if(!Number.isFinite(journalFontSize) || journalFontSize<12) journalFontSize = 16;
    if(!Number.isFinite(dayJournalFontSize) || dayJournalFontSize<12) dayJournalFontSize = 16;
    collectAllJournalTags();
    return changed;
  }

  // ====== Storage ======
  function stripForLocal(){
    const data = {};
    for(const d of Object.keys(dailyData)){
      const day = dailyData[d];
      if(!day) continue;
      const hasStuff = (day.note && day.note.trim()!=='') || (day._events && day._events.length>0) || day.screenshot || day.screenshotCleared;
      if(!hasStuff) continue;
      data[d] = { note: day.note||'', _events: day._events?.map(ev=> ({...ev})) || [] };
      if(day.screenshotCleared) data[d].screenshotCleared = true;
      for(const s of SETUPS){
        if(day[s]) data[d][s] = {wins: day[s].wins||0, losses: day[s].losses||0};
      }
    }
    return data;
  }

  function saveLocal(){
    try{
      const payload = {
        version: '6.1',
        currentDate, currentSetup, activeScenario, unitMode, rValue, flatStart, compStart, compRiskPct, compStepStart, compStepRiskPct, compStepStepPct, compDailyStart, compDailyRiskPct,
        rrReward, rrRisk,
        reportStartDate, reportEndDate,
        repSetup, repResult, repTags, repTagsAll, repExTags, repExTagsAll, repTradesLimit, repNthTrade,
        atStartDate, atEndDate, atSetup, atResult, atDayType, atTags, atTagsAll, atExTags, atExTagsAll, atTradesLimit, atNthTrade,
        calMonth, calSetup, calResult, calTags, calTagsAll, calExTags, calExTagsAll, calTradesLimit, calNthTrade,
        reportLayout,
        weekdayViewMode, calMonthViewMode, quarterViewMode,
        setups: SETUPS.slice(),
        periodNetMode,
        rollingWinWindow,
        rollingWinThresh,
        trailProfit,
        calLayout: getCurrentCalLayout(),
        tagCatalog: getAllTagsFromData(),  // Always save current tags
        dailyData: stripForLocal(),
        currentFileName,
        journalData,
        journalMode,
        journalFilterTags,
        journalSearchText,
        selectedCustomJournalId,
        journalFontSize,
        dayJournalFontSize,
        scenarioSelectionByDate,
        scaling: serializeScalingState(),
        // Analytics / extras
        anaRuinThresh
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    }catch(e){ console.warn('Local save failed:', e); }
    $('#fileBadge').textContent = currentFileName ? `File: ${currentFileName}` : 'Unsaved';
  }

  function loadLocal(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const data = JSON.parse(raw);
      currentDate = data.currentDate || currentDate;
      currentSetup = data.currentSetup || currentSetup;
      activeScenario = SCENARIOS.includes(data.activeScenario) ? data.activeScenario : 'S1';
      scenarioSelectionByDate = (data.scenarioSelectionByDate && typeof data.scenarioSelectionByDate === 'object') ? {...data.scenarioSelectionByDate} : {};
      for(const key of Object.keys(scenarioSelectionByDate)){
        if(!SCENARIOS.includes(scenarioSelectionByDate[key])) delete scenarioSelectionByDate[key];
      }
      scalingState = deserializeScalingState(data.scaling);
      unitMode = data.unitMode || 'R';
      rValue = data.rValue ?? 1;
      flatStart = data.flatStart ?? 0;
      compStart = data.compStart ?? 100000;
      compRiskPct = data.compRiskPct ?? 0.3;
      compStepStart = data.compStepStart ?? 100000;
      compStepRiskPct = data.compStepRiskPct ?? 0.3;
      compStepStepPct = data.compStepStepPct ?? 10;
      compDailyStart = data.compDailyStart ?? 100000;
      compDailyRiskPct = data.compDailyRiskPct ?? 0.3;
      trailProfit = !!data.trailProfit;
      rrReward = data.rrReward ?? 2;
      rrRisk = data.rrRisk ?? 1;
      reportStartDate = data.reportStartDate || null;
      reportEndDate = data.reportEndDate || null;

      repSetup = data.repSetup || ''; repResult = data.repResult || '';
      repTags = data.repTags || []; repTagsAll = !!data.repTagsAll;
      repExTags = Array.isArray(data.repExTags) ? data.repExTags : [];
      repExTagsAll = !!data.repExTagsAll;
      repTradesLimit = (Number.isFinite(parseInt(data.repTradesLimit)) ? parseInt(data.repTradesLimit) : null);
      repNthTrade = (Number.isFinite(parseInt(data.repNthTrade)) ? parseInt(data.repNthTrade) : null);

      atStartDate = data.atStartDate || null; atEndDate = data.atEndDate || null;
      atSetup = data.atSetup || ''; atResult = data.atResult || '';
      atDayType = data.atDayType || ''; atTags = data.atTags || []; atTagsAll = !!data.atTagsAll;
      atExTags = Array.isArray(data.atExTags) ? data.atExTags : [];
      atExTagsAll = !!data.atExTagsAll;
      atTradesLimit = (Number.isFinite(parseInt(data.atTradesLimit)) ? parseInt(data.atTradesLimit) : null);
      atNthTrade = (Number.isFinite(parseInt(data.atNthTrade)) ? parseInt(data.atNthTrade) : null);

      tagCatalog = Array.isArray(data.tagCatalog) ? data.tagCatalog : [];
      dailyData = data.dailyData || {};
      currentFileName = data.currentFileName || null;
      journalData = data.journalData || journalData;
      journalMode = (data.journalMode==='daily' || data.journalMode==='weekly' || data.journalMode==='custom') ? data.journalMode : 'daily';
      journalFilterTags = Array.isArray(data.journalFilterTags) ? data.journalFilterTags.map(normalizeTag).filter(Boolean) : [];
      journalSearchText = typeof data.journalSearchText === 'string' ? data.journalSearchText : '';
      selectedCustomJournalId = data.selectedCustomJournalId || null;
      journalFontSize = Number.isFinite(parseInt(data.journalFontSize,10)) ? parseInt(data.journalFontSize,10) : 16;
      dayJournalFontSize = Number.isFinite(parseInt(data.dayJournalFontSize,10)) ? parseInt(data.dayJournalFontSize,10) : 16;
      reportLayout = Array.isArray(data.reportLayout) ? data.reportLayout : [];
      // Analytics extra
      anaRuinThresh = Number.isFinite(parseFloat(data.anaRuinThresh)) ? parseFloat(data.anaRuinThresh) : 10;
      // View modes for tables/charts
      weekdayViewMode = (data.weekdayViewMode==='chart' || data.weekdayViewMode==='table') ? data.weekdayViewMode : 'table';
      calMonthViewMode = (data.calMonthViewMode==='chart' || data.calMonthViewMode==='table') ? data.calMonthViewMode : 'table';
      quarterViewMode = (data.quarterViewMode==='chart' || data.quarterViewMode==='table') ? data.quarterViewMode : 'table';
      // Calendar
      calMonth = data.calMonth || calMonth;
      calSetup = data.calSetup || '';
      calResult = data.calResult || '';
      calTags = Array.isArray(data.calTags) ? data.calTags : [];
      calTagsAll = !!data.calTagsAll;
      calExTags = Array.isArray(data.calExTags) ? data.calExTags : [];
      calExTagsAll = !!data.calExTagsAll;
      calTradesLimit = (Number.isFinite(parseInt(data.calTradesLimit)) ? parseInt(data.calTradesLimit) : null);
      calNthTrade = (Number.isFinite(parseInt(data.calNthTrade)) ? parseInt(data.calNthTrade) : null);
      // Load setups (fallback to defaults)
      if(Array.isArray(data.setups) && data.setups.length>0){
        SETUPS = data.setups.slice(0,6).map(s=> String(s).trim()).filter(Boolean);
      }
      periodNetMode = (data.periodNetMode==='monthly' || data.periodNetMode==='weekly' || data.periodNetMode==='quarterly') ? data.periodNetMode : 'weekly';
      rollingWinWindow = (data.rollingWinWindow===5 || data.rollingWinWindow===10 || data.rollingWinWindow===20) ? data.rollingWinWindow : 20;
      rollingWinThresh = Number.isFinite(parseFloat(data.rollingWinThresh)) ? parseFloat(data.rollingWinThresh) : 20;
      calLayout = Array.isArray(data.calLayout) ? data.calLayout : [];
      // Ensure currentSetup is valid
      if(!SETUPS.includes(currentSetup)) currentSetup = SETUPS[0] || 'Breakout';

      migrateIfNeeded();
      recomputeScalingState();
    }catch(e){ console.warn('Autosave load failed', e); }
  }

  // ====== Filters ======
  function weekKey(dateStr){
    const date = new Date(dateStr);
    const day = (date.getUTCDay()||7);
    date.setUTCDate(date.getUTCDate() + 4 - day);
    const yearStart = new Date(Date.UTC(date.getUTCFullYear(),0,1));
    return Math.ceil((((date - yearStart)/86400000)+1)/7);
  }

  function groupSeries(series, gran, valueKey='value'){
    if(gran==='daily'){
      return {labels: series.map(d=>dispDate(d.date)), values: series.map(d=>d[valueKey])};
    }
    const map={};
    series.forEach(pt=>{
      const key = gran==='weekly' ? `${new Date(pt.date).getFullYear()}-W${String(weekKey(pt.date)).padStart(2,'0')}` : pt.date.slice(0,7);
      map[key] = pt[valueKey];
    });
    const labels = Object.keys(map).map(k=> k.includes('-W') ? k : k.replace('-','/'));
    return {labels, values:Object.values(map)};
  }

  // ====== Calendar View ======
  function getMonthRange(ym){
    // ym: 'YYYY-MM'
    const [y,m] = ym.split('-').map(n=>parseInt(n,10));
    const start = new Date(Date.UTC(y, m-1, 1));
    const end = new Date(Date.UTC(y, m, 0)); // last day prev month index m
    const s = start.toISOString().slice(0,10);
    const e = end.toISOString().slice(0,10);
    return {start:s, end:e};
  }

  function getCalFilters(){
    const {start, end} = getMonthRange(calMonth);
    return {
      start, end,
      setup: calSetup || '', result: calResult || '',
      tags: Array.isArray(calTags) ? calTags.slice() : [], tagsAll: (document.querySelector('input[name="calTagMode"]:checked')?.value === 'all'),
      excludeTags: Array.isArray(calExTags) ? calExTags.slice() : [], excludeTagsAll: (document.querySelector('input[name="calExTagMode"]:checked')?.value === 'all'),
      limitPerDay: calTradesLimit || null,
      nthTradePerDay: (Number.isFinite(parseInt(calNthTrade)) && parseInt(calNthTrade)>0) ? parseInt(calNthTrade) : null,
      dayType: '',
      scenario: currentScenarioKey()
    };
  }

  function updateCalendarView(){
    // Sync unit toggle classes
    const uR = document.getElementById('calUnitR');
    const uF = document.getElementById('calUnitDollarFlat');
    const uC = document.getElementById('calUnitDollarComp');
    const uCS = document.getElementById('calUnitDollarCompSteps');
    const uCD = document.getElementById('calUnitDollarCompDaily');
    if(uR) uR.classList.toggle('active', unitMode==='R');
    if(uF) uF.classList.toggle('active', unitMode==='flat');
    if(uC) uC.classList.toggle('active', unitMode==='comp');
    if(uCS) uCS.classList.toggle('active', unitMode==='compSteps');
    if(uCD) uCD.classList.toggle('active', unitMode==='compDaily');
    // Sync inputs
    const monInp = document.getElementById('calMonth'); if(monInp) monInp.value = calMonth;
    const nSel = document.getElementById('calTradesPerDay'); if(nSel) nSel.value = calTradesLimit && calTradesLimit>0 ? String(calTradesLimit) : '';
    const nthSel = document.getElementById('calNthTrade'); if(nthSel) nthSel.value = calNthTrade && calNthTrade>0 ? String(calNthTrade) : '';
    const sSel = document.getElementById('calSetupSel'); if(sSel) sSel.value = calSetup || '';
    const rSel = document.getElementById('calResultSel'); if(rSel) rSel.value = calResult || '';
    const scSel = document.getElementById('calScenarioSel'); if(scSel && scSel.value !== currentScenarioKey()) scSel.value = currentScenarioKey();
    const calTrail = document.getElementById('calTrailToggle'); if(calTrail) calTrail.checked = !!trailProfit;

    // Build filtered data for the month
    const f = getCalFilters();
    const data = filteredClone(dailyData, f);
    const dates = Object.keys(data).sort();

    // Precompute per-day net in selected units
    const netByDay = {};
    if(unitMode==='comp'){
      // Use daily USD delta from compounding aggregation
      const startUSD = compStart>0 ? compStart : 100000;
      const comp = aggregateCompounding(data, startUSD, compRiskPct>0? compRiskPct : 0.3);
      (comp.series||[]).forEach(d=>{ netByDay[d.date] = d.delta || 0; });
    } else if(unitMode==='compDaily'){
      const startUSD = compDailyStart>0 ? compDailyStart : 100000;
      const risk = compDailyRiskPct>0 ? compDailyRiskPct : 0.3;
      const comp = aggregateCompoundingDaily(data, startUSD, risk);
      (comp.series||[]).forEach(d=>{ netByDay[d.date] = d.delta || 0; });
    } else if(unitMode==='compSteps'){
      const startUSD = compStepStart>0 ? compStepStart : 100000;
      const risk = compStepRiskPct>0 ? compStepRiskPct : 0.3;
      const step = compStepStepPct>=0 ? compStepStepPct : 0;
      const comp = aggregateCompoundingSteps(data, startUSD, risk, step);
      (comp.series||[]).forEach(d=>{ netByDay[d.date] = d.delta || 0; });
    } else {
      // Sum per-trade R and convert if flat
      dates.forEach(d=>{
        let r=0; (data[d]._events||[]).forEach(ev=>{ r += eventR(ev); });
        netByDay[d] = unitMode==='flat' ? r*rValue : r;
      });
    }

    // Build grid
    const grid = document.getElementById('calGrid'); if(!grid) return;
    grid.innerHTML = '';
    // Header (Mon–Fri + Week)
    const heads = ['Mon','Tue','Wed','Thu','Fri','Week'];
    heads.forEach(h=>{ const el=document.createElement('div'); el.className='cal-head'; el.textContent=h; grid.appendChild(el); });

    const {start, end} = getMonthRange(calMonth);
    const startDate = new Date(start), endDate = new Date(end);
    // Monday on/before first of month
    const startDow = startDate.getUTCDay()===0? 7 : startDate.getUTCDay();
    const monday = new Date(startDate); monday.setUTCDate(startDate.getUTCDate() - (startDow-1));

    const weeklyAgg = [];
    for(let rowStart = new Date(monday); rowStart <= endDate; rowStart.setUTCDate(rowStart.getUTCDate()+7)){
      let curWeek={trades:0, net:0, wins:0, losses:0, days:0};
      for(let i=0;i<5;i++){
        const d = new Date(rowStart); d.setUTCDate(rowStart.getUTCDate()+i);
        const dstr = d.toISOString().slice(0,10);
        const inMonth = d >= startDate && d <= endDate;
        const cell = document.createElement('div'); cell.className='cal-cell';
        const header = document.createElement('div'); header.className='date'; header.textContent = String(d.getUTCDate()); cell.appendChild(header);
        if(inMonth && data[dstr]){
          const day = data[dstr];
          const dt = computeDayType(day);
          const typeEl = document.createElement('div'); typeEl.className = 'daytype '+(dt==='Winning'?'win':dt==='Losing'?'lose':'');
          typeEl.textContent = dt==='Winning' ? 'WIN' : dt==='Losing' ? 'LOSE' : 'BE';
          cell.appendChild(typeEl);
          const net = netByDay[dstr] || 0;
          const netEl = document.createElement('div');
          netEl.style.color = net>0? 'var(--green)' : net<0? 'var(--red)': 'var(--amber)';
          netEl.textContent = (unitMode==='flat' || unitMode==='comp' || unitMode==='compSteps' || unitMode==='compDaily') ? `$${fmt(net,2)}` : `${fmt(net,2)}R`;
          cell.appendChild(netEl);
          // If screenshot exists, make cell clickable to show it
          if(day.screenshot){
            cell.style.cursor = 'pointer';
            cell.title = 'Click to view screenshot';
            cell.addEventListener('click', ()=> openCalShot(dstr));
          }
          const events = (day._events||[]);
          const grouped = groupWinLoss(events);
          curWeek.trades += events.length;
          curWeek.net += net;
          curWeek.wins += grouped.wins;
          curWeek.losses += grouped.losses;
          curWeek.days++;
        }
        grid.appendChild(cell);
      }
      const wkCell = document.createElement('div');
      wkCell.className='cal-week-cell';
      const trades = curWeek.trades;
      const counted = curWeek.wins + curWeek.losses;
      const wr = counted ? (curWeek.wins/counted*100) : 0;
      const netDisp = (unitMode==='flat' || unitMode==='comp' || unitMode==='compSteps' || unitMode==='compDaily') ? `$${fmt(curWeek.net,2)}` : `${fmt(curWeek.net,2)}R`;
      const weekMood = curWeek.net>0 ? 'win' : curWeek.net<0 ? 'lose' : 'be';
      wkCell.classList.add(weekMood);
      wkCell.innerHTML = `
        <div class=\"cal-week-title\">Week</div>
        <span class=\"stat\">Trades: <b>${counted} (${trades})</b></span>
        <span class=\"stat\">Win%: <b>${fmt(wr,1)}%</b></span>
        <span class=\"stat\">Net: <b style=\"color:${curWeek.net>0?'var(--green)':curWeek.net<0?'var(--red)':'var(--amber)'}\">${netDisp}</b></span>`;
      const bar = document.createElement('div'); bar.className = 'cal-week-bar';
      const fill = document.createElement('div'); fill.className = 'fill';
      bar.appendChild(fill);
      wkCell.appendChild(bar);
      grid.appendChild(wkCell);
      weeklyAgg.push({...curWeek, element:wkCell, fill});
    }

    const maxWeekAbs = weeklyAgg.reduce((m,w)=> Math.max(m, Math.abs(w.net||0)), 0);
    weeklyAgg.forEach(w=>{
      if(!w.fill) return;
      const net = w.net || 0;
      const width = maxWeekAbs>0 ? Math.max(4, Math.abs(net)/maxWeekAbs*100) : 0;
      w.fill.style.width = width>0 ? `${Math.min(100,width)}%` : '0%';
      w.fill.style.backgroundColor = net>0 ? 'var(--green)' : net<0 ? 'var(--red)' : 'var(--amber)';
    });

    // Monthly summary
    const sumBox = document.getElementById('calMonthSummary');
    let trades = 0, wins = 0, losses = 0;
    dates.forEach(d=>{
      const grouped = groupWinLoss(data[d]._events||[]);
      trades += (data[d]._events||[]).length;
      wins += grouped.wins;
      losses += grouped.losses;
    });
    let netMonth = 0; dates.forEach(d=>{ netMonth += (netByDay[d]||0); });
    const counted = wins + losses;
    const wr = counted ? (wins/counted*100) : 0;
    const avgPerDay = dates.length? (trades/dates.length) : 0;
    // Expectancy per trade (R-based -> convert if needed)
    let rSum = 0; dates.forEach(d=>{ (data[d]._events||[]).forEach(ev=>{ rSum += eventR(ev); }); });
    const exp = trades? (rSum/trades) : 0;
    const expDisp = (unitMode==='flat' || unitMode==='comp' || unitMode==='compSteps' || unitMode==='compDaily') ? `$${fmt(exp*rValue,2)}` : `${fmt(exp,2)}R`;
    // Monthly max drawdown from daily series in selected unit
    let cum=0, peak=0, maxDD=0; dates.forEach(d=>{ cum += (netByDay[d]||0); peak=Math.max(peak,cum); maxDD=Math.max(maxDD, peak-cum); });
    const ddDisp = (unitMode==='flat' || unitMode==='comp' || unitMode==='compSteps' || unitMode==='compDaily') ? `$${fmt(maxDD,2)}` : `${fmt(maxDD,2)}R`;
    const netDisp = (unitMode==='flat' || unitMode==='comp' || unitMode==='compSteps' || unitMode==='compDaily') ? `$${fmt(netMonth,2)}` : `${fmt(netMonth,2)}R`;

    let longestWin = 0, longestLoss = 0, curWin = 0, curLoss = 0;
    dates.forEach(d=>{
      const net = netByDay[d] || 0;
      if(net>0){ curWin++; longestWin = Math.max(longestWin, curWin); curLoss = 0; }
      else if(net<0){ curLoss++; longestLoss = Math.max(longestLoss, curLoss); curWin = 0; }
      else { curWin = 0; curLoss = 0; }
    });

    sumBox.innerHTML = `
      <div class="grid cols-4">
        <div class="kpi"><div class="label">Total Trades (incl. BE)</div><div class="value">${counted} (${trades})</div></div>
        <div class="kpi"><div class="label">Win %</div><div class="value">${fmt(wr,1)}%</div></div>
        <div class="kpi"><div class="label">Avg Trades/Day</div><div class="value">${fmt(avgPerDay,2)}</div></div>
        <div class="kpi"><div class="label">Net</div><div class="value" style="color:${netMonth>0?'var(--green)':netMonth<0?'var(--red)':'var(--amber)'}">${netDisp}</div></div>
        <div class="kpi"><div class="label">Expectancy</div><div class="value">${expDisp}</div></div>
        <div class="kpi"><div class="label">Max Drawdown</div><div class="value" style="color:var(--red)">${ddDisp}</div></div>
      </div>
      <div class="cal-streaks"><span>Longest Win Streak: <strong>${longestWin}</strong></span><span>Longest Loss Streak: <strong>${longestLoss}</strong></span></div>`;

    // Setup Performance (month) — mirrors Report tab setup cards
    const calSetupContainer = document.getElementById('calSetupCards');
    if(calSetupContainer){
      calSetupContainer.innerHTML = '';
      const statsBySetup = {};
      dates.forEach(d=>{
        (data[d]._events||[]).forEach(ev=>{
          const k = ev.setup;
          if(!statsBySetup[k]) statsBySetup[k] = {wins:0, losses:0, net:0};
          const outcome = effectiveOutcome(ev);
          if(outcome==='W') statsBySetup[k].wins++; else if(outcome==='L') statsBySetup[k].losses++;
          statsBySetup[k].net += eventR(ev);
        });
      });
      const orderedSetups = Array.from(new Set([...(SETUPS||[]), ...Object.keys(statsBySetup)]));
      orderedSetups.forEach(s=>{
        const st = statsBySetup[s] || {wins:0, losses:0, net:0};
        const t = st.wins + st.losses; if(t===0) return;
        const r = st.net; // trail-aware via eventR
        const wrS = t ? (st.wins/t*100) : 0;
        const expS = t ? (r/t) : 0;
        const valueMain = (unitMode==='flat') ? `$${fmt(r*rValue,2)}` : `${fmt(r,2)}R`;
        const card = document.createElement('div');
        card.className = 'kpi';
        card.innerHTML = `
          <div class="label">${s}</div>
          <div class="value">${valueMain}</div>
          <div class="muted" style="margin-top:6px">Trades: <b>${t}</b> • Win%: <b>${fmt(wrS,1)}%</b> • Exp: <b>${unitMode==='flat'? `$${fmt(expS*rValue,2)}` : `${fmt(expS,2)}R`}</b></div>`;
        calSetupContainer.appendChild(card);
      });
      if(calSetupContainer.children.length===0){
        calSetupContainer.innerHTML = `<div class="muted">No setup data in the selected month.</div>`;
      }
    }
    // Calendar Rolling Win Rate chart (global rolling, month-visible)
    try{
      const W = Number.isFinite(parseInt(rollingWinWindow)) ? parseInt(rollingWinWindow) : 20;
      // Use all data (remove date bounds) but keep other filters
      const fAll = {...getCalFilters(), start:null, end:null};
      const dataAll = filteredClone(dailyData, fAll);
      const outcomesAll = getTradeOutcomes(dataAll) || [];
      const rowsAll = flattenTrades(dataAll, true);
      const datesAll = rowsAll.map(r=> r.date);
      const wrAll = [];
      for(let i=0;i<outcomesAll.length;i++){
        const a = Math.max(0, i-W+1);
        const winCount = outcomesAll.slice(a, i+1).filter(v=> v>0).length;
        const denom = (i - a + 1) || 1;
        wrAll.push(+(winCount/denom*100).toFixed(2));
      }
      // Show only points inside current month
      const visIdx = [];
      for(let i=0;i<datesAll.length;i++){ const d=datesAll[i]; if(d>=start && d<=end) visIdx.push(i); }
      const wr = visIdx.map(i=> wrAll[i]);
      const tradeDates = visIdx.map(i=> datesAll[i]);
      const labelsWR = tradeDates.map(d=> dispDate(d));
      const ctx = document.getElementById('calRollingWRChart')?.getContext('2d');
      if(ctx){
        if(calRollingWRChart){ calRollingWRChart.destroy(); }
        const thr = Number.isFinite(parseFloat(rollingWinThresh)) ? parseFloat(rollingWinThresh) : 20;
        const thrArr = wr.map(()=> thr);
        const redData = wr.map(v=> v<=thr ? v : null);
        calRollingWRChart = new Chart(ctx, {
          type:'line',
          data:{ labels: labelsWR, datasets:[
            { label:'Win %', data: wr, borderColor:'#27be69', backgroundColor:'#27be6922', fill:true, tension:.15, borderWidth:2, pointRadius:0, order:0 },
            { label:'≤ Threshold', data: redData, borderColor:'#ff5a6b', backgroundColor:'#ff5a6b55', fill:true, tension:.15, borderWidth:2, pointRadius:3, hitRadius:6, spanGaps:false, order:2 },
            { label:'Threshold', data: thrArr, borderColor:'#ff5a6b', borderDash:[6,6], pointRadius:0, fill:false, order:1 }
          ] },
          options:{ responsive:true, maintainAspectRatio:false, plugins:{ legend:{display:false}, tooltip:{ callbacks:{ title:(items)=>{ const idx=items&&items.length?items[0].dataIndex:null; const d=tradeDates[idx]||null; return d?`Date: ${dispDate(d)}`:''; }, label:(ctx)=>`Win %: ${ctx.parsed.y}%` } } }, scales:{ x:{grid:{color:'#2b315d'}}, y:{min:0, max:100, ticks:{callback:(v)=> `${v}%`}, grid:{color:'#2b315d'}} } }
        });
      }
      // Sync calendar rolling window toggle active state
      $$('#calRollWinSeg button').forEach(x=> x.classList.toggle('active', parseInt(x.getAttribute('data-n'),10)===rollingWinWindow));
    }catch(e){ /* noop */ }
    refreshScalingTradeCountIfNeeded();
  }

  // ====== Report layout (drag & save) ======
  function getCurrentReportLayout(){
    const container = document.getElementById('reportSections');
    if(!container) return [];
    return Array.from(container.querySelectorAll('.report-section')).map(n=> n.getAttribute('data-section')||'');
  }
  
  function applyReportLayout(){
    const container = document.getElementById('reportSections');
    if(!container) return;
    const nodes = Array.from(container.querySelectorAll('.report-section'));
    const map = new Map(nodes.map(n=> [n.getAttribute('data-section')||'', n]));
    const order = (Array.isArray(reportLayout) && reportLayout.length>0) ? reportLayout.slice() : getCurrentReportLayout();
    // Append in saved order
    order.forEach(id=>{ const node = map.get(id); if(node && node.parentElement===container) container.appendChild(node); });
    // Append any missing leftover nodes
    nodes.forEach(n=>{ if(!order.includes(n.getAttribute('data-section')||'')) container.appendChild(n); });
  }

  function injectReportHandles(){
    const secs = document.querySelectorAll('#reportSections .report-section');
    secs.forEach(sec=>{
      sec.classList.add('report-section');
      sec.style.position = sec.style.position || 'relative';
      if(!sec.querySelector(':scope > .drag-handle')){
        const h = document.createElement('div');
        h.className = 'drag-handle';
        h.textContent = '⇅';
        h.title = 'Drag to reorder';
        h.addEventListener('mousedown', ()=>{ sec.setAttribute('draggable','true'); });
        h.addEventListener('mouseup', ()=>{ sec.removeAttribute('draggable'); });
        sec.prepend(h);
      }
    });
  }

  function wireReportDrag(){
    const container = document.getElementById('reportSections');
    if(!container) return;
    injectReportHandles();
    container.querySelectorAll('.report-section').forEach(sec=>{
      sec.addEventListener('dragstart', (e)=>{
        if(e.target!==sec && !sec.contains(e.target)) return;
        sec.classList.add('dragging');
        if(e.dataTransfer){ e.dataTransfer.effectAllowed='move'; }
      });
      sec.addEventListener('dragend', ()=>{
        sec.classList.remove('dragging');
        sec.removeAttribute('draggable');
      });
    });
    container.addEventListener('dragover', (e)=>{
      e.preventDefault();
      const after = getDragAfterElement(container, e.clientY);
      const dragging = container.querySelector('.dragging');
      if(!dragging) return;
      if(after==null){ container.appendChild(dragging); }
      else { container.insertBefore(dragging, after); }
    });
    container.addEventListener('drop', (e)=>{
      e.preventDefault();
      reportLayout = getCurrentReportLayout();
      saveLocal();
    });
  }

  function getDragAfterElement(container, y){
    const els = [...container.querySelectorAll('.report-section:not(.dragging)')];
    let closest = {offset: Number.NEGATIVE_INFINITY, element: null};
    for(const child of els){
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height/2;
      if(offset < 0 && offset > closest.offset){
        closest = {offset, element: child};
      }
    }
    return closest.element;
  }

  // ===== Calendar layout drag =====
  function getCurrentCalLayout(){
    const container = document.getElementById('calSections');
    if(!container) return [];
    return Array.from(container.querySelectorAll('.report-section')).map(n=> n.getAttribute('data-section')||'');
  }
  function applyCalLayout(){
    const container = document.getElementById('calSections');
    if(!container) return;
    const nodes = Array.from(container.querySelectorAll('.report-section'));
    const map = new Map(nodes.map(n=> [n.getAttribute('data-section')||'', n]));
    const order = (Array.isArray(calLayout) && calLayout.length>0) ? calLayout.slice() : getCurrentCalLayout();
    order.forEach(id=>{ const node = map.get(id); if(node && node.parentElement===container) container.appendChild(node); });
    nodes.forEach(n=>{ if(!order.includes(n.getAttribute('data-section')||'')) container.appendChild(n); });
  }
  function injectCalHandles(){
    const secs = document.querySelectorAll('#calSections .report-section');
    secs.forEach(sec=>{
      sec.classList.add('report-section');
      sec.style.position = sec.style.position || 'relative';
      if(!sec.querySelector(':scope > .drag-handle')){
        const h = document.createElement('div');
        h.className = 'drag-handle';
        h.textContent = '⇅';
        h.title = 'Drag to reorder';
        h.addEventListener('mousedown', ()=>{ sec.setAttribute('draggable','true'); });
        h.addEventListener('mouseup', ()=>{ sec.removeAttribute('draggable'); });
        sec.prepend(h);
      }
    });
  }
  function wireCalDrag(){
    const container = document.getElementById('calSections');
    if(!container) return;
    injectCalHandles();
    container.querySelectorAll('.report-section').forEach(sec=>{
      sec.addEventListener('dragstart', (e)=>{
        if(e.target!==sec && !sec.contains(e.target)) return;
        sec.classList.add('dragging');
        if(e.dataTransfer){ e.dataTransfer.effectAllowed='move'; }
      });
      sec.addEventListener('dragend', ()=>{
        sec.classList.remove('dragging');
        sec.removeAttribute('draggable');
      });
    });
    container.addEventListener('dragover', (e)=>{
      e.preventDefault();
      const after = getDragAfterElement(container, e.clientY);
      const dragging = container.querySelector('.dragging');
      if(!dragging) return;
      if(after==null){ container.appendChild(dragging); }
      else { container.insertBefore(dragging, after); }
    });
    container.addEventListener('drop', (e)=>{
      e.preventDefault();
      calLayout = getCurrentCalLayout();
      saveLocal();
    });
  }

  function dayMatchesType(date, scenario = null){
    const day = dailyData[date];
    if(!day) return 'Breakeven';
    return computeDayType(day, scenario);
  }

  function eventMatches(ev, f){
    if(f?.scenario && getEventScenario(ev) !== f.scenario) return false;
    if(f?.setup && ev.setup!==f.setup) return false;
    if(f?.result){
      const outcome = effectiveOutcome(ev) || '';
      if(outcome !== f.result) return false;
    }
    if(f?.tags && f.tags.length>0){
      const evTags = ev.tags||[];
      if(f.tagsAll){
        for(const t of f.tags){ if(!evTags.includes(t)) return false; }
      }else{
        let ok=false; for(const t of f.tags){ if(evTags.includes(t)) { ok=true; break; } }
        if(!ok) return false;
      }
    }
    // Exclude tags logic: if event matches these, filter it out
    if(f?.excludeTags && f.excludeTags.length>0){
      const evTags = ev.tags || [];
      if(f.excludeTagsAll){
        // Exclude if event has ALL of the excluded tags
        let hasAll = true;
        for(const t of f.excludeTags){ if(!evTags.includes(t)) { hasAll = false; break; } }
        if(hasAll) return false;
      } else {
        // Exclude if event has ANY of the excluded tags
        for(const t of f.excludeTags){ if(evTags.includes(t)) return false; }
      }
    }
    return true;
  }

  function filteredClone(source, f){
    const out = {};
    const dates = Object.keys(source).sort();
    for(const d of dates){
      if(f.start && d < f.start) continue;
      if(f.end && d > f.end) continue;

      const scenario = (f && SCENARIOS.includes(f.scenario)) ? f.scenario : null;

      if(f.dayType){
        const dt = dayMatchesType(d, scenario);
        if(dt !== f.dayType) continue;
      }

      const day = source[d];
      const keep = [];
      const limit = (f && Number.isFinite(parseInt(f.limitPerDay)) && parseInt(f.limitPerDay) > 0) ? parseInt(f.limitPerDay) : null;
      let pool = (day._events||[]);
      if(scenario) pool = pool.filter(ev=> getEventScenario(ev) === scenario);
      // Keep only the Nth trade per day if requested (1-based)
      if(f && Number.isFinite(parseInt(f.nthTradePerDay))){
        const nth = parseInt(f.nthTradePerDay);
        if(nth>0){
          if(pool.length >= nth) pool = [ pool[nth-1] ]; else pool = [];
        }
      }
      if(limit) pool = pool.slice(0, limit);
      for(const ev of pool){
        if(eventMatches(ev, f)) keep.push({...ev});
      }
      if(keep.length===0) continue;
      
      out[d] = { note: day.note||'', _events: keep };
      if(day.screenshot) out[d].screenshot = day.screenshot;
      deriveAggregatesForDay(out[d]);
    }
    return out;
  }

  // ====== Flatten trades ======
  function flattenTrades(data, withDayTypeFromFull = true){
    const rows = [];
    const dates = Object.keys(data).sort();
    for(const d of dates){
      const day = data[d];
      const scenarioKey = withDayTypeFromFull ? currentScenarioKey() : null;
      const dayType = withDayTypeFromFull ? dayMatchesType(d, scenarioKey) : computeDayType(day, scenarioKey);
      (day._events||[]).forEach((ev, idx)=>{
        const rVal = eventR(ev);
        rows.push({
          id: ev.id || `${d}-${idx}`,
          date: d,
          setup: ev.setup,
          outcome: effectiveOutcome(ev),
          r: rVal,
          tags: Array.isArray(ev.tags)? ev.tags.slice(): [],
          note: ev.note || '',
          idx,
          dayType
        });
      });
    }
    return rows;
  }

  // ====== Aggregates ======
  function aggregateR(dataObj){
    const dates = Object.keys(dataObj).sort();
    let totalWins=0,totalLoss=0, cum=0, peak=0, maxDD=0, peakAtMaxDD=0;
    let netR=0;
    const dailySeries = [];
    dates.forEach(date=>{
      let dayR=0;
      const day = dataObj[date];
      (day._events||[]).forEach(ev=> {
        const rVal = eventR(ev);
        dayR += rVal;
        const outcome = effectiveOutcome(ev);
        if(outcome==='W') totalWins++; else if(outcome==='L') totalLoss++;
      });
      cum += dayR;
      netR += dayR;
      if(cum > peak) peak = cum;
      const dd = peak - cum;
      if(dd > maxDD){ maxDD = dd; peakAtMaxDD = peak; }
      dailySeries.push({date, value:cum});
    });
    const trades = totalWins + totalLoss;
    const exp = trades>0 ? netR/trades : 0;
    return {dates, totalWins, totalLoss, trades, netR, exp, maxDD, peakAtMaxDD, dailySeries};
  }

  function aggregateCompounding(dataObj, startUSD, riskPct){
    const a = riskPct/100;
    const dates = Object.keys(dataObj).sort();
    const series = [];
    let P = startUSD;
    let peak = P, maxDD = 0, peakAtMaxDD = P;
    let totalWins=0, totalLoss=0, totalTrades=0;
    let totalPnL = 0;

    dates.forEach(date=>{
      let wins=0, losses=0;
      let factor = 1;
      (dataObj[date]._events||[]).forEach(ev=> {
        const rw = Number(ev.rewardR ?? 2);
        const rl = Number(ev.riskR ?? 1);
        const outcome = effectiveOutcome(ev);
        const rVal = eventR(ev);
        if(outcome==='W'){
          wins++;
          const useR = Number.isFinite(rVal) ? Math.max(0, rVal) : (Number.isFinite(rw)? rw : 2);
          factor *= (1 + useR*a);
        }
        else if(outcome==='L'){
          losses++;
          const lossSize = Number.isFinite(rVal) ? Math.abs(rVal) : Math.abs(Number.isFinite(rl)? rl : 1);
          factor *= (1 - lossSize*a);
        }
        else { /* Breakeven: multiply by 1 (no change) */ }
      });
      const prevP = P;
      P = P * factor;
      totalPnL += (P - prevP);
      totalWins += wins; totalLoss += losses;
      totalTrades += wins + losses;
      if(P > peak) peak = P;
      const dd = peak - P;
      if(dd > maxDD){ maxDD = dd; peakAtMaxDD = peak; }
      series.push({date, value:P, delta:(P-prevP), wins, losses});
    });

    const netUSD = P - startUSD;
    const expUSDperTrade = totalTrades>0 ? totalPnL/totalTrades : 0;
    return {series, current:P, start:startUSD, netUSD, maxDD, peakAtMaxDD, totalTrades, totalWins, totalLoss, expUSDperTrade};
  }

  function aggregateCompoundingSteps(dataObj, startUSD, riskPct, stepPct){
    const dates = Object.keys(dataObj).sort();
    const pct = riskPct/100;
    const step = stepPct>0 ? stepPct/100 : 0;
    let equity = startUSD;
    let base = startUSD;
    let nextRaise = step>0 ? base * (1 + step) : Infinity;
    let peak = equity, maxDD = 0, peakAtMaxDD = equity;
    let totalWins = 0, totalLoss = 0, totalTrades = 0;
    let totalPnL = 0;
    const series = [];

    dates.forEach(date=>{
      let dayDelta = 0;
      let wins = 0, losses = 0;
      const events = (dataObj[date]?._events) || [];
      events.forEach(ev=>{
        const outcome = effectiveOutcome(ev);
        const rVal = eventR(ev);
        const riskAmount = base * pct;
        const change = Number.isFinite(rVal) ? rVal * riskAmount : 0;
        if(Number.isFinite(change)){
          const prev = equity;
          equity += change;
          dayDelta += change;
          totalPnL += change;
          if(equity > peak){ peak = equity; }
          const dd = peak - equity;
          if(dd > maxDD){ maxDD = dd; peakAtMaxDD = peak; }
          if(step>0 && equity >= nextRaise){
            base = equity;
            nextRaise = base * (1 + step);
          } else if(step<=0){
            base = equity;
            nextRaise = Infinity;
          }
        }
        if(outcome==='W'){ wins++; totalWins++; totalTrades++; }
        else if(outcome==='L'){ losses++; totalLoss++; totalTrades++; }
      });
      series.push({date, value: equity, delta: dayDelta, wins, losses});
    });

    const netUSD = equity - startUSD;
    const expUSDperTrade = totalTrades>0 ? totalPnL/totalTrades : 0;
    return {series, current:equity, start:startUSD, netUSD, maxDD, peakAtMaxDD, totalTrades, totalWins, totalLoss, expUSDperTrade};
  }

  function aggregateCompoundingDaily(dataObj, startUSD, riskPct){
    const dates = Object.keys(dataObj).sort();
    const pct = riskPct/100;
    let equity = startUSD;
    let peak = equity, maxDD = 0, peakAtMaxDD = equity;
    let totalWins = 0, totalLoss = 0, totalTrades = 0;
    let totalPnL = 0;
    const series = [];

    dates.forEach(date=>{
      const events = (dataObj[date]?._events) || [];
      const dayStart = equity;
      const riskAmount = dayStart * pct;
      let dayDelta = 0;
      let wins = 0, losses = 0;
      events.forEach(ev=>{
        const outcome = effectiveOutcome(ev);
        const rVal = eventR(ev);
        const change = Number.isFinite(rVal) ? rVal * riskAmount : 0;
        if(Number.isFinite(change)){
          dayDelta += change;
        }
        if(outcome==='W'){ wins++; totalWins++; totalTrades++; }
        else if(outcome==='L'){ losses++; totalLoss++; totalTrades++; }
      });
      const prevEquity = equity;
      equity = dayStart + dayDelta;
      totalPnL += (equity - prevEquity);
      if(equity > peak){ peak = equity; }
      const dd = peak - equity;
      if(dd > maxDD){ maxDD = dd; peakAtMaxDD = peak; }
      series.push({date, value: equity, delta: dayDelta, wins, losses, base: dayStart});
    });

    const netUSD = equity - startUSD;
    const expUSDperTrade = totalTrades>0 ? totalPnL/totalTrades : 0;
    return {series, current:equity, start:startUSD, netUSD, maxDD, peakAtMaxDD, totalTrades, totalWins, totalLoss, expUSDperTrade};
  }

  // ====== UI HUD ======
  function renderUnitConfig(){
    const box = $('#unitConfig');
    box.classList.remove('show');
    box.innerHTML = '';
    if(unitMode==='flat'){
      box.classList.add('show');
      box.innerHTML = `
        <div class="row">
          <label>Flat mode:</label>
          <label for="flatStart">Start $</label>
          <input type="number" id="flatStart" step="100" min="0" style="width:160px">
          <label for="rValue">1R = $</label>
          <input type="number" id="rValue" step="0.01" min="0" style="width:140px">
          <span class="note">Applies to Report & CSV.</span>
        </div>`;
      const fs = $('#flatStart'); fs.value = flatStart || '';
      fs.onchange = ()=>{ const v=parseFloat(fs.value); if(isFinite(v) && v>=0){ flatStart=v; if(unitMode==='flat') updateReportView(); saveLocal(); } };
      const el = $('#rValue'); el.value = rValue>0? rValue : '';
      el.onchange = ()=>{ const v=parseFloat(el.value); if(isFinite(v) && v>0){ rValue=v; if(unitMode==='flat') updateReportView(); saveLocal(); } };
    } else if(unitMode==='comp'){
      box.classList.add('show');
      box.innerHTML = `
        <div class="row">
          <label>Compounding:</label>
          <label for="compStart">Start $</label>
          <input type="number" id="compStart" step="100" min="0" style="width:160px">
          <label for="compRisk">% Risk per trade</label>
          <input type="number" id="compRisk" step="0.01" min="0" max="100" style="width:140px">
          <span class="note">Exact compounding using wins/losses per day.</span>
        </div>`;
      const s = $('#compStart'), r = $('#compRisk');
      s.value = compStart || ''; r.value = compRiskPct || '';
      s.onchange = ()=>{ const v=parseFloat(s.value); if(isFinite(v) && v>0){ compStart=v; if(unitMode==='comp') updateReportView(); saveLocal(); } };
      r.onchange = ()=>{ const v=parseFloat(r.value); if(isFinite(v) && v>=0 && v<=100){ compRiskPct=v; if(unitMode==='comp') updateReportView(); saveLocal(); } };
    } else if(unitMode==='compSteps'){
      box.classList.add('show');
      box.innerHTML = `
        <div class="row">
          <label>Compounding (steps):</label>
          <label for="compStepStart">Start $</label>
          <input type="number" id="compStepStart" step="100" min="0" style="width:160px">
          <label for="compStepRisk">% Risk per trade</label>
          <input type="number" id="compStepRisk" step="0.01" min="0" max="100" style="width:140px">
          <label for="compStepPct">Step %</label>
          <input type="number" id="compStepPct" step="0.5" min="0" style="width:120px">
          <span class="note">Risk size increases after equity grows by each step.</span>
        </div>`;
      const s = $('#compStepStart'), r = $('#compStepRisk'), p = $('#compStepPct');
      if(s) s.value = compStepStart || '';
      if(r) r.value = compStepRiskPct || '';
      if(p) p.value = compStepStepPct || '';
      if(s) s.onchange = ()=>{ const v=parseFloat(s.value); if(isFinite(v) && v>0){ compStepStart=v; if(unitMode==='compSteps') updateReportView(); saveLocal(); } };
      if(r) r.onchange = ()=>{ const v=parseFloat(r.value); if(isFinite(v) && v>=0 && v<=100){ compStepRiskPct=v; if(unitMode==='compSteps') updateReportView(); saveLocal(); } };
      if(p) p.onchange = ()=>{ const v=parseFloat(p.value); if(isFinite(v) && v>=0){ compStepStepPct=v; if(unitMode==='compSteps') updateReportView(); saveLocal(); } };
    } else if(unitMode==='compDaily'){
      box.classList.add('show');
      box.innerHTML = `
        <div class="row">
          <label>Compounding (daily):</label>
          <label for="compDailyStart">Start $</label>
          <input type="number" id="compDailyStart" step="100" min="0" style="width:160px">
          <label for="compDailyRisk">% Risk per trade</label>
          <input type="number" id="compDailyRisk" step="0.01" min="0" max="100" style="width:140px">
          <span class="note">Risk size recalculates once per day.</span>
        </div>`;
      const s = $('#compDailyStart'), r = $('#compDailyRisk');
      if(s) s.value = compDailyStart || '';
      if(r) r.value = compDailyRiskPct || '';
      if(s) s.onchange = ()=>{ const v=parseFloat(s.value); if(isFinite(v) && v>0){ compDailyStart=v; if(unitMode==='compDaily') updateReportView(); saveLocal(); } };
      if(r) r.onchange = ()=>{ const v=parseFloat(r.value); if(isFinite(v) && v>=0 && v<=100){ compDailyRiskPct=v; if(unitMode==='compDaily') updateReportView(); saveLocal(); } };
    }
    // Also refresh compact pickers
    try { setupTagPicker("rep"); setupTagPicker("at"); setupTagPicker("repEx"); setupTagPicker("atEx"); } catch(e) {}
  }

  function updateHUD(){
    $('#fileBadge').textContent = currentFileName ? `File: ${currentFileName}` : 'Unsaved';
    const dEl = document.querySelector('#dateInput'); if(dEl) dEl.value = currentDate;
    const uR = document.querySelector('#unitR'); if(uR) uR.classList.toggle('active', unitMode==='R');
    const uF = document.querySelector('#unitDollarFlat'); if(uF) uF.classList.toggle('active', unitMode==='flat');
    const uC = document.querySelector('#unitDollarComp'); if(uC) uC.classList.toggle('active', unitMode==='comp');
    const uCS = document.querySelector('#unitDollarCompSteps'); if(uCS) uCS.classList.toggle('active', unitMode==='compSteps');
    const uCD = document.querySelector('#unitDollarCompDaily'); if(uCD) uCD.classList.toggle('active', unitMode==='compDaily');
    const tEl = document.querySelector('#equityTitle');
    if(tEl){
      if(unitMode==='comp') tEl.textContent = 'Portfolio Value (Compounding)';
      else if(unitMode==='compSteps') tEl.textContent = 'Portfolio Value (Comp Steps)';
      else if(unitMode==='compDaily') tEl.textContent = 'Portfolio Value (Comp Daily)';
      else if(unitMode==='flat') tEl.textContent = 'Cumulative Equity ($)';
      else tEl.textContent = 'Cumulative Equity (R)';
    }
    renderUnitConfig();
    try{ injectReportHandles(); }catch(e){}
  }

  // ====== Calendar Screenshot Modal ======
  function openCalShot(date){
    const img = document.getElementById('calShotImg');
    const ovl = document.getElementById('calShotOverlay');
    if(!img || !ovl) return;
    const shot = getDay(date)?.screenshot;
    if(shot){
      img.src = shot; ovl.classList.add('show'); ovl.setAttribute('aria-hidden','false'); return;
    }
    // Try to fetch lazily from default folder
    getScreenshotForDate(date).then((url)=>{
      if(!url) return;
      img.src = url;
      ovl.classList.add('show');
      ovl.setAttribute('aria-hidden','false');
    });
  }
  function closeCalShot(){
    const img = document.getElementById('calShotImg');
    const ovl = document.getElementById('calShotOverlay');
    if(!img || !ovl) return;
    ovl.classList.remove('show');
    ovl.setAttribute('aria-hidden','true');
    img.removeAttribute('src');
  }

  // ====== Tag pickers (popover widgets) ======
  function updateTagBtn(prefix){
    const btn = $(`#${prefix}TagBtn`);
    // Map prefix to selected arrays (support include and exclude pickers)
    const sel = (function(){
      switch(prefix){
        case 'rep': return repTags;
        case 'at': return atTags;
        case 'cal': return calTags;
        case 'repEx': return repExTags;
        case 'atEx': return atExTags;
        case 'calEx': return calExTags;
        default: return [];
      }
    })();
    const modeAll = document.querySelector(`input[name="${prefix}TagMode"]:checked`)?.value === "all";
    if(!btn) return;
    if(!sel || sel.length===0){ btn.innerHTML = "Any"; btn.setAttribute("aria-label","Tags: Any"); }
    else{
      const count = sel.length;
      btn.innerHTML = `Selected <span class="count">${count}${modeAll? " • All":""}</span>`;
      btn.setAttribute("aria-label", "Tags: "+count+" selected"+(modeAll?" (All)":""));
    }
  }

  function setupTagPicker(prefix){
    const btn = $(`#${prefix}TagBtn`);
    const pop = $(`#${prefix}TagPop`);
    const list = $(`#${prefix}TagList`);
    const search = $(`#${prefix}TagSearch`);
    if(!btn || !pop) return;

    const getSel = ()=>{
      switch(prefix){
        case 'rep': return repTags;
        case 'at': return atTags;
        case 'cal': return calTags;
        case 'repEx': return repExTags;
        case 'atEx': return atExTags;
        case 'calEx': return calExTags;
        default: return [];
      }
    };
    const setSel = (arr)=>{
      switch(prefix){
        case 'rep': repTags = arr; break;
        case 'at': atTags = arr; break;
        case 'cal': calTags = arr; break;
        case 'repEx': repExTags = arr; break;
        case 'atEx': atExTags = arr; break;
        case 'calEx': calExTags = arr; break;
      }
    };

    function syncHidden(){
      const hidden = document.getElementById(prefix+"TagsSel");
      if(!hidden) return;
      const allTags = getAllTagsFromData();
      hidden.innerHTML = "";
      const selArr = Array.isArray(getSel()) ? getSel() : [];
      allTags.forEach(t=>{
        const opt = document.createElement("option");
        opt.value = t; opt.textContent = t; opt.selected = selArr.includes(t);
        hidden.appendChild(opt);
      });
    }

    function renderList(){
      const allTags = getAllTagsFromData();
      list.innerHTML = "";
      if(allTags.length===0){ list.innerHTML = `<div class="muted" style="padding:8px">No tags yet</div>`; return; }
      const selSet = new Set(getSel());
      allTags.forEach(tag=>{
        const id = `${prefix}-tag-${tag.replace(/\s+/g, "-")}`;
        const lab = document.createElement("label");
        lab.dataset.name = tag.toLowerCase();
        lab.innerHTML = `<input type="checkbox" id="${id}" value="${tag}"> <span>${tag}</span>`;
        const cb = lab.querySelector("input");
        cb.checked = selSet.has(tag);
        cb.onchange = ()=>{
          const cur = new Set(getSel());
          if(cb.checked) cur.add(tag); else cur.delete(tag);
          setSel(Array.from(cur));
          updateTagBtn(prefix); syncHidden(); saveLocal();
        };
        list.appendChild(lab);
      });
      syncHidden();
    }

    function filterList(){
      const q = (search?.value||"").trim().toLowerCase();
      list.querySelectorAll("label").forEach(l=>{
        l.style.display = !q || l.dataset.name.includes(q) ? "" : "none";
      });
    }

    btn.onclick = ()=>{ pop.classList.toggle("show"); btn.setAttribute("aria-expanded", pop.classList.contains("show")?"true":"false"); if(pop.classList.contains("show")){ renderList(); updateTagBtn(prefix); setTimeout(()=> search?.focus(), 10); } };
    $(`#${prefix}TagDone`)?.addEventListener("click", ()=>{ pop.classList.remove("show"); btn.setAttribute("aria-expanded","false"); updateTagBtn(prefix); });
    $(`#${prefix}TagClear`)?.addEventListener("click", ()=>{ setSel([]); renderList(); updateTagBtn(prefix); saveLocal(); if(prefix.startsWith("rep")){ updateReportFilterStatus(); } else if(prefix.startsWith("at")){ updateATFilterStatus(); } else { updateCalendarView(); } });
    document.addEventListener("click", (e)=>{
      if(!pop.classList.contains("show")) return;
      const path = e.composedPath ? e.composedPath() : [];
      if(!path.includes(pop) && !path.includes(btn)){
        pop.classList.remove("show"); btn.setAttribute("aria-expanded","false");
      }
    });
    search?.addEventListener("input", filterList);

    // React to Any/All mode toggle
    document.querySelectorAll(`input[name="${prefix}TagMode"]`).forEach(r=>{
      r.addEventListener("change", ()=>{ updateTagBtn(prefix); saveLocal(); if(prefix.startsWith("rep")){ updateReportFilterStatus(); } else if(prefix.startsWith("at")){ updateATFilterStatus(); } else { updateCalendarView(); } });
    });

    // Initial render
    renderList(); updateTagBtn(prefix);
  }

  // ====== Populate tag selects ======
  function populateTagSelects(){
    const allTags = getAllTagsFromData();
    
    // Report tags
    const repSel = $('#repTagsSel');
    if(repSel){
      repSel.innerHTML = '';
      allTags.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        if(repTags.includes(t)) opt.selected = true;
        repSel.appendChild(opt);
      });
    }
    // Report exclude tags
    const repExSel = $('#repExTagsSel');
    if(repExSel){
      repExSel.innerHTML = '';
      allTags.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        if(repExTags.includes(t)) opt.selected = true;
        repExSel.appendChild(opt);
      });
    }
    
    // All Trades tags
    const atSel = $('#atTagsSel');
    if(atSel){
      atSel.innerHTML = '';
      allTags.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        if(atTags.includes(t)) opt.selected = true;
        atSel.appendChild(opt);
      });
    }
    // All Trades exclude tags
    const atExSel = $('#atExTagsSel');
    if(atExSel){
      atExSel.innerHTML = '';
      allTags.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        if(atExTags.includes(t)) opt.selected = true;
        atExSel.appendChild(opt);
      });
    }

    // Calendar tags (hidden backing select for popover)
    const calSel = $('#calTagsSel');
    if(calSel){
      calSel.innerHTML = '';
      allTags.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        if(calTags.includes(t)) opt.selected = true;
        calSel.appendChild(opt);
      });
    }
    // Calendar exclude tags (hidden backing select for popover)
    const calExSel = $('#calExTagsSel');
    if(calExSel){
      calExSel.innerHTML = '';
      allTags.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        if(calExTags.includes(t)) opt.selected = true;
        calExSel.appendChild(opt);
      });
    }
  }

  // ====== Backtest View ======
  function updateBacktestView(){
    updateHUD();
    const day = getDay(currentDate);
    let storedScenario = scenarioSelectionByDate[currentDate];
    if(!SCENARIOS.includes(storedScenario)) storedScenario = 'S1';
    scenarioSelectionByDate[currentDate] = storedScenario;
    if(activeScenario !== storedScenario){
      changeScenario(storedScenario, {skipRefresh:true, skipSave:true});
    } else {
      syncScenarioControls();
    }

    $('#dayLabel').textContent = dispDate(currentDate);

    renderBacktestJournal(currentDate);

    let W=0,L=0;
    const events = day ? eventsForScenario(day, currentScenarioKey()) : [];
    events.forEach(ev=>{
      const outcome = effectiveOutcome(ev);
      if(outcome==='W') W++;
      else if(outcome==='L') L++;
    });
    // Sync Backtest Trail toggle with global
    const btTrail = document.getElementById('btTrailToggle'); if(btTrail) btTrail.checked = !!trailProfit;

    // Compute day R from events (per-trade RR)
    let dayR = 0;
    events.forEach(ev=>{ dayR += eventR(ev); });
    const T = W+L, WR = T? (W/T*100):0, EXP = T? dayR/T : 0;
    $('#wins').textContent = W;
    $('#losses').textContent = L;
    $('#total').textContent = T;
    $('#winRate').textContent = `${fmt(WR,1)}%`;
    $('#totalR').textContent = `${fmt(dayR,1)}R`;
    $('#expectancy').textContent = `${fmt(EXP,2)}R`;

    const body = $('#todayTableBody'); body.innerHTML='';
    if(events.length===0){
      body.innerHTML = `<tr><td colspan="8" class="muted" style="text-align:center">No data for this day yet</td></tr>`;
    }else{
      events.forEach((ev, idx)=>{
        const effective = effectiveOutcome(ev);
        const isWin = effective==='W';
        const isBE = effective==='B';
        const origOutcome = ev.outcome;
        const origWin = origOutcome==='W';
        const rVal = origWin ? Number(ev.rewardR ?? 2) : (origOutcome==='B' ? 0 : -Number(ev.riskR ?? 1));
        const rDisp = `${rVal>0? '+':''}${fmt(rVal,2)}R`;
        const resHTML = isWin
          ? `<span style="color:var(--green); font-weight:800">WIN</span>`
          : isBE
            ? `<span style="color:var(--amber); font-weight:800">BREAKEVEN</span>`
            : `<span style="color:var(--red); font-weight:800">LOSE</span>`;
        const rColor = isWin ? 'var(--green)' : (isBE ? 'var(--amber)' : 'var(--red)');
        const rHTML = `<button class="btn soft" data-r-id="${ev.id}" style="color:${rColor}; padding:4px 10px">${rDisp}</button>`;
        const showTrailBtn = origOutcome==='W' || origOutcome==='L';
        const trailVal = showTrailBtn && Number.isFinite(parseFloat(ev.trailR)) ? Number(ev.trailR) : null;
        const trailDisp = trailVal!=null ? `${trailVal>0? '+':''}${fmt(trailVal,2)}R` : '—';
        const trailTitle = origOutcome==='L' ? 'Set Trailed R (loss)' : 'Set Trailed R';
        const trailCell = showTrailBtn
          ? `<button class="btn soft" data-trail-id="${ev.id}" title="${trailTitle}">${trailDisp}</button>`
          : '<span class="muted">—</span>';
        const tags = Array.isArray(ev.tags)? ev.tags : [];
        const tagHTML = `
          <div class="tag-cell" data-id="${ev.id}">${
            tags.length>0
              ? tags.map(t=>`<span class="chip">${t} <span class="xbtn" title="Remove" data-tag-remove="${t}">×</span></span>`).join(' ')
              : '<span class="muted">—</span>'
          }
            <input type="text" class="row-tag-input" data-id="${ev.id}" placeholder="Add tag…" style="min-width:110px; margin-left:6px" />
          </div>`;
        const noteBtn = `<button class=\"btn soft\" data-note-id=\"${ev.id}\" title=\"Edit note\">✏️</button>`;
        const notePreview = `<span class=\"muted\" data-note-prev=\"${ev.id}\">${(ev.note||'').slice(0,40) || '—'}</span>`;
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${idx+1}</td>
          <td>${ev.setup||'—'}</td>
          <td>${resHTML}</td>
          <td>${rHTML}</td>
          <td>${trailCell}</td>
          <td>${tagHTML}</td>
          <td>${noteBtn} ${notePreview}</td>
          <td><button class=\"icon-btn\" title=\"Delete trade\" data-del-id=\"${ev.id}\">🗑️</button></td>`;
        body.appendChild(tr);
      });
    }

    // Tag add (Enter in inline input)
    body.querySelectorAll('.row-tag-input').forEach(inp=>{
      inp.onkeydown = (e)=>{
        if(e.key==='Enter'){
          e.preventDefault();
          const id = inp.getAttribute('data-id');
          const v = (inp.value||'').trim(); if(!v) return;
          const day = touchDay(currentDate);
          const ev = (day._events||[]).find(x=> x.id===id);
          if(!ev) return;
          ensureTag(v); addTagsToEvent(ev, [v]); inp.value='';
          deriveAggregatesForDay(day); updateBacktestView(); updateReportView(); saveLocal();
          // Restore focus to the same trade's tag input after re-render
          requestAnimationFrame(()=>{
            const nextInp = document.querySelector(`.row-tag-input[data-id="${id}"]`);
            if(nextInp){ nextInp.focus(); }
          });
          showToast(`Tag "${v}" added`);
        }
      };
    });

    // Tag remove (click x on chip)
    body.querySelectorAll('.tag-cell .xbtn[data-tag-remove]').forEach(btn=>{
      btn.onclick = ()=>{
        const cell = btn.closest('.tag-cell'); const id = cell?.getAttribute('data-id'); const t = btn.getAttribute('data-tag-remove');
        if(!id || !t) return;
        const day = touchDay(currentDate);
        const ev = (day._events||[]).find(x=> x.id===id);
        if(!ev) return;
        removeTagsFromEvent(ev, [t]);
        deriveAggregatesForDay(day); updateBacktestView(); updateReportView(); saveLocal();
        showToast(`Tag "${t}" removed`);
      };
    });

    body.querySelectorAll('[data-del-id]').forEach(btn=>{
      btn.onclick = ()=>{
        const id = btn.getAttribute('data-del-id');
        const snapshot = deepCloneData(dailyData);
        pushUndo(()=>{ dailyData = snapshot; updateBacktestView(); updateReportView(); saveLocal(); });
        const tgt = touchDay(currentDate);
        tgt._events = (tgt._events||[]).filter(ev=> ev.id !== id);
        deriveAggregatesForDay(tgt);
        if((tgt._events?.length||0)===0 && (!tgt.note || tgt.note.trim()==='') && !tgt.screenshot){
          delete dailyData[currentDate];
        }
        showToast(`Deleted trade for ${dispDate(currentDate)}`);
        updateBacktestView(); updateReportView(); saveLocal();
      };
    });

    // Inline R editor
    body.querySelectorAll('[data-r-id]').forEach(btn=>{
      btn.onclick = ()=>{
        const id = btn.getAttribute('data-r-id');
        if(!id) return;
        const day = touchDay(currentDate);
        const ev = (day._events||[]).find(x=> x.id===id);
        if(!ev) return;
        let current = 0;
        if(ev.outcome==='W') current = Number(ev.rewardR ?? 2);
        else if(ev.outcome==='L') current = -Number(ev.riskR ?? 1);
        const promptMsg = ev.outcome==='W'
          ? 'Set reward (R) for this winning trade:'
          : ev.outcome==='L'
            ? 'Set loss (R) for this losing trade (positive number):'
            : 'Breakeven trade — set custom R (use 0 for breakeven):';
        const res = prompt(promptMsg, fmt(current,2));
        if(res===null) return;
        const val = parseFloat(res);
        if(!Number.isFinite(val)){
          alert('Please enter a numeric value.');
          return;
        }
        if(ev.outcome==='W'){
          if(val < 0){ alert('Reward must be non-negative.'); return; }
          ev.rewardR = val;
          if(val===0) ev.outcome='B';
        } else if(ev.outcome==='L'){
          if(val > 0){ alert('Loss should be entered as a positive number.'); return; }
          const lossVal = Math.abs(val);
          ev.riskR = lossVal;
          if(lossVal===0) ev.outcome='B';
        } else {
          if(val > 0){ ev.outcome='W'; ev.rewardR = val; delete ev.riskR; }
          else if(val < 0){ ev.outcome='L'; ev.riskR = Math.abs(val); delete ev.rewardR; }
          else { ev.outcome='B'; ev.rewardR=0; ev.riskR=0; }
        }
        deriveAggregatesForDay(day);
        updateBacktestView();
        updateReportView();
        saveLocal();
        showToast('Updated R value');
      };
    });

    // Trail R editor
    body.querySelectorAll('[data-trail-id]').forEach(btn=>{
      btn.onclick = ()=>{
        const id = btn.getAttribute('data-trail-id');
        const d = touchDay(currentDate);
        const ev = (d._events||[]).find(x=> x.id===id);
        if(!ev || (ev.outcome!=='W' && ev.outcome!=='L')) return;
        const cur = Number.isFinite(parseFloat(ev.trailR)) ? String(ev.trailR) : '';
        const promptMsg = ev.outcome==='L'
          ? 'Set Trailed R for this losing trade (use negative values to reflect loss; leave empty to clear):'
          : 'Set Trailed R for this winning trade (negative converts to loss; leave empty to clear):';
        const next = prompt(promptMsg, cur);
        if(next===null) return;
        const trimmed = String(next).trim();
        if(trimmed===''){
          delete ev.trailR;
        } else {
          const v = parseFloat(trimmed);
          if(Number.isFinite(v)){
            ev.trailR = v;
          } else {
            alert('Please enter a numeric value, or clear it.');
            return;
          }
        }
        deriveAggregatesForDay(d); updateBacktestView(); updateReportView(); updateCalendarView(); saveLocal();
      };
    });

    updateScreenshotView();

    // RR inputs + hints
    const rIn = document.getElementById('rewardInput');
    const kIn = document.getElementById('riskInput');
    const winHint = document.getElementById('winHint');
    const loseHint = document.getElementById('loseHint');
    if(rIn){ rIn.value = rrReward; rIn.oninput = ()=>{ const v=parseFloat(rIn.value); if(isFinite(v) && v>=0){ rrReward=v; if(winHint) winHint.textContent = `Adds +${fmt(rrReward,2)}R to today`; saveLocal(); } }; }
    if(kIn){ kIn.value = rrRisk; kIn.oninput = ()=>{ const v=parseFloat(kIn.value); if(isFinite(v) && v>=0){ rrRisk=v; if(loseHint) loseHint.textContent = `Adds -${fmt(rrRisk,2)}R to today`; saveLocal(); } }; }
    if(winHint) winHint.textContent = `Adds +${fmt(rrReward,2)}R to today`;
    if(loseHint) loseHint.textContent = `Adds -${fmt(rrRisk,2)}R to today`;

    // Wire per-trade note editors
    body.querySelectorAll('[data-note-id]').forEach(btn=>{
      btn.onclick = ()=>{
        const id = btn.getAttribute('data-note-id');
        const d = touchDay(currentDate);
        const ev = (d._events||[]).find(x=> x.id===id);
        if(!ev) return;
        const cur = ev.note || '';
        const next = prompt('Edit trade note:', cur);
        if(next===null) return;
        ev.note = String(next).slice(0,400);
        deriveAggregatesForDay(d); updateBacktestView(); updateReportView(); saveLocal();
        showToast('Trade note saved');
      };
    });

    // (Daily rules removed in v8.13)
  }

  // ====== Setup controls (dynamic, up to 5) ======
  function renderSetupButtons(){
    const seg = document.getElementById('setupSeg');
    if(!seg) return;
    seg.innerHTML = '';
    const max = Math.min(6, (SETUPS||[]).length);
    (SETUPS||[]).slice(0, max).forEach((name, idx)=>{
      const b = document.createElement('button');
      b.setAttribute('data-setup', name);
      b.textContent = name;
      b.title = `Shortcut: ${idx+1}`;
      if(currentSetup===name) b.classList.add('active');
      b.onclick = ()=>{
        seg.querySelectorAll('button').forEach(x=>x.classList.remove('active'));
        b.classList.add('active');
        currentSetup = name; saveLocal();
      };
      seg.appendChild(b);
    });
  }

  function populateSetupSelects(){
    const allInData = new Set();
    for(const d of Object.keys(dailyData||{})){
      (dailyData[d]._events||[]).forEach(ev=>{ if(ev.setup) allInData.add(ev.setup); });
    }
    const ordered = Array.from(new Set([...(SETUPS||[]), ...Array.from(allInData)]));

    const repSel = document.getElementById('repSetupSel');
    if(repSel){
      const cur = repSel.value || '';
      repSel.innerHTML = '';
      const any = document.createElement('option'); any.value=''; any.textContent='Any'; repSel.appendChild(any);
      ordered.forEach(s=>{ const o=document.createElement('option'); o.value=s; o.textContent=s; repSel.appendChild(o); });
      repSel.value = cur && ordered.includes(cur) ? cur : '';
    }
    const atSel = document.getElementById('atSetupSel');
    if(atSel){
      const cur = atSel.value || '';
      atSel.innerHTML = '';
      const any = document.createElement('option'); any.value=''; any.textContent='Any'; atSel.appendChild(any);
      ordered.forEach(s=>{ const o=document.createElement('option'); o.value=s; o.textContent=s; atSel.appendChild(o); });
      atSel.value = cur && ordered.includes(cur) ? cur : '';
    }
    const calSel = document.getElementById('calSetupSel');
    if(calSel){
      const cur = calSel.value || '';
      calSel.innerHTML = '';
      const any = document.createElement('option'); any.value=''; any.textContent='Any'; calSel.appendChild(any);
      ordered.forEach(s=>{ const o=document.createElement('option'); o.value=s; o.textContent=s; calSel.appendChild(o); });
      calSel.value = cur && ordered.includes(cur) ? cur : '';
    }
  }

  function openSetupMgr(){
    const pop = document.getElementById('setupManagePop');
    const btn = document.getElementById('setupManageBtn');
    if(!pop||!btn) return;
    pop.classList.add('show');
    btn.setAttribute('aria-expanded','true');
    renderSetupMgr();
    setTimeout(()=> document.getElementById('newSetupName')?.focus(), 10);
  }
  function closeSetupMgr(){
    const pop = document.getElementById('setupManagePop');
    const btn = document.getElementById('setupManageBtn');
    if(!pop||!btn) return;
    pop.classList.remove('show');
    btn.setAttribute('aria-expanded','false');
  }
  function renderSetupMgr(){
    const list = document.getElementById('setupList');
    if(!list) return;
    list.innerHTML='';
    const max = 6;
    (SETUPS||[]).forEach((s, i)=>{
      const row = document.createElement('div');
      row.style.display='flex'; row.style.alignItems='center'; row.style.justifyContent='space-between'; row.style.gap='8px';
      const left = document.createElement('div'); left.textContent = `${i+1}. ${s}`; row.appendChild(left);
      const right = document.createElement('div');
      const del = document.createElement('button'); del.className='btn soft'; del.textContent='Remove'; del.title='Remove this setup';
      del.onclick = ()=> removeSetup(s);
      if((SETUPS||[]).length<=1) del.disabled=true;
      right.appendChild(del); row.appendChild(right);
      list.appendChild(row);
    });
    const hint = document.getElementById('setupHint'); if(hint){ hint.textContent = `Up to ${max} setups. Use keys 1–${Math.min(max, (SETUPS||[]).length)} to switch.`; }
    const addBtn = document.getElementById('addSetupBtn'); const inp = document.getElementById('newSetupName');
    if(addBtn){
      addBtn.onclick = ()=>{
        const v = (inp?.value||'').trim();
        if(!v) return;
        addSetup(v);
        if(inp) inp.value='';
      };
      addBtn.disabled = (SETUPS||[]).length>=max;
    }
    if(inp){ inp.onkeydown = (e)=>{ if(e.key==='Enter'){ e.preventDefault(); addBtn?.click(); } }; }
  }

  function addSetup(name){
    const max = 6; const v = String(name||'').trim(); if(!v) return;
    if(!Array.isArray(SETUPS)) SETUPS=[];
    if(SETUPS.length>=max){ showToast('Maximum of 6 setups'); return; }
    if(SETUPS.includes(v)){ showToast('Setup already exists'); return; }
    SETUPS.push(v);
    if(!currentSetup) currentSetup = v;
    renderSetupButtons(); populateSetupSelects(); updateReportView(); saveLocal(); showToast(`Added setup "${v}"`);
    renderSetupMgr();
  }

  function removeSetup(name){
    const v = String(name||'').trim(); if(!v) return;
    if(!Array.isArray(SETUPS) || SETUPS.length<=1){ showToast('Keep at least one setup'); return; }
    SETUPS = SETUPS.filter(s=> s!==v);
    if(!SETUPS.includes(currentSetup)) currentSetup = SETUPS[0] || '';
    renderSetupButtons(); populateSetupSelects(); updateReportView(); saveLocal(); showToast(`Removed setup "${v}"`);
    renderSetupMgr();
  }

  function updateScreenshotView(){
    const day = getDay(currentDate);
    const dataUrl = day?.screenshot || null;
    const img = $('#shotImg'), tools = $('#shotTools'), drop = $('#shotDrop');
    if(dataUrl){
      img.src = dataUrl; img.style.display='block'; tools.style.display='flex'; drop.style.display='none';
    }else{
      // If user explicitly cleared the screenshot for this date, do not lazy-load
      if(day?.screenshotCleared){
        if(img){ img.removeAttribute('src'); img.style.display='none'; }
        if(tools) tools.style.display='none'; if(drop) drop.style.display='flex';
        return;
      }
      // Try to lazy-load from default save folder/shots by date
      try{
        getScreenshotForDate(currentDate).then((url)=>{
          if(url){
            const d = getDay(currentDate); if(d) d.screenshot = url;
            if(img){ img.src = url; img.style.display='block'; }
            if(tools) tools.style.display='flex'; if(drop) drop.style.display='none';
          }else{
            if(img){ img.removeAttribute('src'); img.style.display='none'; }
            if(tools) tools.style.display='none'; if(drop) drop.style.display='flex';
          }
        }).catch(()=>{
          if(img){ img.removeAttribute('src'); img.style.display='none'; }
          if(tools) tools.style.display='none'; if(drop) drop.style.display='flex';
        });
      }catch(_e){
        img.removeAttribute('src'); img.style.display='none'; tools.style.display='none'; drop.style.display='flex';
      }
    }
  }

  // ====== Report View ======
  function getReportFilters(){
    return {
      start: reportStartDate, end: reportEndDate,
      setup: repSetup || '', result: repResult || '',
      tags: repTags.slice(), tagsAll: !!repTagsAll,
      excludeTags: repExTags.slice(), excludeTagsAll: !!repExTagsAll,
      limitPerDay: repTradesLimit || null,
      nthTradePerDay: (Number.isFinite(parseInt(repNthTrade)) && parseInt(repNthTrade)>0) ? parseInt(repNthTrade) : null,
      scenario: currentScenarioKey(),
      dayType: ''
    };
  }

  function filteredData(){
    const f = getReportFilters();
    return filteredClone(dailyData, f);
  }

  function updateReportFilterStatus(){
    const f = getReportFilters();
    let count = 0;
    if(f.start || f.end) count++;
    if(f.setup) count++;
    if(f.result) count++;
    if(f.scenario && f.scenario !== 'S1') count++;
    if(f.tags && f.tags.length > 0) count++;
    if(f.excludeTags && f.excludeTags.length > 0) count++;
    if(f.limitPerDay && parseInt(f.limitPerDay) > 0) count++;
    if(f.nthTradePerDay && parseInt(f.nthTradePerDay) > 0) count++;
    
    const el = $('#repFilterStatus');
    if(el){
      if(count > 0){
        el.innerHTML = `<span class="filter-active">${count} filter${count>1?'s':''} active</span>`;
      } else {
        el.innerHTML = '';
      }
    }
  }

  function updateReportView(){
    updateHUD();
    updateReportFilterStatus();
    // sync input with state
    const repInp = document.getElementById('repTradesPerDay'); if(repInp) repInp.value = repTradesLimit && repTradesLimit>0 ? String(repTradesLimit) : '';
    const repNthInp = document.getElementById('repNthTrade'); if(repNthInp) repNthInp.value = repNthTrade && repNthTrade>0 ? String(repNthTrade) : '';
    const repTrail = document.getElementById('repTrailToggle'); if(repTrail) repTrail.checked = !!trailProfit;
    const repScenarioSel = document.getElementById('repScenarioSel'); if(repScenarioSel && repScenarioSel.value !== currentScenarioKey()) repScenarioSel.value = currentScenarioKey();

    const data = filteredData();
    const dates = Object.keys(data).sort();
    const flatTrades = flattenTrades(data, true);

    // Charts: Trade R Distribution and Rolling Win Rate
    try{
      const outcomes = getTradeOutcomes(data) || [];
      // Trade R distribution (histogram over R)
      const n = outcomes.length;
      const ctxDist = document.getElementById('rDistChart')?.getContext('2d');
      if(ctxDist){
        let labels = [], counts = [];
        if(n>0){
          const minV = Math.min(...outcomes), maxV = Math.max(...outcomes);
          const targetBins = Math.max(5, Math.min(30, Math.ceil(Math.sqrt(n))));
          const span = (maxV - minV) || 1;
          // Choose a "nice" step size for readable ranges
          const rawStep = span / targetBins;
          const pow = Math.pow(10, Math.floor(Math.log10(Math.abs(rawStep))));
          const norm = rawStep / pow;
          const niceNorm = norm <= 1 ? 1 : norm <= 2 ? 2 : norm <= 2.5 ? 2.5 : norm <= 5 ? 5 : 10;
          const step = niceNorm * pow;
          const minEdge = Math.floor(minV / step) * step;
          const maxEdge = Math.ceil(maxV / step) * step;
          const binCount = Math.max(1, Math.ceil((maxEdge - minEdge) / step));
          labels = new Array(binCount).fill(0).map((_,i)=> {
            const a = minEdge + i*step; const b = a + step;
            return `${fmt(a,2)}–${fmt(b,2)}`;
          });
          counts = new Array(binCount).fill(0);
          const bg = new Array(binCount).fill('#4ea1ff66');
          const br = new Array(binCount).fill('#4ea1ff');
          // Color bins by sign (midpoint sign → green/red/amber)
          for(let i=0;i<binCount;i++){
            const mid = (minEdge + i*step) + step/2;
            if(mid>0){ bg[i] = '#27be6944'; br[i] = '#27be69'; }
            else if(mid<0){ bg[i] = '#ff5a6b44'; br[i] = '#ff5a6b'; }
            else { bg[i] = '#ffc85744'; br[i] = '#ffc857'; }
          }
          outcomes.forEach(v=>{
            let idx = Math.floor((v - minEdge)/step);
            if(idx<0) idx = 0; if(idx>=binCount) idx = binCount-1; // include max in last bin
            counts[idx]++;
          });
          if(rDistChart){ rDistChart.destroy(); }
          rDistChart = new Chart(ctxDist, {
            type:'bar',
            data:{ labels, datasets:[{ label:'Trades', data: counts, backgroundColor:bg, borderColor:br, borderWidth:1 }] },
            options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ x:{grid:{color:'#2b315d'}}, y:{grid:{color:'#2b315d'}} } }
          });
        } else {
          if(rDistChart){ rDistChart.destroy(); }
          rDistChart = new Chart(ctxDist, {
            type:'bar',
            data:{ labels, datasets:[{ label:'Trades', data: counts, backgroundColor:'#4ea1ff66', borderColor:'#4ea1ff', borderWidth:1 }] },
            options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ x:{grid:{color:'#2b315d'}}, y:{grid:{color:'#2b315d'}} } }
          });
        }
      }

      // Rolling win rate with selectable window
      const ctxWR = document.getElementById('rollingWRChart')?.getContext('2d');
      if(ctxWR){
        const W = Number.isFinite(parseInt(rollingWinWindow)) ? parseInt(rollingWinWindow) : 20;
        const wr = [];
        // Build trade dates aligned to each point (trade index)
        const rowsWR = flatTrades.slice();
        const tradeDates = rowsWR.map(r=> r.date);
        for(let i=0;i<outcomes.length;i++){
          const a = Math.max(0, i-W+1);
          const winCount = outcomes.slice(a, i+1).filter(v=> v>0).length;
          const denom = (i - a + 1) || 1;
          wr.push(+(winCount/denom*100).toFixed(2));
        }
        const labelsWR = tradeDates.map(d=> dispDate(d));
        if(rollingWRChart){ rollingWRChart.destroy(); }
        const thr = Number.isFinite(parseFloat(rollingWinThresh)) ? parseFloat(rollingWinThresh) : 20;
        const thrArr = wr.map(()=> thr);
        const redData = wr.map(v=> v<=thr ? v : null);
        rollingWRChart = new Chart(ctxWR, {
          type:'line',
          data:{ labels: labelsWR, datasets:[
            { label:'Win %', data: wr, borderColor:'#27be69', backgroundColor:'#27be6922', fill:true, tension:.15, borderWidth:2, pointRadius:0, order:0 },
            { label:'≤ Threshold', data: redData, borderColor:'#ff5a6b', backgroundColor:'#ff5a6b55', fill:true, tension:.15, borderWidth:2, pointRadius:3, hitRadius:6, spanGaps:false, order:2 },
            { label:'Threshold', data: thrArr, borderColor:'#ff5a6b', borderDash:[6,6], pointRadius:0, fill:false, order:1 }
          ] },
          options:{
            responsive:true, maintainAspectRatio:false,
            plugins:{
              legend:{display:false},
              tooltip:{
                callbacks:{
                  title:(items)=>{
                    const idx = items && items.length ? items[0].dataIndex : null;
                    if(idx==null) return '';
                    const d = tradeDates[idx] || null;
                    return d ? `Date: ${dispDate(d)}` : '';
                  },
                  label:(ctx)=> `Win %: ${ctx.parsed.y}%`
                }
              }
            },
            scales:{ x:{grid:{color:'#2b315d'}}, y:{min:0, max:100, ticks:{callback:(v)=> `${v}%`}, grid:{color:'#2b315d'}} }
          }
        });
      }
    }catch(e){ /* noop */ }

    // Profit concentration curve (Pareto)
    try{
      const ctxPareto = document.getElementById('profitConcentrationChart')?.getContext('2d');
      const summaryEl = document.getElementById('profitConcentrationSummary');
      if(ctxPareto && summaryEl){
        if(!flatTrades.length){
          if(profitConcentrationChart){ profitConcentrationChart.destroy(); profitConcentrationChart = null; }
          summaryEl.innerHTML = '<span style="background:none;color:var(--muted);font-weight:600">No trades</span>';
        } else {
          const sorted = flatTrades.slice().sort((a,b)=> b.r - a.r);
          const totalTrades = sorted.length;
          const totalPos = sorted.reduce((acc,t)=> acc + (t.r>0 ? t.r : 0), 0);
          const totalAbs = sorted.reduce((acc,t)=> acc + Math.abs(t.r), 0);
          const denom = totalPos > 0 ? totalPos : (totalAbs > 0 ? totalAbs : 1);
          let cumPos = 0;
          const points = sorted.map((t, idx)=>{
            if(t.r>0) cumPos += t.r;
            const tradePct = ((idx+1)/totalTrades)*100;
            const profitPct = denom>0 ? (cumPos/denom*100) : 0;
            return {x:+tradePct.toFixed(2), y:+profitPct.toFixed(2)};
          });
          const highlightSpec = [
            {label:'Top 10%', share:0.10, color:'#ffc857'},
            {label:'Top 20%', share:0.20, color:'#35cc7a'}
          ];
          const highlightDatasets = highlightSpec.map(spec=>{
            const count = Math.max(1, Math.round(totalTrades * spec.share));
            const idx = Math.min(totalTrades-1, count-1);
            const pt = idx>=0 && points[idx] ? points[idx] : null;
            return {
              type:'scatter',
              label: spec.label,
              data: pt ? [pt] : [],
              pointRadius:6,
              pointHoverRadius:8,
              pointBackgroundColor: spec.color,
              pointBorderColor:'#0f1222',
              pointBorderWidth:2,
              showLine:false
            };
          });
          if(profitConcentrationChart){ profitConcentrationChart.destroy(); }
          profitConcentrationChart = new Chart(ctxPareto, {
            type:'line',
            data:{
              datasets:[
                { label:'Profit Share', data: points, borderColor:'#4ea1ff', backgroundColor:'rgba(78,161,255,0.18)', borderWidth:2, fill:true, tension:.2, pointRadius:0, parsing:false },
                { label:'Baseline', data:[{x:0,y:0},{x:100,y:100}], borderColor:'rgba(154,161,198,0.35)', borderDash:[6,6], pointRadius:0, fill:false, tension:0, parsing:false },
                ...highlightDatasets
              ]
            },
            options:{
              responsive:true, maintainAspectRatio:false,
              interaction:{mode:'nearest', intersect:false},
              plugins:{
                legend:{display:false},
                tooltip:{
                  callbacks:{
                    title:(items)=>{
                      if(!items || !items.length) return '';
                      const x = items[0].parsed?.x;
                      return x==null? '' : `${fmt(x,1)}% of trades`;
                    },
                    label:(ctx)=>{
                      const y = ctx.parsed?.y;
                      return y==null? '' : `${fmt(y,1)}% of cumulative profit`;
                    }
                  }
                }
              },
              scales:{
                x:{type:'linear', min:0, max:100, grid:{color:'#2b315d'}, ticks:{callback:(v)=> `${v}%`}},
                y:{suggestedMin:0, suggestedMax:100, grid:{color:'#2b315d'}, ticks:{callback:(v)=> `${v}%`}}
              }
            }
          });

          const shareFor = (share)=>{
            const count = Math.max(1, Math.round(totalTrades*share));
            const idx = Math.min(totalTrades-1, count-1);
            return idx>=0 && points[idx] ? points[idx].y : 0;
          };
          const share10 = shareFor(0.10);
          const share20 = shareFor(0.20);
          const totalNet = sorted.reduce((acc,t)=> acc + t.r, 0);
          const denomLabel = totalPos>0 ? 'of profit' : 'of turnover';
          const top10Count = Math.max(1, Math.round(totalTrades*0.10));
          const top20Count = Math.max(1, Math.round(totalTrades*0.20));
          summaryEl.innerHTML = `
            <span>Top 10%<small>${top10Count} trades · ${fmt(share10,1)}% ${denomLabel}</small></span>
            <span>Top 20%<small>${top20Count} trades · ${fmt(share20,1)}% ${denomLabel}</small></span>
            <span>Net Total<small>${fmt(totalNet,2)}R</small></span>
          `;
        }
      }
    }catch(e){ /* noop */ }

    // Compute Avg Win/Loss R once (trail-aware)
    (function(){
      try{
        let wSum=0, wN=0, lSum=0, lN=0;
        Object.keys(data).forEach(d=>{
          ((data[d]?._events)||[]).forEach(ev=>{
            const outcome = effectiveOutcome(ev);
            if(outcome==='W'){ wSum += eventR(ev); wN++; }
            else if(outcome==='L'){ lSum += eventR(ev); lN++; }
          });
        });
        const winEl = document.getElementById('kpiAvgWinR'); if(winEl) winEl.textContent = wN>0? `${fmt(wSum/wN,2)}R` : '—';
        const lossEl = document.getElementById('kpiAvgLossR'); if(lossEl) lossEl.textContent = lN>0? `${fmt(lSum/lN,2)}R` : '—';
      }catch(e){ /* noop */ }
    })();

    // KPIs based on unit mode (keeping all existing logic)
    if(unitMode==='comp' || unitMode==='compSteps' || unitMode==='compDaily'){
      const isSteps = unitMode==='compSteps';
      const isDaily = unitMode==='compDaily';
      const start = isSteps
        ? (compStepStart>0 ? compStepStart : 100000)
        : (isDaily ? (compDailyStart>0 ? compDailyStart : 100000) : (compStart>0 ? compStart : 100000));
      const risk = isSteps
        ? (compStepRiskPct>0 ? compStepRiskPct : 0.3)
        : (isDaily ? (compDailyRiskPct>0 ? compDailyRiskPct : 0.3) : (compRiskPct>0 ? compRiskPct : 0.3));
      const step = isSteps ? (compStepStepPct>=0 ? compStepStepPct : 0) : 0;
      const comp = isSteps
        ? aggregateCompoundingSteps(data, start, risk, step)
        : (isDaily ? aggregateCompoundingDaily(data, start, risk) : aggregateCompounding(data, start, risk));

      // Total trades incl. BE shown in brackets
      (function(){
        const totalIncl = Object.keys(data).reduce((a,d)=> a + ((data[d]?._events||[]).length), 0);
        const main = comp.totalTrades;
        const el = document.getElementById('kpiTrades');
        if(el) el.innerHTML = `${main} <span class="pct">(${totalIncl})</span>`;
      })();
      const compNetPct = start>0 ? (comp.netUSD/start*100) : null;
      const compNetPctStr = compNetPct==null ? null : `${comp.netUSD>=0?'+':''}${fmt(compNetPct,1)}%`;
      const compNetPctSpan = compNetPctStr ? ` <span class="pct" style="color:${comp.netUSD>=0?'var(--green)':'var(--red)'}">(${compNetPctStr})</span>` : '';
      $('#kpiNet').innerHTML = `$${fmt(comp.netUSD,2)}${compNetPctSpan}`;
      const winRate = comp.totalTrades? (comp.totalWins/comp.totalTrades*100):0;
      $('#kpiWR').textContent = `${fmt(winRate,1)}%`;
      $('#kpiExp').textContent = `$${fmt(comp.expUSDperTrade,2)}`;
      const compDDDen = comp.peakAtMaxDD && comp.peakAtMaxDD>0 ? comp.peakAtMaxDD : start;
      const compDDPctStr = compDDDen>0 ? `${fmt(-(comp.maxDD/compDDDen*100),1)}%` : null;
      const compDDPctSpan = compDDPctStr ? ` <span class="pct" style="color:var(--red)">(${compDDPctStr})</span>` : '';
      $('#kpiDD').innerHTML = `$${fmt(comp.maxDD,2)}${compDDPctSpan}`;

      // (avg win/loss already computed above)

      if(dates.length>0){
        const minD = new Date(dates[0]); const maxD = new Date(dates[dates.length-1]);
        const daySpan = Math.floor((maxD - minD)/86400000) + 1;
        const months = new Set(dates.map(d=>d.slice(0,7)));
        const quarters = new Set(dates.map(d=>`${new Date(d).getFullYear()}-Q${Math.floor(new Date(d).getMonth()/3)+1}`));
        const years = new Set(dates.map(d=>new Date(d).getFullYear()));
        const activeDays = dates.length;
        const avgPerDay = activeDays>0 ? comp.totalTrades/activeDays : 0;
        $('#kpiDaySpan').textContent = daySpan;
        $('#kpiMonthSpan').textContent = months.size;
        $('#kpiQuarterSpan').textContent = quarters.size;
        $('#kpiYearSpan').textContent = years.size;
        $('#kpiAvgPerDay').textContent = fmt(avgPerDay,2);
      }else{
        $('#kpiDaySpan').textContent = 0; $('#kpiMonthSpan').textContent = 0; $('#kpiQuarterSpan').textContent = 0;
        $('#kpiYearSpan').textContent = 0; $('#kpiAvgPerDay').textContent = '0.00';
      }

      const ctx = $('#equityChart')?.getContext('2d');
      if(ctx && !equityChart){
        equityChart = new Chart(ctx,{
          type:'line',
          data:{labels:[], datasets:[{label:'Portfolio Value ($)', data:[], fill:true, tension:.15, borderWidth:2}]},
          options:{
            responsive:true, maintainAspectRatio:false,
            scales:{ x:{grid:{color:'#2b315d'}}, y:{grid:{color:'#2b315d'}, ticks:{callback:(v)=> `$${fmt(v,0)}`}}},
            plugins:{ legend:{labels:{color:'#cfd2e6'}}, tooltip:{callbacks:{label:(ctx)=>`$${fmt(ctx.parsed.y,2)}`}} }
          }
        });
      }
      if(equityChart){
        const grouped = groupSeries(comp.series, granularity, 'value');
        equityChart.data.labels = grouped.labels;
        equityChart.data.datasets[0].data = grouped.values;
        const perf = comp.netUSD;
        const color = perf>0?'#27be69':(perf<0?'#ff5a6b':'#ffc857');
        equityChart.data.datasets[0].borderColor = color;
        equityChart.data.datasets[0].backgroundColor = color+'22';
        equityChart.data.datasets[0].label = 'Portfolio Value ($)';
        equityChart.update();
      }
      $('#startEquity').textContent = `$${fmt(comp.start,2)}`;
      $('#currEquity').textContent = `$${fmt(comp.current,2)}`;
      $('#peakEquity').textContent = `$${fmt(Math.max(...comp.series.map(s=>s.value), comp.start),2)}`;
      const compChartDDDen = comp.peakAtMaxDD && comp.peakAtMaxDD>0 ? comp.peakAtMaxDD : start;
      const compChartDDPctStr = compChartDDDen>0 ? `${fmt(-(comp.maxDD/compChartDDDen*100),1)}%` : null;
      const compChartDDPctSpan = compChartDDPctStr ? ` <span class=\"pct\" style=\"color:var(--red)\">(${compChartDDPctStr})</span>` : '';
      $('#chartDD').innerHTML = `$${fmt(comp.maxDD,2)}${compChartDDPctSpan}`;

      // Periodic averages in compounding mode (based on daily USD change)
      const compSeriesDaily = comp.series.map(s=> ({date:s.date, val: s.delta || 0}));
      const compWeeks = {}; const compMonths = {};
      compSeriesDaily.forEach(d=>{
        const wk = `${new Date(d.date).getFullYear()}-W${String(weekKey(d.date)).padStart(2,'0')}`;
        compWeeks[wk] = (compWeeks[wk]||0) + d.val;
        const mo = d.date.slice(0,7); compMonths[mo] = (compMonths[mo]||0) + d.val;
      });
      const cDayAvg = compSeriesDaily.length? compSeriesDaily.reduce((a,b)=>a+b.val,0)/compSeriesDaily.length : 0;
      const cWeekAvg = Object.keys(compWeeks).length? Object.values(compWeeks).reduce((a,b)=>a+b,0)/Object.keys(compWeeks).length : 0;
      const cMonthAvg = Object.keys(compMonths).length? Object.values(compMonths).reduce((a,b)=>a+b,0)/Object.keys(compMonths).length : 0;
      $('#avgDaily').textContent = `$${fmt(cDayAvg,2)}`;
      $('#avgWeekly').textContent = `$${fmt(cWeekAvg,2)}`;
      $('#avgMonthly').textContent = `$${fmt(cMonthAvg,2)}`;

      // Profitable days/weeks/months (comp mode, USD)
      try{
        const dVals = (compSeriesDaily||[]).map(d=> d.val);
        const wkVals = Object.values(compWeeks||{});
        const moVals = Object.values(compMonths||{});
        const pDays = dVals.length? (dVals.filter(v=>v>0).length / dVals.length * 100) : 0;
        const pWeeks = wkVals.length? (wkVals.filter(v=>v>0).length / wkVals.length * 100) : 0;
        const pMonths = moVals.length? (moVals.filter(v=>v>0).length / moVals.length * 100) : 0;
        const pdEl = document.getElementById('kpiProfDays'); if(pdEl) pdEl.textContent = dVals.length? `${fmt(pDays,1)}%` : '—';
        const pwEl = document.getElementById('kpiProfWeeks'); if(pwEl) pwEl.textContent = wkVals.length? `${fmt(pWeeks,1)}%` : '—';
        const pmEl = document.getElementById('kpiProfMonths'); if(pmEl) pmEl.textContent = moVals.length? `${fmt(pMonths,1)}%` : '—';
      }catch(e){ /* noop */ }

      // Period Net bar chart (USD)
      try{
        const ctxW = document.getElementById('weeklyNetChart')?.getContext('2d');
        if(ctxW){
          const compQuarters = {};
          compSeriesDaily.forEach(d=>{
            const q = `${new Date(d.date).getFullYear()}-Q${Math.floor(new Date(d.date).getMonth()/3)+1}`;
            compQuarters[q] = (compQuarters[q]||0) + d.val;
          });
          const map = periodNetMode==='monthly' ? compMonths : (periodNetMode==='quarterly' ? compQuarters : compWeeks);
          const keys = Object.keys(map).sort();
          const vals = keys.map(k=> map[k]);
          if(weeklyNetChart){ weeklyNetChart.destroy(); }
          weeklyNetChart = new Chart(ctxW, {
            type:'bar',
            data:{ labels: keys, datasets:[{ label:'Net ($)', data: vals, backgroundColor: vals.map(v=> v>=0? '#27be6944':'#ff5a6b44'), borderColor: vals.map(v=> v>=0? '#27be69':'#ff5a6b'), borderWidth:1 }] },
            options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ x:{grid:{color:'#2b315d'}}, y:{grid:{color:'#2b315d'}, ticks:{callback:(v)=> `$${fmt(v,0)}`}} } }
          });
        }
      }catch(e){ /* noop */ }

    } else {
      const aggR = aggregateR(data);
      // Total trades incl. BE shown in brackets
      (function(){
        const totalIncl = Object.keys(data).reduce((a,d)=> a + ((data[d]?._events||[]).length), 0);
        const main = aggR.trades;
        const el = document.getElementById('kpiTrades');
        if(el) el.innerHTML = `${main} <span class="pct">(${totalIncl})</span>`;
      })();
      const netUSDFlat = aggR.netR * rValue;
      const netDisp = unitMode==='flat' ? `$${fmt(netUSDFlat,2)}` : `${fmt(aggR.netR,2)}R`;
      const expDisp = unitMode==='flat' ? `$${fmt(aggR.exp * rValue,2)}` : `${fmt(aggR.exp,2)}R`;
      const ddUSDFlat = aggR.maxDD * rValue;
      const flatNetPct = flatStart>0 ? (netUSDFlat/flatStart*100) : null;
      const flatNetPctStr = flatNetPct==null ? null : `${netUSDFlat>=0?'+':''}${fmt(flatNetPct,1)}%`;
      const flatNetPctSpan = unitMode==='flat' && flatNetPctStr ? ` <span class="pct" style="color:${netUSDFlat>=0?'var(--green)':'var(--red)'}">(${flatNetPctStr})</span>` : '';
      const flatDDDen = flatStart + (aggR.peakAtMaxDD||0)*rValue;
      const flatDDPctStr = flatDDDen>0 ? `${fmt(-(ddUSDFlat/flatDDDen*100),1)}%` : null;
      const ddDisp = unitMode==='flat' ? `$${fmt(ddUSDFlat,2)}` : `${fmt(aggR.maxDD,2)}R`;
      $('#kpiNet').innerHTML = unitMode==='flat' ? `${netDisp}${flatNetPctSpan}` : netDisp;
      $('#kpiWR').textContent = `${fmt(aggR.trades? (aggR.totalWins/aggR.trades*100):0,1)}%`;
      $('#kpiExp').textContent = expDisp;
      const flatDDPctSpan = unitMode==='flat' && flatDDPctStr ? ` <span class="pct" style="color:var(--red)">(${flatDDPctStr})</span>` : '';
      $('#kpiDD').innerHTML = unitMode==='flat' ? `${ddDisp}${flatDDPctSpan}` : ddDisp;

      if(dates.length>0){
        const minD = new Date(dates[0]); const maxD = new Date(dates[dates.length-1]);
        const daySpan = Math.floor((maxD - minD)/86400000) + 1;
        const months = new Set(dates.map(d=>d.slice(0,7)));
        const quarters = new Set(dates.map(d=>`${new Date(d).getFullYear()}-Q${Math.floor(new Date(d).getMonth()/3)+1}`));
        const years = new Set(dates.map(d=>new Date(d).getFullYear()));
        const activeDays = dates.length;
        const avgPerDay = activeDays>0 ? aggR.trades/activeDays : 0;
        $('#kpiDaySpan').textContent = daySpan; $('#kpiMonthSpan').textContent = months.size; $('#kpiQuarterSpan').textContent = quarters.size;
        $('#kpiYearSpan').textContent = years.size; $('#kpiAvgPerDay').textContent = fmt(avgPerDay,2);
      }else{
        $('#kpiDaySpan').textContent = 0; $('#kpiMonthSpan').textContent = 0; $('#kpiQuarterSpan').textContent = 0; 
        $('#kpiYearSpan').textContent = 0; $('#kpiAvgPerDay').textContent = '0.00';
      }

      const ctx = $('#equityChart')?.getContext('2d');
      if(ctx && !equityChart){
        equityChart = new Chart(ctx,{
          type:'line',
          data:{labels:[], datasets:[{label:'Cumulative Equity', data:[], fill:true, tension:.15, borderWidth:2}]},
          options:{
            responsive:true, maintainAspectRatio:false,
            scales:{ x:{grid:{color:'#2b315d'}}, y:{grid:{color:'#2b315d'}, ticks:{callback:(v)=> unitMode==='flat'? `$${fmt(v,0)}` : `${v}R`}}},
            plugins:{ legend:{labels:{color:'#cfd2e6'}}, tooltip:{callbacks:{label:(ctx)=> unitMode==='flat'? `$${fmt(ctx.parsed.y,2)}` : `${fmt(ctx.parsed.y,2)}R` }} }
          }
        });
      }
      if(equityChart){
        const grouped = groupSeries(aggR.dailySeries, granularity, 'value');
        const vals = unitMode==='flat' ? grouped.values.map(v=> v*rValue + flatStart) : grouped.values;
        equityChart.data.labels = grouped.labels;
        equityChart.data.datasets[0].data = vals;
        const color = aggR.netR>0?'#27be69':(aggR.netR<0?'#ff5a6b':'#ffc857');
        equityChart.data.datasets[0].borderColor = color;
        equityChart.data.datasets[0].backgroundColor = color+'22';
        equityChart.data.datasets[0].label = unitMode==='flat' ? 'Cumulative Equity ($)' : 'Cumulative Equity (R)';
        equityChart.update();
      }
      // Drawdown Over Time (in R)
      try{
        const ddLabels = [];
        const ddValues = [];
        let peak = 0;
        (aggR.dailySeries||[]).forEach(pt=>{
          peak = Math.max(peak, pt.value||0);
          const dd = (pt.value||0) - peak; // <= 0
          ddLabels.push(dispDate(pt.date));
          ddValues.push(dd);
        });
        const ctxDD = document.getElementById('ddTimeChart')?.getContext('2d');
        if(ctxDD){
          if(ddTimeChart){ ddTimeChart.destroy(); }
          ddTimeChart = new Chart(ctxDD, {
            type:'line',
            data:{ labels: ddLabels, datasets:[{ label:'Drawdown (R)', data: ddValues, borderColor:'#ff5a6b', backgroundColor:'#ff5a6b33', fill:true, tension:.15, pointRadius:0, borderWidth:2 }] },
            options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ x:{grid:{color:'#2b315d'}}, y:{grid:{color:'#2b315d'}, title:{display:true, text:'Drawdown (R)'} } } }
          });
        }
      }catch(e){ /* noop */ }
      $('#startEquity').textContent = unitMode==='flat' ? `$${fmt(flatStart,2)}` : `${fmt(0,2)}R`;
      const totalEquity = (aggregateR(data).dailySeries.slice(-1)[0]?.value)||0;
      const peak = (()=>{ let p=0; aggregateR(data).dailySeries.forEach(pt=>{ p=Math.max(p,pt.value); }); return p; })();
      $('#currEquity').textContent = unitMode==='flat' ? `$${fmt(flatStart + totalEquity*rValue,2)}` : `${fmt(totalEquity,2)}R`;
      $('#peakEquity').textContent = unitMode==='flat' ? `$${fmt(flatStart + peak*rValue,2)}` : `${fmt(peak,2)}R`;
      const ddChartUSDFlat = aggR.maxDD*rValue;
      const ddChartDenFlat = flatStart + (aggR.peakAtMaxDD||0)*rValue;
      const ddChartPctFlatStr = ddChartDenFlat>0 ? `${fmt(-(ddChartUSDFlat/ddChartDenFlat*100),1)}%` : null;
      const ddChartPctFlatSpan = unitMode==='flat' && ddChartPctFlatStr ? ` <span class=\"pct\" style=\"color:var(--red)\">(${ddChartPctFlatStr})</span>` : '';
      $('#chartDD').innerHTML = unitMode==='flat' ? `$${fmt(ddChartUSDFlat,2)}${ddChartPctFlatSpan}` : `${fmt(aggR.maxDD,2)}R`;

      // Periodic averages in R / $ flat mode
      const dSeries = dates.map(d=>{
        let r=0; (data[d]._events||[]).forEach(ev=>{ r += eventR(ev); });
        return {date:d, val:r};
      });
      const wkMap = {}; const moMap = {};
      dSeries.forEach(x=>{
        const wk = `${new Date(x.date).getFullYear()}-W${String(weekKey(x.date)).padStart(2,'0')}`;
        wkMap[wk] = (wkMap[wk]||0) + x.val;
        const mo = x.date.slice(0,7); moMap[mo] = (moMap[mo]||0) + x.val;
      });
      const dAvg = dSeries.length? dSeries.reduce((a,b)=>a+b.val,0)/dSeries.length : 0;
      const wAvg = Object.keys(wkMap).length? Object.values(wkMap).reduce((a,b)=>a+b,0)/Object.keys(wkMap).length : 0;
      const mAvg = Object.keys(moMap).length? Object.values(moMap).reduce((a,b)=>a+b,0)/Object.keys(moMap).length : 0;
      if(unitMode==='flat'){
        $('#avgDaily').textContent = `$${fmt(dAvg*rValue,2)}`;
        $('#avgWeekly').textContent = `$${fmt(wAvg*rValue,2)}`;
        $('#avgMonthly').textContent = `$${fmt(mAvg*rValue,2)}`;
      }else{
        $('#avgDaily').textContent = `${fmt(dAvg,2)}R`;
        $('#avgWeekly').textContent = `${fmt(wAvg,2)}R`;
        $('#avgMonthly').textContent = `${fmt(mAvg,2)}R`;
      }

      // Profitable days/weeks/months (R or $ flat)
      try{
        const dVals = (dSeries||[]).map(x=> x.val);
        const wkVals = Object.values(wkMap||{});
        const moVals = Object.values(moMap||{});
        const pDays = dVals.length? (dVals.filter(v=>v>0).length / dVals.length * 100) : 0;
        const pWeeks = wkVals.length? (wkVals.filter(v=>v>0).length / wkVals.length * 100) : 0;
        const pMonths = moVals.length? (moVals.filter(v=>v>0).length / moVals.length * 100) : 0;
        const pdEl = document.getElementById('kpiProfDays'); if(pdEl) pdEl.textContent = dVals.length? `${fmt(pDays,1)}%` : '—';
        const pwEl = document.getElementById('kpiProfWeeks'); if(pwEl) pwEl.textContent = wkVals.length? `${fmt(pWeeks,1)}%` : '—';
        const pmEl = document.getElementById('kpiProfMonths'); if(pmEl) pmEl.textContent = moVals.length? `${fmt(pMonths,1)}%` : '—';
      }catch(e){ /* noop */ }

      // Period Net bar chart (R or $ flat)
      try{
        const ctxW = document.getElementById('weeklyNetChart')?.getContext('2d');
        if(ctxW){
          const qMap = {};
          dSeries.forEach(x=>{
            const q = `${new Date(x.date).getFullYear()}-Q${Math.floor(new Date(x.date).getMonth()/3)+1}`;
            qMap[q] = (qMap[q]||0) + x.val;
          });
          const map = periodNetMode==='monthly' ? moMap : (periodNetMode==='quarterly' ? qMap : wkMap);
          const keys = Object.keys(map).sort();
          const valsR = keys.map(k=> map[k]);
          const vals = unitMode==='flat' ? valsR.map(v=> v*rValue) : valsR;
          if(weeklyNetChart){ weeklyNetChart.destroy(); }
          weeklyNetChart = new Chart(ctxW, {
            type:'bar',
            data:{ labels: keys, datasets:[{ label: unitMode==='flat'? 'Net ($)' : 'Net (R)', data: vals, backgroundColor: vals.map(v=> v>=0? '#27be6944':'#ff5a6b44'), borderColor: vals.map(v=> v>=0? '#27be69':'#ff5a6b'), borderWidth:1 }] },
            options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ x:{grid:{color:'#2b315d'}}, y:{grid:{color:'#2b315d'}, ticks:{callback:(v)=> unitMode==='flat'? `$${fmt(v,0)}` : `${v}R`}} } }
          });
        }
      }catch(e){ /* noop */ }
    }

    // Breakeven analysis
    try{
      const rowsAll = flatTrades.slice();
      const totalAll = rowsAll.length;
      const beRows = rowsAll.filter(r=> r.outcome==='B');
      const beCount = beRows.length;
      const beRate = totalAll>0 ? beCount/totalAll*100 : 0;
      const beTradesEl = document.getElementById('kpiBETrades'); if(beTradesEl) beTradesEl.textContent = String(beCount);
      const beRateEl = document.getElementById('kpiBERate'); if(beRateEl) beRateEl.textContent = totalAll>0 ? `${fmt(beRate,1)}%` : '—';

      // BE by setup
      const bySetup = {};
      rowsAll.forEach(r=>{
        const k = r.setup || '—';
        if(!bySetup[k]) bySetup[k] = {be:0, total:0};
        bySetup[k].total++;
        if(r.outcome==='B') bySetup[k].be++;
      });
      const beSetupBody = document.getElementById('beSetupBody');
      if(beSetupBody){
        beSetupBody.innerHTML='';
        const rows = Object.keys(bySetup).map(k=> ({setup:k, ...bySetup[k], ber: bySetup[k].total>0 ? bySetup[k].be/bySetup[k].total*100 : 0}))
          .sort((a,b)=> b.be - a.be);
        if(rows.length===0){ beSetupBody.innerHTML = `<tr><td colspan="4" class="muted" style="text-align:center">No data</td></tr>`; }
        else{
          rows.forEach(r=>{
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${r.setup}</td>
              <td>${r.be}</td>
              <td>${fmt(r.ber,1)}%</td>
              <td>${r.total}</td>`;
            beSetupBody.appendChild(tr);
          });
        }
        // Top BE setup KPI
        const top = rows.find(x=> x.be>0);
        const topEl = document.getElementById('kpiBETopSetup'); if(topEl) topEl.textContent = top ? `${top.setup} (${top.be})` : '—';
      }

      // BE by tag
      const byTag = {};
      rowsAll.forEach(r=>{
        const tags = Array.isArray(r.tags) ? r.tags : [];
        tags.forEach(t=>{
          if(!byTag[t]) byTag[t] = {be:0, total:0};
          byTag[t].total++;
          if(r.outcome==='B') byTag[t].be++;
        });
      });
      const beTagBody = document.getElementById('beTagBody');
      if(beTagBody){
        beTagBody.innerHTML='';
        const rows = Object.keys(byTag).map(tag=> ({tag, ...byTag[tag], ber: byTag[tag].total>0 ? byTag[tag].be/byTag[tag].total*100 : 0}))
          .sort((a,b)=> b.be - a.be).slice(0,50);
        if(rows.length===0){ beTagBody.innerHTML = `<tr><td colspan="4" class="muted" style="text-align:center">No tags</td></tr>`; }
        else{
          rows.forEach(r=>{
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${r.tag}</td>
              <td>${r.be}</td>
              <td>${fmt(r.ber,1)}%</td>
              <td>${r.total}</td>`;
            beTagBody.appendChild(tr);
          });
        }
      }

      // BE Trend (monthly BE %)
      try{
        const mo = {};
        rowsAll.forEach(r=>{
          const m = (r.date||'').slice(0,7);
          if(!m) return;
          if(!mo[m]) mo[m] = {be:0, total:0};
          mo[m].total++;
          if(r.outcome==='B') mo[m].be++;
        });
        const keys = Object.keys(mo).sort();
        const labels = keys.map(k=> k.replace('-', '/'));
        const vals = keys.map(k=> mo[k].total>0 ? +(mo[k].be/mo[k].total*100).toFixed(2) : 0);
        const ctx = document.getElementById('beTrendChart')?.getContext('2d');
        if(ctx){
          if(beTrendChart){ beTrendChart.destroy(); }
          beTrendChart = new Chart(ctx, {
            type:'line',
            data:{ labels, datasets:[{ label:'BE %', data: vals, borderColor:'#ffc857', backgroundColor:'#ffc85722', fill:true, tension:.15, borderWidth:2, pointRadius:0 }] },
            options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ x:{grid:{color:'#2b315d'}}, y:{min:0, max:100, ticks:{callback:(v)=> `${v}%`}, grid:{color:'#2b315d'}} } }
          });
        }
      }catch(e){ /* noop */ }
    }catch(e){ /* noop */ }

    // Setup cards
    const container = $('#setupCards'); container.innerHTML='';
    const statsBySetup = {};
    for(const d of dates){
      for(const ev of (data[d]._events||[])){
        const k = ev.setup;
        if(!statsBySetup[k]) statsBySetup[k]={wins:0, losses:0, net:0};
        const val = eventR(ev);
        const outcome = effectiveOutcome(ev);
        if(outcome==='W') statsBySetup[k].wins++; else if(outcome==='L') statsBySetup[k].losses++;
        statsBySetup[k].net += val;
      }
    }
    const orderedSetups = Array.from(new Set([...(SETUPS||[]), ...Object.keys(statsBySetup)]));
    orderedSetups.forEach(s=>{
      const st = statsBySetup[s] || {wins:0, losses:0, net:0};
      const t = st.wins + st.losses; if(t===0) return;
      const r = st.net;
      const wr = t? (st.wins/t*100):0;
      const exp = t? (r/t) : 0;
      const valueMain = unitMode==='flat' ? `$${fmt(r*rValue,2)}` : `${fmt(r,2)}R`;
      const card = document.createElement('div');
      card.className='kpi';
      card.innerHTML = `
        <div class="label">${s}</div>
        <div class="value">${valueMain}</div>
        <div class="muted" style="margin-top:6px">Trades: <b>${t}</b> • Win%: <b>${fmt(wr,1)}%</b> • Exp: <b>${unitMode==='flat'? `$${fmt(exp*rValue,2)}` : `${fmt(exp,2)}R`}</b></div>`;
      container.appendChild(card);
    });
    if(container.children.length===0){ container.innerHTML = `<div class="muted">No setup data in the selected range.</div>`; }

    // Tag Performance table
    const tagBody = document.getElementById('tagPerfBody');
    if(tagBody){
      tagBody.innerHTML='';
      const tagMap = {};
      dates.forEach(d=>{
        (data[d]._events||[]).forEach(ev=>{
          const tags = Array.isArray(ev.tags)? ev.tags : [];
          if(tags.length===0) return;
          const rw = Number(ev.rewardR ?? 2); const rl = Number(ev.riskR ?? 1);
          const val = eventR(ev);
          tags.forEach(t=>{
            if(!tagMap[t]) tagMap[t] = {wins:0, losses:0, net:0};
            if(val>0) tagMap[t].wins++; else if(val<0) tagMap[t].losses++;
            tagMap[t].net += val;
          });
        });
      });
      const rows = Object.keys(tagMap).map(tag=>{
        const w=tagMap[tag].wins||0, l=tagMap[tag].losses||0; const t=w+l; const wr=t? w/t*100:0; const exp=t? tagMap[tag].net/t:0;
        return {tag, trades:t, net:tagMap[tag].net, wr, exp};
      }).sort((a,b)=> b.trades - a.trades).slice(0,50);
      if(rows.length===0){ tagBody.innerHTML = `<tr><td colspan="5" class="muted" style="text-align:center">No tags</td></tr>`; }
      else{
        rows.forEach(r=>{
          const netDisp = unitMode==='flat' ? `$${fmt(r.net*rValue,2)}` : `${fmt(r.net,2)}R`;
          const expDisp = unitMode==='flat' ? `$${fmt(r.exp*rValue,2)}` : `${fmt(r.exp,2)}R`;
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${r.tag}</td>
            <td>${r.trades}</td>
            <td style="color:${r.net>0?'var(--green)':r.net<0?'var(--red)':'var(--amber)'}">${netDisp}</td>
            <td>${fmt(r.wr,1)}%</td>
            <td style="color:${r.exp>0?'var(--green)':r.exp<0?'var(--red)':'var(--amber)'}">${expDisp}</td>`;
          tagBody.appendChild(tr);
        });
      }
    }

    // Daily outcomes
    let win=0, lose=0, be=0;
    dates.forEach(d=>{
      const dr = (data[d]._events||[]).reduce((acc,ev)=>{
        const rw = Number(ev.rewardR ?? 2); const rl = Number(ev.riskR ?? 1);
        return acc + eventR(ev);
      }, 0);
      if(dr>0) win++; else if(dr<0) lose++; else be++;
    });
    const totalDays = dates.length || 1;
    $('#winDays').textContent = `${win} (${fmt(win/totalDays*100,1)}%)`;
    $('#loseDays').textContent = `${lose} (${fmt(lose/totalDays*100,1)}%)`;
    $('#beDays').textContent = `${be} (${fmt(be/totalDays*100,1)}%)`;

    // Monthly table
    const mBody = $('#monthlyBody'); mBody.innerHTML='';
    const monthly = {};
    dates.forEach(d=>{
      const m = d.slice(0,7);
      if(!monthly[m]) monthly[m]={wins:0, losses:0, cum:0, peak:0, dd:0};
      let dr=0;
      (data[d]._events||[]).forEach(ev=>{
        const outcome = effectiveOutcome(ev);
        if(outcome==='W'){ monthly[m].wins++; }
        else if(outcome==='L'){ monthly[m].losses++; }
        dr += eventR(ev);
      });
      monthly[m].cum += dr;
      monthly[m].peak = Math.max(monthly[m].peak, monthly[m].cum);
      monthly[m].dd = Math.max(monthly[m].dd, monthly[m].peak - monthly[m].cum);
    });
    const monthsKeys = Object.keys(monthly).sort();
    if(monthsKeys.length===0){
      mBody.innerHTML = `<tr><td colspan="6" class="muted" style="text-align:center">No data</td></tr>`;
    }else{
      monthsKeys.forEach(m=>{
        const x = monthly[m];
        const trades = x.wins + x.losses;
        const net = x.cum; // monthly cum already sums net R
        const wr = trades? (x.wins/trades*100):0;
        const exp = trades? (net/trades) : 0;
        const netDisp = unitMode==='flat' ? `$${fmt(net*rValue,2)}` : `${fmt(net,2)}R`;
        const expDisp = unitMode==='flat' ? `$${fmt(exp*rValue,2)}` : `${fmt(exp,2)}R`;
        const ddDisp = unitMode==='flat' ? `$${fmt(x.dd*rValue,2)}` : `${fmt(x.dd,2)}R`;
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${m.replace('-','/')}</td>
          <td>${trades}</td>
          <td style="color:${net>0?'var(--green)':net<0?'var(--red)':'var(--amber)'}">${netDisp}</td>
          <td>${fmt(wr,1)}%</td>
          <td style="color:${exp>0?'var(--green)':exp<0?'var(--red)':'var(--amber)'}">${expDisp}</td>
          <td style="color:var(--red)">${ddDisp}</td>`;
        mBody.appendChild(tr);
      });
    }

    // Weekday performance (Mon–Fri)
    const wBody = $('#weekdayBody');
    if(wBody){
      wBody.innerHTML='';
      const wdAgg = {1:{wins:0,losses:0,net:0},2:{wins:0,losses:0,net:0},3:{wins:0,losses:0,net:0},4:{wins:0,losses:0,net:0},5:{wins:0,losses:0,net:0}};
      dates.forEach(d=>{
        const wd = new Date(d).getUTCDay(); // 0=Sun..6=Sat
        if(wd<1 || wd>5) return; // only Mon-Fri
        (data[d]._events||[]).forEach(ev=>{
          const outcome = effectiveOutcome(ev);
          if(outcome==='W'){ wdAgg[wd].wins++; }
          else if(outcome==='L'){ wdAgg[wd].losses++; }
          wdAgg[wd].net += eventR(ev);
        });
      });
      const wdNames = {1:'Monday',2:'Tuesday',3:'Wednesday',4:'Thursday',5:'Friday'};
      // Apply toggle state to UI and render
      const wSeg = document.getElementById('weekdayViewSeg');
      if(wSeg){ wSeg.querySelectorAll('button').forEach(b=> b.classList.toggle('active', b.getAttribute('data-view')===weekdayViewMode)); }
      const wTableWrap = document.getElementById('weekdayTableWrap');
      const wChartWrap = document.getElementById('weekdayChartWrap');
      if(weekdayViewMode==='chart'){
        if(wTableWrap) wTableWrap.style.display='none';
        if(wChartWrap) wChartWrap.style.display='block';
        const labels = [1,2,3,4,5].map(k=> wdNames[k]);
        const valsR = [1,2,3,4,5].map(k=>{ const t=(wdAgg[k].wins+wdAgg[k].losses); return t? (wdAgg[k].net/t) : 0; });
        const vals = unitMode==='flat' ? valsR.map(x=> x*rValue) : valsR;
        const bg = valsR.map(v=> v>0? '#35cc7a99' : v<0? '#ff5a6b99' : '#ffc85799');
        const border = valsR.map(v=> v>0? '#35cc7a' : v<0? '#ff5a6b' : '#ffc857');
        const ctx = document.getElementById('weekdayNetChart')?.getContext('2d');
        if(ctx){
          if(weekdayNetBarChart){ weekdayNetBarChart.destroy(); weekdayNetBarChart=null; }
          weekdayNetBarChart = new Chart(ctx, {
            type:'bar',
            data:{ labels, datasets:[{ label: (unitMode==='flat'? 'Expectancy ($/trade)' : 'Expectancy (R/trade)'), data: vals, backgroundColor:bg, borderColor:border, borderWidth:1 }] },
            options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ x:{grid:{color:'#2b315d'}}, y:{grid:{color:'#2b315d'}, ticks:{callback:(v)=> unitMode==='flat' ? `$${fmt(v,2)}` : `${fmt(v,2)}R`}} } }
          });
        }
      }else{
        if(wChartWrap) wChartWrap.style.display='none';
        if(wTableWrap) wTableWrap.style.display='block';
        if(weekdayNetBarChart){ weekdayNetBarChart.destroy(); weekdayNetBarChart=null; }
        [1,2,3,4,5].forEach(k=>{
          const x = wdAgg[k];
          const trades = x.wins + x.losses;
          const net = x.net;
          const wr = trades? (x.wins/trades*100):0;
          const exp = trades? (net/trades):0;
          const netDisp = unitMode==='flat' ? `$${fmt(net*rValue,2)}` : `${fmt(net,2)}R`;
          const expDisp = unitMode==='flat' ? `$${fmt(exp*rValue,2)}` : `${fmt(exp,2)}R`;
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${wdNames[k]}</td>
            <td>${trades}</td>
            <td style="color:${net>0?'var(--green)':net<0?'var(--red)':'var(--amber)'}">${netDisp}</td>
            <td>${fmt(wr,1)}%</td>
            <td style="color:${exp>0?'var(--green)':exp<0?'var(--red)':'var(--amber)'}">${expDisp}</td>`;
          wBody.appendChild(tr);
        });
      }
    }

    // Calendar month-of-year performance (Jan–Dec across years)
    const cmBody = $('#calMonthBody');
    if(cmBody){
      cmBody.innerHTML='';
      const names = ['January','February','March','April','May','June','July','August','September','October','November','December'];
      const moAgg = { 1:{wins:0,losses:0,net:0},2:{wins:0,losses:0,net:0},3:{wins:0,losses:0,net:0},4:{wins:0,losses:0,net:0},5:{wins:0,losses:0,net:0},6:{wins:0,losses:0,net:0},7:{wins:0,losses:0,net:0},8:{wins:0,losses:0,net:0},9:{wins:0,losses:0,net:0},10:{wins:0,losses:0,net:0},11:{wins:0,losses:0,net:0},12:{wins:0,losses:0,net:0} };
      dates.forEach(d=>{
        const mm = parseInt(d.slice(5,7), 10); // 1..12
        if(!Number.isFinite(mm) || mm<1 || mm>12) return;
        (data[d]._events||[]).forEach(ev=>{
          const outcome = effectiveOutcome(ev);
          if(outcome==='W'){ moAgg[mm].wins++; }
          else if(outcome==='L'){ moAgg[mm].losses++; }
          moAgg[mm].net += eventR(ev);
        });
      });
      // Apply toggle state to UI and render
      const cSeg = document.getElementById('calMonthViewSeg');
      if(cSeg){ cSeg.querySelectorAll('button').forEach(b=> b.classList.toggle('active', b.getAttribute('data-view')===calMonthViewMode)); }
      const cTableWrap = document.getElementById('calMonthTableWrap');
      const cChartWrap = document.getElementById('calMonthChartWrap');
      if(calMonthViewMode==='chart'){
        if(cTableWrap) cTableWrap.style.display='none';
        if(cChartWrap) cChartWrap.style.display='block';
        const labels = names;
        const valsR = Array.from({length:12}, (_,i)=>{ const k=i+1; const t=(moAgg[k].wins+moAgg[k].losses); return t? (moAgg[k].net/t) : 0; });
        const vals = unitMode==='flat' ? valsR.map(x=> x*rValue) : valsR;
        const bg = valsR.map(v=> v>0? '#35cc7a99' : v<0? '#ff5a6b99' : '#ffc85799');
        const border = valsR.map(v=> v>0? '#35cc7a' : v<0? '#ff5a6b' : '#ffc857');
        const ctx = document.getElementById('calMonthNetChart')?.getContext('2d');
        if(ctx){
          if(calMonthNetBarChart){ calMonthNetBarChart.destroy(); calMonthNetBarChart=null; }
          calMonthNetBarChart = new Chart(ctx, {
            type:'bar',
            data:{ labels, datasets:[{ label: (unitMode==='flat'? 'Expectancy ($/trade)' : 'Expectancy (R/trade)'), data: vals, backgroundColor:bg, borderColor:border, borderWidth:1 }] },
            options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ x:{grid:{color:'#2b315d'}}, y:{grid:{color:'#2b315d'}, ticks:{callback:(v)=> unitMode==='flat' ? `$${fmt(v,2)}` : `${fmt(v,2)}R`}} } }
          });
        }
      }else{
        if(cChartWrap) cChartWrap.style.display='none';
        if(cTableWrap) cTableWrap.style.display='block';
        if(calMonthNetBarChart){ calMonthNetBarChart.destroy(); calMonthNetBarChart=null; }
        for(let m=1;m<=12;m++){
          const x = moAgg[m];
          const trades = x.wins + x.losses;
          const net = x.net;
          const wr = trades? (x.wins/trades*100):0;
          const exp = trades? (net/trades):0;
          const netDisp = unitMode==='flat' ? `$${fmt(net*rValue,2)}` : `${fmt(net,2)}R`;
          const expDisp = unitMode==='flat' ? `$${fmt(exp*rValue,2)}` : `${fmt(exp,2)}R`;
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${names[m-1]}</td>
            <td>${trades}</td>
            <td style="color:${net>0?'var(--green)':net<0?'var(--red)':'var(--amber)'}">${netDisp}</td>
            <td>${fmt(wr,1)}%</td>
            <td style="color:${exp>0?'var(--green)':exp<0?'var(--red)':'var(--amber)'}">${expDisp}</td>`;
          cmBody.appendChild(tr);
        }
      }
    }

    // Quarterly performance (Q1–Q4 across years)
    const qBody = $('#quarterBody');
    if(qBody){
      qBody.innerHTML='';
      const qNames = {1:'Q1',2:'Q2',3:'Q3',4:'Q4'};
      const qAgg = { 1:{wins:0,losses:0,net:0}, 2:{wins:0,losses:0,net:0}, 3:{wins:0,losses:0,net:0}, 4:{wins:0,losses:0,net:0} };
      dates.forEach(d=>{
        const mm = parseInt(d.slice(5,7), 10);
        if(!Number.isFinite(mm)) return;
        const q = mm<=3?1 : mm<=6?2 : mm<=9?3 : 4;
        (data[d]._events||[]).forEach(ev=>{
          const outcome = effectiveOutcome(ev);
          if(outcome==='W'){ qAgg[q].wins++; }
          else if(outcome==='L'){ qAgg[q].losses++; }
          qAgg[q].net += eventR(ev);
        });
      });
      // Apply toggle state to UI
      const qSeg = document.getElementById('quarterViewSeg');
      if(qSeg){ qSeg.querySelectorAll('button').forEach(b=> b.classList.toggle('active', b.getAttribute('data-view')===quarterViewMode)); }
      const qTableWrap = document.getElementById('quarterTableWrap');
      const qChartWrap = document.getElementById('quarterChartWrap');
      if(quarterViewMode==='chart'){
        if(qTableWrap) qTableWrap.style.display='none';
        if(qChartWrap) qChartWrap.style.display='block';
        const labels = [1,2,3,4].map(k=> qNames[k]);
        const valsR = [1,2,3,4].map(k=>{ const t=(qAgg[k].wins+qAgg[k].losses); return t? (qAgg[k].net/t) : 0; });
        const vals = unitMode==='flat' ? valsR.map(x=> x*rValue) : valsR;
        const bg = valsR.map(v=> v>0? '#35cc7a99' : v<0? '#ff5a6b99' : '#ffc85799');
        const border = valsR.map(v=> v>0? '#35cc7a' : v<0? '#ff5a6b' : '#ffc857');
        const ctx = document.getElementById('quarterNetChart')?.getContext('2d');
        if(ctx){
          if(quarterNetBarChart){ quarterNetBarChart.destroy(); quarterNetBarChart=null; }
          quarterNetBarChart = new Chart(ctx, {
            type:'bar',
            data:{ labels, datasets:[{ label: (unitMode==='flat'? 'Expectancy ($/trade)' : 'Expectancy (R/trade)'), data: vals, backgroundColor:bg, borderColor:border, borderWidth:1 }] },
            options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ x:{grid:{color:'#2b315d'}}, y:{grid:{color:'#2b315d'}, ticks:{callback:(v)=> unitMode==='flat' ? `$${fmt(v,2)}` : `${fmt(v,2)}R`}} } }
          });
        }
      } else {
        if(qChartWrap) qChartWrap.style.display='none';
        if(qTableWrap) qTableWrap.style.display='block';
        if(quarterNetBarChart){ quarterNetBarChart.destroy(); quarterNetBarChart=null; }
        [1,2,3,4].forEach(k=>{
          const x = qAgg[k];
          const trades = x.wins + x.losses;
          const net = x.net;
          const wr = trades? (x.wins/trades*100):0;
          const exp = trades? (net/trades):0;
          const netDisp = unitMode==='flat' ? `$${fmt(net*rValue,2)}` : `${fmt(net,2)}R`;
          const expDisp = unitMode==='flat' ? `$${fmt(exp*rValue,2)}` : `${fmt(exp,2)}R`;
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${qNames[k]}</td>
            <td>${trades}</td>
            <td style=\"color:${net>0?'var(--green)':net<0?'var(--red)':'var(--amber)'}\">${netDisp}</td>
            <td>${fmt(wr,1)}%</td>
            <td style=\"color:${exp>0?'var(--green)':exp<0?'var(--red)':'var(--amber)'}\">${expDisp}</td>`;
          qBody.appendChild(tr);
        });
      }
    }

    renderTopDrawdowns(flatTrades);

    // Losing streaks
    const tbody = $('#streakBody'); tbody.innerHTML='';
    const freq = computeLosingTradeStreaks(data);
    const keys = Object.keys(freq).map(n=>+n).sort((a,b)=>a-b);
    if(keys.length===0){
      tbody.innerHTML = `<tr><td colspan="2" class="muted" style="text-align:center">No losing streaks of 2+ trades</td></tr>`;
    }else{
      keys.forEach(k=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${k}</td><td>${freq[k]}</td>`;
        tbody.appendChild(tr);
      });
    }
  }

  function computeLosingTradeStreaks(dataObj){
    const seq = buildTradeSequence(dataObj).map(x=> x>0 ? 'W':'L');
    const freq = {}; let cur=0;
    seq.forEach(out=>{
      if(out==='L'){ cur++; } else { if(cur>=2){ freq[cur]=(freq[cur]||0)+1; } cur=0; }
    });
    if(cur>=2){ freq[cur]=(freq[cur]||0)+1; }
    return freq;
  }

  function renderTopDrawdowns(trades){
    const container = document.getElementById('topDrawdownBody');
    if(!container) return;
    container.innerHTML = '';
    const drawdowns = computeTopDrawdowns(trades);
    if(drawdowns.length===0){
      container.innerHTML = `<div class="muted">Not enough trade history to calculate drawdowns.</div>`;
      return;
    }
    drawdowns.forEach((dd, idx)=>{
      const peakLabel = dd.peakDate ? dispDate(dd.peakDate) : '—';
      const endRaw = dd.recoveryDate || dd.troughDate;
      const endLabel = endRaw ? dispDate(endRaw) : '—';
      const spanLabel = `${peakLabel} → ${endLabel}${dd.recoveryDate ? '' : ' (open)'}`;
      const spanDaysLabel = dd.spanDays != null ? `${dd.spanDays} day${dd.spanDays===1?'':'s'}` : '—';
      const dropDaysLabel = dd.dropDays != null ? `${dd.dropDays} day${dd.dropDays===1?'':'s'}` : '—';
      const dropRangeLabel = dd.peakDate && dd.troughDate ? `${dispDate(dd.peakDate)} → ${dispDate(dd.troughDate)}` : '—';
      const recoveryDaysLabel = dd.recoveryDate ? `${dd.recoveryDays} day${dd.recoveryDays===1?'':'s'}` : '—';
      const recoveryRangeLabel = dd.recoveryDate ? `${dispDate(dd.troughDate)} → ${dispDate(dd.recoveryDate)}` : 'Pending recovery';
      const dropTradesLabel = `${dd.dropTrades} trade${dd.dropTrades===1?'':'s'}`;
      const dropDecisive = dd.dropWins + dd.dropLosses;
      const dropRecordLabel = dropDecisive>0 ? `${dd.dropWins}W / ${dd.dropLosses}L` : 'No wins or losses';
      const recoveryTradesLabel = dd.recoveryDate ? `${dd.recoveryTrades} trade${dd.recoveryTrades===1?'':'s'}` : '—';
      const dropWinRateLabel = formatWinRate(dd.dropWinRate);
      const percentLabel = formatDrawdownPercent(dd.percentDrop);
      const setupTiles = dd.setupStats.length
        ? dd.setupStats.slice(0,6).map(s=>{
            const setupWin = formatWinRate(s.winRate);
            const tradesText = `${s.trades} trade${s.trades===1?'':'s'}`;
            return `<div class="dd-setup"><div style="font-weight:600">${s.setup}</div><div class="dd-muted">${tradesText}</div><div class="dd-muted">Win ${setupWin}</div></div>`;
          }).join('')
        : `<div class="dd-muted">No trades in this window.</div>`;

      const card = document.createElement('div');
      card.className = 'dd-card';
      card.innerHTML = `
        <div class="dd-summary">
          <div class="dd-rank">#${idx+1}</div>
          <div>
            <div class="dd-metric">${formatDrawdownValue(dd.magnitude)}</div>
            <div class="dd-muted">${spanLabel}</div>
          </div>
          <div class="dd-pill">Span: ${spanDaysLabel}</div>
          <div class="dd-pill">Drop: ${percentLabel}</div>
          <div class="dd-pill">Drop trades: ${dropTradesLabel}</div>
          <div class="dd-pill">Recovery trades: ${dd.recoveryDate ? recoveryTradesLabel : '—'}</div>
        </div>
        <div class="dd-meta-grid">
          <div>
            <div class="dd-muted">Total span</div>
            <div class="dd-metric">${spanDaysLabel}</div>
            <div class="dd-muted">${spanLabel}</div>
          </div>
          <div>
            <div class="dd-muted">Drop duration</div>
            <div class="dd-metric">${dropDaysLabel}</div>
            <div class="dd-muted">${dropRangeLabel}</div>
          </div>
          <div>
            <div class="dd-muted">Recovery from trough</div>
            <div class="dd-metric">${dd.recoveryDate ? recoveryDaysLabel : '—'}</div>
            <div class="dd-muted">${recoveryRangeLabel}</div>
          </div>
          <div>
            <div class="dd-muted">Drop win rate</div>
            <div class="dd-metric">${dropWinRateLabel}</div>
            <div class="dd-muted">${dropRecordLabel}</div>
          </div>
        </div>
        <div class="dd-setup-grid" style="margin-top:12px">
          ${setupTiles}
        </div>`;
      container.appendChild(card);
    });
  }

  function computeTopDrawdowns(trades){
    if(!Array.isArray(trades) || trades.length===0) return [];
    const series = buildEquitySeriesForDrawdowns(trades);
    if(series.length===0) return [];
    const initialValue = unitMode==='comp'
      ? (compStart>0 ? compStart : 100000)
      : (unitMode==='compSteps'
        ? (compStepStart>0 ? compStepStart : 100000)
        : (unitMode==='compDaily'
          ? (compDailyStart>0 ? compDailyStart : 100000)
          : (unitMode==='flat' ? (flatStart || 0) : 0)));
    let peakValue = initialValue;
    let peakIndex = -1;
    let peakDate = trades.length ? trades[0].date : null;
    const results = [];
    let active = null;
    const EPS = 1e-9;

    series.forEach((node, idx)=>{
      const val = Number(node.value) || 0;
      const date = node.date;
      if(val >= peakValue - EPS){
        if(active && val >= active.peakValue - EPS){
          active.recoveryIndex = idx;
          active.recoveryDate = date;
          const finalized = finalizeDrawdownRecord(active, trades);
          if(finalized) results.push(finalized);
          active = null;
        }
        if(val > peakValue + EPS){
          peakValue = val;
          peakIndex = idx;
          peakDate = date;
        } else if(Math.abs(val - peakValue) <= EPS){
          peakIndex = idx;
          peakDate = date;
        }
      } else {
        if(!active){
          active = {
            peakValue,
            peakIndex,
            peakDate,
            startIndex: idx,
            startDate: date,
            troughValue: val,
            troughIndex: idx,
            troughDate: date
          };
        } else if(val < active.troughValue){
          active.troughValue = val;
          active.troughIndex = idx;
          active.troughDate = date;
        }
      }
    });

    if(active){
      const finalized = finalizeDrawdownRecord(active, trades);
      if(finalized) results.push(finalized);
    }

    return results.sort((a,b)=> b.magnitude - a.magnitude).slice(0,5);
  }

  function finalizeDrawdownRecord(active, trades){
    if(!active) return null;
    const peakValue = Number(active.peakValue) || 0;
    const troughValue = Number(active.troughValue) || 0;
    const magnitude = peakValue - troughValue;
    if(!(magnitude>0)) return null;

    const dropStartIdx = Number.isInteger(active.startIndex) ? Math.max(0, active.startIndex) : 0;
    const troughIdx = Number.isInteger(active.troughIndex) ? active.troughIndex : dropStartIdx;
    const recoveryIdx = Number.isInteger(active.recoveryIndex) ? active.recoveryIndex : null;

    const dropTrades = trades.slice(dropStartIdx, troughIdx + 1);
    const recoveryTrades = recoveryIdx!=null ? trades.slice(troughIdx + 1, recoveryIdx + 1) : [];

    let dropWins=0, dropLosses=0;
    dropTrades.forEach(t=>{
      if(t.outcome==='W') dropWins++;
      else if(t.outcome==='L') dropLosses++;
    });

    const setupMap = new Map();
    dropTrades.forEach(t=>{
      const key = t.setup || 'Unlabeled';
      const entry = setupMap.get(key) || {wins:0, losses:0, total:0};
      entry.total++;
      if(t.outcome==='W') entry.wins++;
      else if(t.outcome==='L') entry.losses++;
      setupMap.set(key, entry);
    });
    const setupStats = Array.from(setupMap.entries()).map(([setup, stats])=>{
      const decisive = stats.wins + stats.losses;
      return {
        setup,
        trades: stats.total,
        wins: stats.wins,
        losses: stats.losses,
        winRate: decisive>0 ? stats.wins/decisive : null
      };
    }).sort((a,b)=> b.trades - a.trades);

    const peakIdx = Number.isInteger(active.peakIndex) ? active.peakIndex : -1;
    const inferredPeakDate = active.peakDate || (peakIdx>=0 ? trades[peakIdx]?.date : dropTrades[0]?.date);
    const inferredTroughDate = active.troughDate || (dropTrades.length ? dropTrades[dropTrades.length-1].date : inferredPeakDate);
    const recoveryDate = active.recoveryDate || null;

    const spanDays = calculateDaySpan(inferredPeakDate, recoveryDate || inferredTroughDate);
    const dropDays = calculateDaySpan(inferredPeakDate, inferredTroughDate);
    const recoveryDays = recoveryDate ? calculateDaySpan(inferredTroughDate, recoveryDate) : null;

    const decisiveTrades = dropWins + dropLosses;

    const percentDrop = computeDrawdownPercent(peakValue, magnitude);

    return {
      magnitude,
      peakDate: inferredPeakDate || null,
      troughDate: inferredTroughDate || null,
      recoveryDate,
      spanDays,
      dropDays,
      recoveryDays,
      dropTrades: dropTrades.length,
      recoveryTrades: recoveryTrades.length,
      dropWinRate: decisiveTrades>0 ? dropWins/decisiveTrades : null,
      setupStats,
      dropWins,
      dropLosses,
      percentDrop
    };
  }

  function buildEquitySeriesForDrawdowns(trades){
    const series = [];
    if(!Array.isArray(trades) || trades.length===0) return series;
    if(unitMode==='comp'){
      const start = compStart>0 ? compStart : 100000;
      const riskPct = compRiskPct>0 ? compRiskPct : 0.3;
      const a = riskPct/100;
      let equity = start;
      trades.forEach((t, idx)=>{
        const rVal = Number(t.r) || 0;
        equity = equity * (1 + rVal * a);
        series.push({index: idx, date: t.date, value: equity});
      });
    } else if(unitMode==='compSteps'){
      const start = compStepStart>0 ? compStepStart : 100000;
      const riskPct = compStepRiskPct>0 ? compStepRiskPct : 0.3;
      const stepPct = compStepStepPct>=0 ? compStepStepPct : 0;
      const pct = riskPct/100;
      const step = stepPct>0 ? stepPct/100 : 0;
      let equity = start;
      let base = start;
      let nextRaise = step>0 ? base * (1 + step) : Infinity;
      trades.forEach((t, idx)=>{
        const rVal = Number(t.r) || 0;
        equity += rVal * base * pct;
        if(step>0 && equity >= nextRaise){
          base = equity;
          nextRaise = base * (1 + step);
        } else if(step<=0){
          base = equity;
          nextRaise = Infinity;
        }
        series.push({index: idx, date: t.date, value: equity});
      });
    } else if(unitMode==='compDaily'){
      const start = compDailyStart>0 ? compDailyStart : 100000;
      const riskPct = compDailyRiskPct>0 ? compDailyRiskPct : 0.3;
      const pct = riskPct/100;
      let equity = start;
      let currentDay = trades.length ? trades[0].date : null;
      let dayStart = equity;
      trades.forEach((t, idx)=>{
        if(t.date && t.date !== currentDay){
          currentDay = t.date;
          dayStart = equity;
        }
        const rVal = Number(t.r) || 0;
        equity += rVal * dayStart * pct;
        series.push({index: idx, date: t.date, value: equity});
      });
    } else {
      const valuePerR = unitMode==='flat' ? (rValue>0 ? rValue : 100) : 1;
      const base = unitMode==='flat' ? (flatStart || 0) : 0;
      let cum = 0;
      trades.forEach((t, idx)=>{
        const rVal = Number(t.r) || 0;
        cum += rVal * valuePerR;
        series.push({index: idx, date: t.date, value: base + cum});
      });
    }
    return series;
  }

  function calculateDaySpan(start, end){
    if(!start || !end) return null;
    const s = Date.parse(`${start}T00:00:00Z`);
    const e = Date.parse(`${end}T00:00:00Z`);
    if(Number.isNaN(s) || Number.isNaN(e)) return null;
    const diff = Math.round((e - s)/86400000);
    if(diff < 0) return null;
    return diff + 1;
  }

  function formatDrawdownValue(value){
    if(!Number.isFinite(value)) return '—';
    const abs = Math.abs(value);
    if(unitMode==='R') return `-${fmt(abs,2)}R`;
    return `-$${fmt(abs,2)}`;
  }

  function formatWinRate(rate){
    if(rate==null || !Number.isFinite(rate)) return '—';
    return `${fmt(rate*100,1)}%`;
  }

  function computeDrawdownPercent(peakValue, magnitude){
    if(unitMode==='R') return null;
    if(!Number.isFinite(peakValue) || !Number.isFinite(magnitude)) return null;
    if(peakValue <= 0) return null;
    return -(magnitude / peakValue * 100);
  }

  function formatDrawdownPercent(percent){
    if(percent==null || !Number.isFinite(percent)) return '—';
    return `${fmt(percent,1)}%`;
  }

  function getTradeOutcomes(dataObj){
    const arr = [];
    for(const d of Object.keys(dataObj)){
      for(const ev of (dataObj[d]._events||[])){
        const rw = Number(ev.rewardR ?? 2); const rl = Number(ev.riskR ?? 1);
        arr.push(eventR(ev));
      }
    }
    return arr;
  }

  function buildTradeSequence(dataObj){
    const dates = Object.keys(dataObj).sort();
    const seq = [];
    dates.forEach(date=>{
      const day = dataObj[date];
      (day._events||[]).forEach(ev=>{
        const rw = Number(ev.rewardR ?? 2); const rl = Number(ev.riskR ?? 1);
        seq.push(eventR(ev));
      });
    });
    return seq;
  }

  // ===== Daily Rule Guards =====
  // (Daily rules removed in v8.13)

  // ===== Screenshot paste =====
  function fileToDataURL(fileOrBlob, cb){ const reader=new FileReader(); reader.onload=()=>cb(reader.result); reader.readAsDataURL(fileOrBlob); }
  function wireScreenshot(){
    const drop = $('#shotDrop');
    drop?.addEventListener('click', ()=> drop.focus());
    ['focus','blur','dragenter','dragleave'].forEach(ev=>{
      drop?.addEventListener(ev, ()=>{ if(ev==='focus' || ev==='dragenter') drop.classList.add('focus'); else drop.classList.remove('focus'); });
    });
    drop?.addEventListener('dragover', (e)=>{ e.preventDefault(); });
    drop?.addEventListener('drop', (e)=>{
      e.preventDefault();
      const file = e.dataTransfer.files?.[0]; if(!file || !file.type.startsWith('image/')) return alert('Drop an image file.');
      fileToDataURL(file, (dataUrl)=>{
        const day = touchDay(currentDate);
        if(day.screenshotCleared) delete day.screenshotCleared;
        day.screenshot = dataUrl; updateScreenshotView(); saveLocal(); showToast('Screenshot added');
        // Persist large image in IndexedDB
        try{ idbPutShot(currentDate, dataUrl); }catch(e){}
        renderBacktestJournal(currentDate);
        refreshJournalScreensForDate(currentDate);
      });
    });
    drop?.addEventListener('paste', (e)=>{
      const items = e.clipboardData && e.clipboardData.items; if(!items) return;
      for(const it of items){
        if(it.type && it.type.indexOf('image') !== -1){
          const file = it.getAsFile(); if(!file) continue;
          fileToDataURL(file, (dataUrl)=>{
            const day = touchDay(currentDate);
            if(day.screenshotCleared) delete day.screenshotCleared;
            day.screenshot = dataUrl; updateScreenshotView(); saveLocal(); showToast('Screenshot pasted');
            try{ idbPutShot(currentDate, dataUrl); }catch(e){}
            renderBacktestJournal(currentDate);
            refreshJournalScreensForDate(currentDate);
          });
          e.preventDefault(); return;
        }
      }
      alert('Clipboard has no image. Copy an image first, then paste.');
    });
    $('#openShot')?.addEventListener('click', ()=>{
      const dataUrl = getDay(currentDate)?.screenshot;
      if(dataUrl){ const w = window.open(); if(w){ w.document.write(`<img src=\"${dataUrl}\" style=\"max-width:100%; height:auto\">`); } return; }
      getScreenshotForDate(currentDate).then((url)=>{
        if(!url) return;
        const w = window.open(); if(w){ w.document.write(`<img src=\"${url}\" style=\"max-width:100%; height:auto\">`); }
      });
    });
    $('#clearShot')?.addEventListener('click', ()=>{
      const day = getDay(currentDate); if(!day?.screenshot) return;
      const snap = day.screenshot;
      pushUndo(()=>{ const d=touchDay(currentDate); d.screenshot = snap; if(d.screenshotCleared) delete d.screenshotCleared; updateScreenshotView(); saveLocal(); });
      delete day.screenshot; day.screenshotCleared = true; updateScreenshotView(); saveLocal(); showToast('Screenshot cleared');
      try{ idbDeleteShot(currentDate); }catch(e){}
      renderBacktestJournal(currentDate);
      refreshJournalScreensForDate(currentDate);
    });
  }

  // ===== Recording trades =====
  function newEventId(date){ return `${date}-${Math.random().toString(36).slice(2,8)}${Date.now().toString(36).slice(-4)}`; }
  function record(type){
    const day = touchDay(currentDate);
    // Read RR inputs (fallback to defaults)
    const ri = parseFloat(document.getElementById('rewardInput')?.value || rrReward);
    const ki = parseFloat(document.getElementById('riskInput')?.value || rrRisk);
    const rwd = (isFinite(ri) && ri>=0) ? ri : rrReward;
    const rsk = (isFinite(ki) && ki>=0) ? ki : rrRisk;
    // Persist last used inputs to defaults
    rrReward = rwd; rrRisk = rsk; saveLocal();
    const ev = { id:newEventId(currentDate), setup: currentSetup, scenario: currentScenarioKey(), outcome: type==='win' ? 'W' : (type==='be' ? 'B' : 'L'), tags: [], rewardR: rwd, riskR: rsk };
    addTagsToEvent(ev, quickTags);
    day._events.push(ev);
    deriveAggregatesForDay(day);
    const disp = type==='win' ? `+${fmt(rwd,2)}R win` : (type==='be' ? `0R breakeven` : `-${fmt(rsk,2)}R loss`);
    showToast(`${disp} • ${currentSetup} • ${dispDate(currentDate)}`);
    updateBacktestView(); updateReportView(); saveLocal();
  }

  // Quick Tags chips
  function renderQuickTags(){
    const box = $('#quickTagsBox'); if(!box) return;
    [...box.querySelectorAll('.chip')].forEach(n=> n.remove());
    quickTags.forEach(tag=>{
      const c=document.createElement('span'); c.className='chip'; c.innerHTML=`${tag} <span class="xbtn" title="Remove">×</span>`;
      c.querySelector('.xbtn').onclick = ()=>{ quickTags = quickTags.filter(t=>t!==tag); renderQuickTags(); saveLocal(); };
      box.insertBefore(c, $('#quickTagInput'));
    });
  }
  $('#quickTagInput')?.addEventListener('keydown', (e)=>{
    if(e.key==='Enter'){
      const v = e.currentTarget.value.trim(); if(!v) return;
      ensureTag(v); if(!quickTags.includes(v)) quickTags.push(v);
      e.currentTarget.value=''; renderQuickTags(); populateTagSelects(); saveLocal();
    }
  });

  // ===== All Trades =====
  let atSelection = new Set(); let atHoverDate = null;

  function getATFilters(){
    // Read directly from UI
    const selectedTags = Array.from($('#atTagsSel')?.selectedOptions || []).map(o=>o.value);
    const tagMode = document.querySelector('input[name="atTagMode"]:checked')?.value || 'any';
    const selectedExTags = Array.from($('#atExTagsSel')?.selectedOptions || []).map(o=>o.value);
    const exTagMode = document.querySelector('input[name="atExTagMode"]:checked')?.value || 'any';
    
    return {
      start: atStartDate, end: atEndDate,
      setup: atSetup || '',
      result: atResult || '',
      dayType: atDayType || '',
      tags: selectedTags,
      tagsAll: tagMode === 'all',
      excludeTags: selectedExTags,
      excludeTagsAll: exTagMode === 'all',
      scenario: currentScenarioKey()
    };
  }

  // New: same as getATFilters but uses compact picker state
  function getATFilters2(){
    const tagMode = document.querySelector("input[name=\"atTagMode\"]:checked")?.value || "any";
    const exTagMode = document.querySelector("input[name=\"atExTagMode\"]:checked")?.value || "any";
    return {
      start: atStartDate, end: atEndDate,
      setup: atSetup || "",
      result: atResult || "",
      dayType: atDayType || "",
      tags: Array.isArray(atTags) ? atTags.slice() : [],
      tagsAll: tagMode === "all",
      excludeTags: Array.isArray(atExTags) ? atExTags.slice() : [],
      excludeTagsAll: exTagMode === "all",
      limitPerDay: atTradesLimit || null,
      nthTradePerDay: (Number.isFinite(parseInt(atNthTrade)) && parseInt(atNthTrade)>0) ? parseInt(atNthTrade) : null,
      scenario: currentScenarioKey()
    };
  }

  function updateATFilterStatus(){
    const f = getATFilters2();
    let count = 0;
    if(f.start || f.end) count++;
    if(f.setup) count++;
    if(f.result) count++;
    if(f.dayType) count++;
    if(f.scenario && f.scenario !== 'S1') count++;
    if(f.tags && f.tags.length > 0) count++;
    if(f.excludeTags && f.excludeTags.length > 0) count++;
    if(f.limitPerDay && parseInt(f.limitPerDay) > 0) count++;
    if(f.nthTradePerDay && parseInt(f.nthTradePerDay) > 0) count++;
    
    const el = $('#atFilterStatus');
    if(el){
      if(count > 0){
        el.innerHTML = `<span class="filter-active">${count} filter${count>1?'s':''}</span>`;
      } else {
        el.innerHTML = '';
      }
    }
  }

  function renderAllTrades(){
    populateTagSelects();
    updateATFilterStatus();
    // sync input with state
    const atInp = document.getElementById('atTradesPerDay'); if(atInp) atInp.value = atTradesLimit && atTradesLimit>0 ? String(atTradesLimit) : '';
    const atNthInp = document.getElementById('atNthTrade'); if(atNthInp) atNthInp.value = atNthTrade && atNthTrade>0 ? String(atNthTrade) : '';
    const atTrail = document.getElementById('atTrailToggle'); if(atTrail) atTrail.checked = !!trailProfit;
    const atScenarioSel = document.getElementById('atScenarioSel'); if(atScenarioSel && atScenarioSel.value !== currentScenarioKey()) atScenarioSel.value = currentScenarioKey();
    
    const f = getATFilters2();
    const clone = filteredClone(dailyData, f);
    const rows = flattenTrades(clone, true);

    const body = $('#atTbody'); body.innerHTML='';
    const countSpan = $('#atCount');
    if (countSpan) countSpan.textContent = rows.length ? `(${rows.length})` : '';
    
    if(rows.length===0){ body.innerHTML = `<tr><td colspan="7" class="muted" style="text-align:center">No trades yet</td></tr>`; return; }

    rows.sort((a,b)=> a.date<b.date? -1 : a.date>b.date? 1 : 0);
    rows.forEach(r=>{
      const tr = document.createElement('tr');
      const checked = atSelection.has(r.id) ? 'checked' : '';
      const tagsHtml = (r.tags||[]).map(t=>`<span class="chip">${t}</span>`).join(' ');
      const resHTML = r.outcome==='W'
        ? `<span style="color:var(--green); font-weight:800">WIN</span>`
        : (r.outcome==='B'
          ? `<span style="color:var(--amber); font-weight:800">BREAKEVEN</span>`
          : `<span style="color:var(--red); font-weight:800">LOSE</span>`);
      tr.innerHTML = `
        <td class="col-select"><input type="checkbox" data-id="${r.id}" ${checked}></td>
        <td>${dispDate(r.date)}</td>
        <td>${r.setup}</td>
        <td>${resHTML}</td>
        <td>${r.r}</td>
        <td>${tagsHtml || '<span class="muted">—</span>'}</td>
        <td class="col-pic"><span class="pic-icon" data-date="${r.date}" title="Preview">IMG</span></td>`;
      body.appendChild(tr);
    });

    // Selection
    body.querySelectorAll('input[type="checkbox"][data-id]').forEach(ch=>{
      ch.onchange = ()=>{ const id = ch.getAttribute('data-id'); if(ch.checked) atSelection.add(id); else atSelection.delete(id); };
    });
    $('#atHeadCheck').onchange = ()=>{
      const head = $('#atHeadCheck').checked;
      body.querySelectorAll('input[type="checkbox"][data-id]').forEach(ch=>{
        ch.checked = head; const id=ch.getAttribute('data-id'); if(head) atSelection.add(id); else atSelection.delete(id);
      });
    };

    // Hover preview
    function setPreviewByDate(date){
      const holder = $('#atPreviewHolder');
      holder.innerHTML='';
      const img=document.createElement('img');
      const shot = getDay(date)?.screenshot;
      if(shot){ img.src=shot; holder.appendChild(img); $('#atPrevMeta').textContent = `Screenshot • ${dispDate(date)}`; return; }
      // Try to fetch from default folder if not present
      getScreenshotForDate(date).then((url)=>{
        if(url){ img.src=url; holder.innerHTML=''; holder.appendChild(img); $('#atPrevMeta').textContent = `Screenshot • ${dispDate(date)}`; }
        else { holder.innerHTML = `<span class=\"muted\">No screenshot for ${dispDate(date)}</span>`; $('#atPrevMeta').textContent = ''; }
      }).catch(()=>{ holder.innerHTML = `<span class=\"muted\">No screenshot for ${dispDate(date)}</span>`; $('#atPrevMeta').textContent = ''; });
    }
    body.querySelectorAll('.pic-icon').forEach(el=>{
      el.addEventListener('mouseenter', ()=>{ atHoverDate = el.getAttribute('data-date'); setPreviewByDate(atHoverDate); });
      el.addEventListener('click', ()=>{ atHoverDate = el.getAttribute('data-date'); setPreviewByDate(atHoverDate); });
    });

    $('#atOpenShot').onclick = ()=>{
      if(!atHoverDate) return;
      const local = getDay(atHoverDate)?.screenshot;
      if(local){ const w = window.open(); if(w){ w.document.write(`<img src="${local}" style="max-width:100%; height:auto">`); } return; }
      getScreenshotForDate(atHoverDate).then((url)=>{
        if(!url) return;
        const w = window.open(); if(w){ w.document.write(`<img src=\"${url}\" style=\"max-width:100%; height:auto\">`); }
      });
    };
    $('#atClearShot').onclick = ()=>{
      if(!atHoverDate) return;
      const d = getDay(atHoverDate); if(!d?.screenshot) return;
      const snap = d.screenshot;
      pushUndo(()=>{ const dd=touchDay(atHoverDate); dd.screenshot = snap; if(dd.screenshotCleared) delete dd.screenshotCleared; renderAllTrades(); updateScreenshotView(); saveLocal(); });
      delete d.screenshot; d.screenshotCleared = true; renderAllTrades(); if(currentDate===atHoverDate) updateScreenshotView(); saveLocal(); showToast('Screenshot cleared');
    };
  }

  // ===== All Trades bulk operations =====
  function forEachSelectedEvent(cb){
    const idToDate = {};
    for(const d of Object.keys(dailyData)){
      for(const ev of (dailyData[d]._events||[])) idToDate[ev.id]=d;
    }
    atSelection.forEach(id=>{
      const date = idToDate[id]; if(!date) return;
      const day = dailyData[date]; if(!day) return;
      const idx = day._events.findIndex(e=> e.id===id); if(idx<0) return;
      cb({date, day, idx, ev: day._events[idx]});
    });
  }

  function applyBulkOps({addTags=[], removeTags=[], doDelete=false}){
    const snapshot = deepCloneData(dailyData);
    pushUndo(()=>{ dailyData = snapshot; syncTagCatalog(); renderAllTrades(); updateReportView(); updateBacktestView(); saveLocal(); });
    let changes=0;
    forEachSelectedEvent(({date, day, idx, ev})=>{
      if(doDelete){ 
        day._events.splice(idx,1); 
        changes++; 
      } else {
        if(addTags.length){ addTagsToEvent(ev, addTags); changes++; }
        if(removeTags.length){ removeTagsFromEvent(ev, removeTags); changes++; }
      }
      deriveAggregatesForDay(day);
      if((day._events?.length||0)===0 && (!day.note || day.note.trim()==='') && !day.screenshot){
        delete dailyData[date];
      }
    });
    if(changes===0){ showToast('No changes applied'); return; }
    atSelection.clear();
    syncTagCatalog();
    renderAllTrades(); updateReportView(); updateBacktestView(); saveLocal();
    showToast('Bulk operation applied', undoStack.length ? undoStack[undoStack.length-1] : undefined);
  }

  $('#atSelectAll')?.addEventListener('click', ()=>{
    document.querySelectorAll('#atTbody input[type="checkbox"][data-id]').forEach(ch=>{ ch.checked=true; atSelection.add(ch.getAttribute('data-id')); });
  });
  $('#atClearSel')?.addEventListener('click', ()=>{ atSelection.clear(); document.querySelectorAll('#atTbody input[type="checkbox"][data-id]').forEach(ch=> ch.checked=false); });
  $('#atBulkAddTag')?.addEventListener('click', ()=>{
    const t = ($('#atBulkTagInput').value||'').trim(); if(!t) return alert('Enter a tag');
    ensureTag(t); applyBulkOps({addTags:[t]});
  });
  $('#atBulkRemoveTag')?.addEventListener('click', ()=>{
    const t = ($('#atBulkTagInput').value||'').trim(); if(!t) return alert('Enter a tag');
    applyBulkOps({removeTags:[t]});
  });
  $('#atBulkDelete')?.addEventListener('click', ()=>{
    if(atSelection.size===0) return alert('Select rows first');
    if(!confirm('Delete selected trades?')) return;
    applyBulkOps({doDelete:true});
  });

  $('#atExport')?.addEventListener('click', ()=>{
    const rows = flattenTrades(filteredClone(dailyData, getATFilters2()), true);
    if(rows.length===0) { alert('No trades to export'); return; }
    let csv = 'Date,Setup,Result,R,Day Type,Tags,Note\n';
    rows.forEach(r=>{
      const tags = (r.tags||[]).join('|');
      const note = (r.note||'').replace(/[\n\r,]/g,' ');
      const res = r.outcome==='W' ? 'Win' : (r.outcome==='B' ? 'Breakeven' : 'Loss');
      csv += `${dispDate(r.date)},${r.setup},${res},${r.r},${r.dayType},${tags},${note}\n`;
    });
    const blob = new Blob([csv],{type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url; a.download=`all_trades_${new Date().toISOString().slice(0,10).replaceAll('-','_')}.csv`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    showToast('All Trades CSV exported');
  });

  // ===== Tag Manager =====
  function openTagMgr(){ $('#tagModalBackdrop').classList.add('show'); $('#tagModal').classList.add('show'); renderTagList(); }
  function closeTagMgr(){ $('#tagModalBackdrop').classList.remove('show'); $('#tagModal').classList.remove('show'); }
  // Centralized deletion: remove a tag from all trades, lists, and quick tags
  function deleteTagEverywhere(tag){
    const t = (tag||'').trim(); if(!t) return;
    const snapshot = deepCloneData(dailyData);
    pushUndo(()=>{ dailyData = snapshot; syncTagCatalog(); renderAllTrades(); updateReportView(); updateBacktestView(); saveLocal(); });

    // Remove from all events
    for(const d of Object.keys(dailyData)){
      (dailyData[d]._events||[]).forEach(ev=>{ if(ev.tags) ev.tags = ev.tags.filter(x=> x!==t); });
    }
    // Remove from quick tags and catalog
    if(Array.isArray(quickTags)) quickTags = quickTags.filter(x=> x!==t);
    if(Array.isArray(tagCatalog)) tagCatalog = tagCatalog.filter(x=> x!==t);
    // Remove from active filters
    if(Array.isArray(repTags)) repTags = repTags.filter(x=> x!==t);
    if(Array.isArray(atTags)) atTags = atTags.filter(x=> x!==t);
    if(Array.isArray(calTags)) calTags = calTags.filter(x=> x!==t);
    if(Array.isArray(repExTags)) repExTags = repExTags.filter(x=> x!==t);
    if(Array.isArray(atExTags)) atExTags = atExTags.filter(x=> x!==t);
    if(Array.isArray(calExTags)) calExTags = calExTags.filter(x=> x!==t);

    // Refresh caches and UI
    syncTagCatalog();
    renderTagList(); populateTagSelects(); renderQuickTags(); renderAllTrades(); updateReportView(); saveLocal();
    showToast(`Tag "${t}" deleted from all trades`);
  }
  function renderTagList(){
    const box = $('#tagList'); box.innerHTML='';
    const allTags = getAllTagsFromData();
    if(allTags.length===0){ box.innerHTML = `<div class="muted">No tags yet</div>`; return; }
    allTags.forEach(t=>{
      const row=document.createElement('div'); row.className='item';
      // Per-tag delete button removes the tag everywhere
      row.innerHTML = `<div>${t}</div><div><button class="btn red" data-delete="${t}">Delete</button></div>`;
      box.appendChild(row);
    });
    box.querySelectorAll('[data-delete]').forEach(b=>{
      b.onclick=()=>{ const t=b.getAttribute('data-delete'); deleteTagEverywhere(t); };
    });
  }
  $('#openTagMgrBtn')?.addEventListener('click', openTagMgr);
  $('#closeTagMgrBtn')?.addEventListener('click', closeTagMgr);
  $('#tagModalBackdrop')?.addEventListener('click', closeTagMgr);

  $('#addTagBtn')?.addEventListener('click', ()=>{
    const v = ($('#newTagInput').value||'').trim(); if(!v) return;
    ensureTag(v); renderTagList(); populateTagSelects(); saveLocal(); showToast(`Tag "${v}" added`);
    $('#newTagInput').value = '';
  });
  $('#renameTagBtn')?.addEventListener('click', ()=>{
    const from = ($('#renameFrom').value||'').trim(); const to = ($('#renameTo').value||'').trim();
    if(!from || !to) return alert('Enter both old and new names');
    if(from===to) return;
    const allTags = getAllTagsFromData();
    if(!allTags.includes(from)) return alert('Old tag not found');
    ensureTag(to);
    const snapshot = deepCloneData(dailyData);
    pushUndo(()=>{ dailyData = snapshot; syncTagCatalog(); renderAllTrades(); updateReportView(); saveLocal(); });

    for(const d of Object.keys(dailyData)){
      (dailyData[d]._events||[]).forEach(ev=>{
        if(ev.tags && ev.tags.includes(from)){
          ev.tags = ev.tags.map(t=> t===from ? to : t);
        }
      });
    }
    // Update quick tags, active filters, and catalog so old name disappears
    if(Array.isArray(quickTags)) quickTags = quickTags.map(t=> t===from ? to : t).filter(Boolean);
    if(Array.isArray(repTags)) repTags = repTags.map(t=> t===from ? to : t);
    if(Array.isArray(atTags)) atTags = atTags.map(t=> t===from ? to : t);
    if(Array.isArray(tagCatalog)){
      tagCatalog = tagCatalog.filter(t=> t!==from);
      ensureTag(to);
    }
    syncTagCatalog();
    renderTagList(); populateTagSelects(); renderQuickTags(); renderAllTrades(); updateReportView(); saveLocal(); 
    showToast(`Renamed "${from}" → "${to}"`);
    $('#renameFrom').value = ''; $('#renameTo').value = '';
  });
  // Direct delete line removed; deletion available via buttons in Existing tags list

  // ===== Report & All Trades filter wiring =====
  // Calendar wiring
  document.getElementById('calApply')?.addEventListener('click', ()=>{
    const n = parseInt(document.getElementById('calTradesPerDay')?.value || '');
    calTradesLimit = Number.isFinite(n) && n>0 ? n : null;
    calSetup = document.getElementById('calSetupSel')?.value || '';
    calResult = document.getElementById('calResultSel')?.value || '';
    const nthi = parseInt(document.getElementById('calNthTrade')?.value || '');
    calNthTrade = Number.isFinite(nthi) && nthi>0 ? nthi : null;
    updateCalendarView(); saveLocal();
  });
  document.getElementById('calClear')?.addEventListener('click', ()=>{
    calSetup = calResult = ''; calTags = []; calTagsAll=false; calExTags=[]; calExTagsAll=false; calTradesLimit=null; calNthTrade=null;
    document.getElementById('calSetupSel').value='';
    document.getElementById('calResultSel').value='';
    document.getElementById('calTradesPerDay').value='';
    const cni = document.getElementById('calNthTrade'); if(cni) cni.value='';
    const cem = document.querySelector('input[name="calExTagMode"][value="any"]'); if(cem) cem.checked = true;
    updateCalendarView(); saveLocal();
  });
  document.getElementById('calPrevMonth')?.addEventListener('click', ()=>{
    const [y,m] = (calMonth||new Date().toISOString().slice(0,7)).split('-').map(n=>parseInt(n,10));
    const d = new Date(Date.UTC(y, m-2, 1));
    calMonth = d.toISOString().slice(0,7); updateCalendarView(); saveLocal();
  });
  document.getElementById('calNextMonth')?.addEventListener('click', ()=>{
    const [y,m] = (calMonth||new Date().toISOString().slice(0,7)).split('-').map(n=>parseInt(n,10));
    const d = new Date(Date.UTC(y, m, 1));
    calMonth = d.toISOString().slice(0,7); updateCalendarView(); saveLocal();
  });
  document.getElementById('calMonth')?.addEventListener('change', ()=>{
    const v = document.getElementById('calMonth').value; if(v) calMonth=v; updateCalendarView(); saveLocal();
  });

  // Calendar unit toggles
  document.getElementById('calUnitR')?.addEventListener('click', ()=>{ unitMode='R'; updateCalendarView(); saveLocal(); });
  document.getElementById('calUnitDollarFlat')?.addEventListener('click', ()=>{ unitMode='flat'; updateCalendarView(); saveLocal(); });
  document.getElementById('calUnitDollarComp')?.addEventListener('click', ()=>{ unitMode='comp'; updateCalendarView(); saveLocal(); });
  document.getElementById('calUnitDollarCompSteps')?.addEventListener('click', ()=>{ unitMode='compSteps'; updateCalendarView(); saveLocal(); });
  document.getElementById('calUnitDollarCompDaily')?.addEventListener('click', ()=>{ unitMode='compDaily'; updateCalendarView(); saveLocal(); });
  document.getElementById('calClear')?.addEventListener('click', ()=>{
    calSetup = calResult = ''; calTags = []; calTagsAll=false; calExTags=[]; calExTagsAll=false; calTradesLimit=null; calNthTrade=null;
    trailProfit = false;
    document.getElementById('calSetupSel').value='';
    document.getElementById('calResultSel').value='';
    document.querySelector('input[name="calTagMode"][value="any"]').checked = true;
    document.querySelector('input[name="calExTagMode"][value="any"]').checked = true;
    const ctpd = document.getElementById('calTradesPerDay'); if(ctpd) ctpd.value='';
    const ctn = document.getElementById('calNthTrade'); if(ctn) ctn.value='';
    const ctt = document.getElementById('calTrailToggle'); if(ctt) ctt.checked = false;
    updateCalendarView(); saveLocal();
  });
  $('#applyRange')?.addEventListener('click', ()=>{
    const s=$('#startDate').value||null, e=$('#endDate').value||null;
    if(s && e && s>e) return alert('Start must be before end.');
    reportStartDate=s; reportEndDate=e;
    repSetup = $('#repSetupSel').value||'';
    repResult = $('#repResultSel').value||'';
    // Trades per day limit
    const repN = parseInt(document.getElementById('repTradesPerDay')?.value || '');
    repTradesLimit = Number.isFinite(repN) && repN>0 ? repN : null;
    // Nth trade per day
    const repNth = parseInt(document.getElementById('repNthTrade')?.value || '');
    repNthTrade = Number.isFinite(repNth) && repNth>0 ? repNth : null;
    
    // Read tags directly from UI
    repTags = Array.from($('#repTagsSel')?.selectedOptions || []).map(o=>o.value);
    repTagsAll = document.querySelector('input[name="repTagMode"]:checked')?.value === 'all';
    repExTags = Array.from($('#repExTagsSel')?.selectedOptions || []).map(o=>o.value);
    repExTagsAll = document.querySelector('input[name="repExTagMode"]:checked')?.value === 'all';
    
    updateReportView(); saveLocal();
  });

  // Calendar screenshot overlay interactions
  (function(){
    const ovl = document.getElementById('calShotOverlay');
    const closeBtn = document.getElementById('calShotClose');
    if(ovl){
      // Click outside the modal content to close
      ovl.addEventListener('click', (e)=>{ if(e.target === ovl) closeCalShot(); });
      // Esc to close
      document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && ovl.classList.contains('show')) closeCalShot(); });
    }
    if(closeBtn){ closeBtn.addEventListener('click', closeCalShot); }
  })();
  
  $('#clearRangeBtn')?.addEventListener('click', ()=>{
    reportStartDate = reportEndDate = null;
    repSetup = repResult = ''; repTags = []; repTagsAll=false; repExTags=[]; repExTagsAll=false; repTradesLimit=null; repNthTrade=null;
    trailProfit = false;
    $('#startDate').value=''; $('#endDate').value='';
    $('#repSetupSel').value=''; $('#repResultSel').value='';
    $('#repTagsSel').value='';
    document.querySelector('input[name="repTagMode"][value="any"]').checked = true;
    $('#repExTagsSel').value='';
    document.querySelector('input[name="repExTagMode"][value="any"]').checked = true;
    const rpd = document.getElementById('repTradesPerDay'); if(rpd) rpd.value='';
    const rpn = document.getElementById('repNthTrade'); if(rpn) rpn.value='';
    const rt = document.getElementById('repTrailToggle'); if(rt) rt.checked = false;
    updateReportView(); saveLocal();
  });

  // All Trades controls
  $('#atApply')?.addEventListener('click', ()=>{
    const s=$('#atStartDate').value||null, e=$('#atEndDate').value||null;
    if(s && e && s>e) return alert('Start must be before end.');
    atStartDate=s; atEndDate=e;
    atSetup = $('#atSetupSel').value||'';
    atResult = $('#atResultSel').value||'';
    atDayType = $('#atDayTypeSel').value||'';
    // Trades per day limit
    const atN = parseInt(document.getElementById('atTradesPerDay')?.value || '');
    atTradesLimit = Number.isFinite(atN) && atN>0 ? atN : null;
    // Nth trade per day
    const atNth = parseInt(document.getElementById('atNthTrade')?.value || '');
    atNthTrade = Number.isFinite(atNth) && atNth>0 ? atNth : null;
    
    // Store for persistence but filters are read from UI in getATFilters()
    atTags = Array.from($('#atTagsSel')?.selectedOptions || []).map(o=>o.value);
    atTagsAll = document.querySelector('input[name="atTagMode"]:checked')?.value === 'all';
    atExTags = Array.from($('#atExTagsSel')?.selectedOptions || []).map(o=>o.value);
    atExTagsAll = document.querySelector('input[name="atExTagMode"]:checked')?.value === 'all';
    
    atSelection.clear();
    renderAllTrades(); saveLocal();
  });
  
  $('#atClear')?.addEventListener('click', ()=>{
    atStartDate=atEndDate=null; atSetup=atResult=atDayType=''; atTags=[]; atTagsAll=false; atExTags=[]; atExTagsAll=false; atTradesLimit=null; atNthTrade=null; atSelection.clear();
    trailProfit = false;
    $('#atStartDate').value=''; $('#atEndDate').value='';
    $('#atSetupSel').value=''; $('#atResultSel').value=''; $('#atDayTypeSel').value='';
    $('#atTagsSel').value='';
    document.querySelector('input[name="atTagMode"][value="any"]').checked = true;
    $('#atExTagsSel').value='';
    document.querySelector('input[name="atExTagMode"][value="any"]').checked = true;
    const atpd = document.getElementById('atTradesPerDay'); if(atpd) atpd.value='';
    const atni = document.getElementById('atNthTrade'); if(atni) atni.value='';
    const atT = document.getElementById('atTrailToggle'); if(atT) atT.checked = false;
    renderAllTrades(); saveLocal();
  });
  // Trail Profit toggles
  $('#repTrailToggle')?.addEventListener('change', ()=>{ trailProfit = !!document.getElementById('repTrailToggle').checked; updateReportView(); updateCalendarView(); renderAllTrades(); recalculateCompareStats(); saveLocal(); });
  $('#atTrailToggle')?.addEventListener('change', ()=>{ trailProfit = !!document.getElementById('atTrailToggle').checked; renderAllTrades(); updateReportView(); updateCalendarView(); recalculateCompareStats(); saveLocal(); });
  $('#calTrailToggle')?.addEventListener('change', ()=>{ trailProfit = !!document.getElementById('calTrailToggle').checked; updateCalendarView(); updateReportView(); renderAllTrades(); recalculateCompareStats(); saveLocal(); });
  $('#btTrailToggle')?.addEventListener('change', ()=>{ trailProfit = !!document.getElementById('btTrailToggle').checked; updateBacktestView(); updateReportView(); updateCalendarView(); renderAllTrades(); recalculateCompareStats(); saveLocal(); });

  // Granularity
  $$('#granSeg button').forEach(b=>{
    b.onclick = ()=>{ $$('#granSeg button').forEach(x=>x.classList.remove('active')); b.classList.add('active'); granularity=b.getAttribute('data-gran'); updateReportView(); saveLocal(); };
  });

  // Rolling Win Rate toggle
  $$('#rollWinSeg button').forEach(b=>{
    b.onclick = ()=>{
      $$('#rollWinSeg button').forEach(x=>x.classList.remove('active'));
      b.classList.add('active');
      const n = parseInt(b.getAttribute('data-n'), 10);
      rollingWinWindow = (n===5||n===10||n===20) ? n : 20;
      updateReportView(); saveLocal();
    };
  });

  // Threshold inputs (Report + Calendar)
  const thRep = document.getElementById('rollWinThresh'); if(thRep){ thRep.value = rollingWinThresh; thRep.onchange = ()=>{ const v=parseFloat(thRep.value); rollingWinThresh = Number.isFinite(v)? v : 20; updateReportView(); updateCalendarView(); saveLocal(); }; }
  const thCal = document.getElementById('calRollWinThresh'); if(thCal){ thCal.value = rollingWinThresh; thCal.onchange = ()=>{ const v=parseFloat(thCal.value); rollingWinThresh = Number.isFinite(v)? v : 20; updateReportView(); updateCalendarView(); saveLocal(); }; }

  // Calendar Rolling Win Rate toggle
  $$('#calRollWinSeg button').forEach(b=>{
    b.onclick = ()=>{
      $$('#calRollWinSeg button').forEach(x=>x.classList.remove('active'));
      b.classList.add('active');
      const n = parseInt(b.getAttribute('data-n'), 10);
      rollingWinWindow = (n===5||n===10||n===20) ? n : 20;
      updateCalendarView(); saveLocal();
    };
  });

  // Period Net toggle
  $$('#periodNetSeg button').forEach(b=>{
    b.onclick = ()=>{
      $$('#periodNetSeg button').forEach(x=>x.classList.remove('active'));
      b.classList.add('active');
      const m = b.getAttribute('data-period');
      periodNetMode = (m==='monthly' || m==='quarterly') ? m : 'weekly';
      const title = document.getElementById('periodNetTitle');
      if(title) title.textContent = 'Period Net';
      updateReportView(); saveLocal();
    };
  });

  // Weekday and Calendar Month view toggles
  $$('#weekdayViewSeg button').forEach(b=>{
    b.onclick = ()=>{
      weekdayViewMode = b.getAttribute('data-view')==='chart' ? 'chart' : 'table';
      updateReportView(); saveLocal();
    };
  });
  $$('#calMonthViewSeg button').forEach(b=>{
    b.onclick = ()=>{
      calMonthViewMode = b.getAttribute('data-view')==='chart' ? 'chart' : 'table';
      updateReportView(); saveLocal();
    };
  });
  $$('#quarterViewSeg button').forEach(b=>{
    b.onclick = ()=>{
      quarterViewMode = b.getAttribute('data-view')==='chart' ? 'chart' : 'table';
      updateReportView(); saveLocal();
    };
  });

  // Unit mode
  $('#unitR')?.addEventListener('click', ()=>{ unitMode='R'; updateReportView(); saveLocal(); });
  $('#unitDollarFlat')?.addEventListener('click', ()=>{ unitMode='flat'; updateReportView(); saveLocal(); });
  $('#unitDollarComp')?.addEventListener('click', ()=>{ unitMode='comp'; updateReportView(); saveLocal(); });
  $('#unitDollarCompSteps')?.addEventListener('click', ()=>{ unitMode='compSteps'; updateReportView(); saveLocal(); });
  $('#unitDollarCompDaily')?.addEventListener('click', ()=>{ unitMode='compDaily'; updateReportView(); saveLocal(); });

  // File I/O — Directory Mode default
  async function getDefaultDir(){ try{ return await idbGetPref('defaultDir'); }catch(_){ return null; } }
  async function setDefaultDir(dir){ try{ await idbSetPref('defaultDir', dir); updateDefaultDirLabel(dir); }catch(_){ /* noop */ } }
  async function clearDefaultDir(){ try{ await idbDeletePref('defaultDir'); updateDefaultDirLabel(null); }catch(_){ /* noop */ } }
  function updateDefaultDirLabel(dir){ const el=document.getElementById('defaultDirLabel'); if(el) el.textContent = dir?.name ? `Folder: ${dir.name}` : 'Not set'; }
  async function ensureReadPermission(handle){
    if(!handle) return false;
    try{
      if(handle.queryPermission){
        const q = await handle.queryPermission({mode:'read'});
        if(q==='granted') return true;
        const r = await handle.requestPermission({mode:'read'});
        return r==='granted';
      }
    }catch(_){ /* ignore */ }
    return true;
  }
  async function getScreenshotForDate(date){
    try{
      const day = getDay(date);
      const existing = day?.screenshot; if(existing) return existing;
      if(day?.screenshotCleared) return null; // do not auto-load if user cleared
      const dir = await getDefaultDir(); if(!dir) return null;
      const ok = await ensureReadPermission(dir); if(!ok) return null;
      let shots = null; try{ shots = await dir.getDirectoryHandle('shots'); }catch(_){ return null; }
      const exts = ['png','jpg','jpeg','webp'];
      for(const ext of exts){
        const name = `${date}.${ext}`;
        try{
          const fh = await shots.getFileHandle(name);
          const f = await fh.getFile();
          const b = await f.arrayBuffer();
          const mime = ext==='jpg'||ext==='jpeg' ? 'image/jpeg' : (ext==='webp'?'image/webp':'image/png');
          const b64 = abToBase64(b);
          const dataUrl = `data:${mime};base64,${b64}`;
          const d = touchDay(date); if(d.screenshotCleared) return null; d.screenshot = dataUrl; try{ idbPutShot(date, dataUrl); }catch(_){ }
          return dataUrl;
        }catch(_){ /* try next ext */ }
      }
      return null;
    }catch(_e){ return null; }
  }
  async function ensureRWPermission(handle){
    if(!handle) return false;
    if(handle.queryPermission){
      const q = await handle.queryPermission({mode:'readwrite'});
      if(q==='granted') return true;
      const r = await handle.requestPermission({mode:'readwrite'});
      return r==='granted';
    }
    return true;
  }
  async function saveToFile(){
    if(!window.showDirectoryPicker){ alert('Directory save requires a Chromium browser. Use Export Bundle (ZIP) instead.'); return; }
    if(Object.keys(dailyData).length===0){ alert('No data to save'); return; }
    const name = prompt('Save as (file name, for metadata only):', currentFileName || 'backtest'); if(!name) return;
    let dir = await getDefaultDir();
    if(!dir){ try{ dir = await window.showDirectoryPicker({ id:'tt_export_dir', mode:'readwrite', startIn:'downloads' }); await setDefaultDir(dir); }catch(e){ return; } }
    if(!(await ensureRWPermission(dir))){ alert('Permission denied for this folder'); return; }
    // shots subdir
    let shots; try{ shots = await dir.getDirectoryHandle('shots', {create:true}); }catch(e){ alert('Cannot create shots folder'); return; }
    // write images
    for(const d of Object.keys(dailyData)){
      const shot = dailyData[d]?.screenshot; if(!shot) continue;
      const {mime, bin} = dataURLToUint8(shot);
      const ext = extForMime(mime);
      const fname = `${d}.${ext}`;
      const fh = await shots.getFileHandle(fname, {create:true}); const w = await fh.createWritable(); await w.write(bin); await w.close();
    }
    const saveData = {
      fileName:name,
      data: buildThinDataWithRefs(),
      journalData,
      journalMode,
      journalFilterTags,
      journalSearchText,
      selectedCustomJournalId,
      journalFontSize,
      dayJournalFontSize,
      currentDate,
      savedAt:new Date().toISOString(),
      version:'6.1-dir',
      tagCatalog: getAllTagsFromData(),
      reportLayout: getCurrentReportLayout(),
      scaling: serializeScalingState(),
      setups: (SETUPS||[]).slice()
    };
    const jh = await dir.getFileHandle('data.json', {create:true}); const jw = await jh.createWritable(); await jw.write(JSON.stringify(saveData, null, 2)); await jw.close();
    currentFileName = name; saveLocal(); showToast(`Saved to folder${dir?.name? ' '+dir.name:''}`);
  }

  // Global Directory Load (used by Load button)
  async function loadFromDirectory(){
    if(!window.showDirectoryPicker){ alert('Directory load requires a Chromium browser. Use Load Bundle (ZIP) instead.'); return; }
    try{
      const dir = await window.showDirectoryPicker({ id:'tt_load_dir', mode:'read', startIn:'downloads' });
      // Read data.json
      const jh = await dir.getFileHandle('data.json');
      const jf = await jh.getFile();
      const text = await jf.text();
      const loaded = JSON.parse(text);
      const dataMap = loaded.data || loaded.dailyData || {};
      // Attach images by inferring shots/YYYY-MM-DD.ext in the selected folder
      let shotsDir = null; try{ shotsDir = await dir.getDirectoryHandle('shots'); }catch(_){ shotsDir=null; }
      for(const d of Object.keys(dataMap)){
        if(!shotsDir) break;
        let matched = false;
        for(const ext of ['png','jpg','jpeg','webp']){
          const name = `${d}.${ext}`;
          try{
            const fh = await shotsDir.getFileHandle(name);
            const f = await fh.getFile();
            const b = await f.arrayBuffer();
            const mime = ext==='jpg'||ext==='jpeg' ? 'image/jpeg' : (ext==='webp'?'image/webp':'image/png');
            const b64 = abToBase64(b);
            dataMap[d].screenshot = `data:${mime};base64,${b64}`;
            matched = true; break;
          }catch(_){ /* try next */ }
        }
        // Back-compat fallback: if JSON had explicit screenshotFile
        if(!matched){
          const sf = dataMap[d]?.screenshotFile;
          if(sf){
            const name = sf.split('/').pop();
            try{
              const fh = await shotsDir.getFileHandle(name);
              const f = await fh.getFile();
              const b = await f.arrayBuffer();
              const ext = name.split('.').pop().toLowerCase();
              const mime = ext==='jpg'||ext==='jpeg' ? 'image/jpeg' : (ext==='webp'?'image/webp':'image/png');
              const b64 = abToBase64(b);
              dataMap[d].screenshot = `data:${mime};base64,${b64}`;
            }catch(_e){ /* missing image, skip */ }
          }
        }
      }
      if(Object.keys(dailyData).length>0){ if(!confirm('Loading will replace current data. Continue?')) return; }
      dailyData = dataMap;
      journalData = loaded.journalData || journalData;
      journalMode = (loaded.journalMode==='daily' || loaded.journalMode==='weekly' || loaded.journalMode==='custom') ? loaded.journalMode : 'daily';
      journalFilterTags = Array.isArray(loaded.journalFilterTags) ? loaded.journalFilterTags.map(normalizeTag).filter(Boolean) : [];
      journalSearchText = typeof loaded.journalSearchText === 'string' ? loaded.journalSearchText : '';
      selectedCustomJournalId = loaded.selectedCustomJournalId || null;
      journalFontSize = Number.isFinite(parseInt(loaded.journalFontSize,10)) ? parseInt(loaded.journalFontSize,10) : journalFontSize;
      dayJournalFontSize = Number.isFinite(parseInt(loaded.dayJournalFontSize,10)) ? parseInt(loaded.dayJournalFontSize,10) : dayJournalFontSize;
      if(Array.isArray(loaded.setups) && loaded.setups.length>0){
        SETUPS = loaded.setups.slice(0,6).map(s=> String(s).trim()).filter(Boolean);
        if(!SETUPS.includes(currentSetup)) currentSetup = SETUPS[0] || currentSetup;
      }
      tagCatalog = Array.isArray(loaded.tagCatalog)? loaded.tagCatalog : [];
      currentFileName = loaded.fileName || null;
      reportLayout = Array.isArray(loaded.reportLayout) ? loaded.reportLayout : [];
      if(loaded.currentDate) currentDate = loaded.currentDate;
      migrateIfNeeded();
      collectAllJournalTags();
      syncTagCatalog();
      applyLoadedScalingState(loaded.scaling);
      try{ persistShotsForCurrentData(); }catch(e){}
      renderSetupButtons(); populateSetupSelects();
      renderJournalModeControls();
      renderJournalFilterChips();
      renderJournalList();
      renderJournalDetail();
      saveLocal(); applyReportLayout(); updateBacktestView(); updateReportView(); renderAllTrades();
      try{ await idbSetPref('defaultDir', dir); updateDefaultDirLabel(dir); }catch(_){}
      showToast('Loaded from folder');
    }catch(e){
      console.warn('Load dir failed', e);
      const msg = String(e?.message||e||'');
      if(msg.toLowerCase().includes('system files')){
        alert('Cannot open that folder (OS-protected). Please select a regular folder (e.g., new folder under Downloads/Documents), or use Load Bundle (ZIP).');
      }else if(msg){
        alert('Load failed: '+msg);
      }else{
        // probably user cancelled; ignore
      }
    }
  }
  
  function loadFromFile(file){
    const reader = new FileReader();
    reader.onload = (e)=>{
      function finishLoad(loaded, note){
        const dataMap = loaded.data || loaded.dailyData || null;
        if(!dataMap){ alert('Invalid file format'); return; }
        if(Object.keys(dailyData).length>0){
          if(!confirm('Loading will replace current data. Continue?')) return;
        }
        dailyData = dataMap || {};
        journalData = loaded.journalData || journalData;
        journalMode = (loaded.journalMode==='daily' || loaded.journalMode==='weekly' || loaded.journalMode==='custom') ? loaded.journalMode : 'daily';
        journalFilterTags = Array.isArray(loaded.journalFilterTags) ? loaded.journalFilterTags.map(normalizeTag).filter(Boolean) : [];
        journalSearchText = typeof loaded.journalSearchText === 'string' ? loaded.journalSearchText : '';
        selectedCustomJournalId = loaded.selectedCustomJournalId || null;
        journalFontSize = Number.isFinite(parseInt(loaded.journalFontSize,10)) ? parseInt(loaded.journalFontSize,10) : journalFontSize;
        dayJournalFontSize = Number.isFinite(parseInt(loaded.dayJournalFontSize,10)) ? parseInt(loaded.dayJournalFontSize,10) : dayJournalFontSize;
        if(Array.isArray(loaded.setups) && loaded.setups.length>0){
          SETUPS = loaded.setups.slice(0,6).map(s=> String(s).trim()).filter(Boolean);
          if(!SETUPS.includes(currentSetup)) currentSetup = SETUPS[0] || currentSetup;
        }
        tagCatalog = Array.isArray(loaded.tagCatalog)? loaded.tagCatalog : [];
        currentFileName = loaded.fileName || null;
        reportLayout = Array.isArray(loaded.reportLayout) ? loaded.reportLayout : [];
        if(loaded.currentDate) currentDate = loaded.currentDate;
        migrateIfNeeded();
        collectAllJournalTags();
        syncTagCatalog();
        applyLoadedScalingState(loaded.scaling);
        // Persist screenshots in IndexedDB so they survive refresh
        try{ persistShotsForCurrentData(); }catch(e){}
        renderSetupButtons(); populateSetupSelects();
        renderJournalModeControls();
        renderJournalFilterChips();
        renderJournalList();
        renderJournalDetail();
        saveLocal();
        applyReportLayout();
        updateBacktestView(); updateReportView(); renderAllTrades();
        showToast(`Loaded${currentFileName? ` "${currentFileName}"`:''}${note? ` — ${note}`:''}`);
      }

      try{
        const loaded = JSON.parse(e.target.result);
        finishLoad(loaded, '');
      }catch(err){
        // Fallback: strip screenshot data URLs and try to parse again
        try{
          const raw = String(e.target.result||'');
          const slim = raw.replace(/"screenshot":"data:[^"\\]*"/g, '"screenshot":null');
          const loaded2 = JSON.parse(slim);
          finishLoad(loaded2, 'screenshots skipped');
        }catch(err2){
          console.warn('Load failed:', err, err2);
          alert('Failed to read file');
        }
      }
    };
    reader.readAsText(file);
  }
  
  function exportCSV(){
    if(Object.keys(dailyData).length===0){ alert('No data to export'); return; }
    let csv = 'Date,Setup,Wins,Losses,Total Trades,Win Rate (%),Total R,Expectancy R,Note\n';
    const dates = Object.keys(dailyData).sort();
    let allW=0, allL=0;
    dates.forEach(date=>{
      const note = (dailyData[date].note || '').replace(/[\n\r,]/g,' ');
      for(const [setup,v] of Object.entries(dailyData[date])){
        if(['note','_events','screenshot'].includes(setup)) continue;
        const w=v.wins||0, l=v.losses||0, t=w+l;
        const r = Number(v.r||0);
        const wr=t? (w/t*100):0, exp=t? r/t:0;
        allW+=w; allL+=l;
        csv += `${dispDate(date)},${setup},${w},${l},${t},${fmt(wr,1)},${fmt(r,1)},${fmt(exp,2)},${note}\n`;
      }
    });
    // Recompute overall R by summing all events to be accurate with per-trade RR
    let totalR=0; for(const d of Object.keys(dailyData)){
      (dailyData[d]._events||[]).forEach(ev=>{ totalR += eventR(ev); });
    }
    const t=allW+allL, r=totalR, wr=t? (allW/t*100):0, exp=t? r/t:0;
    csv += `\nTOTAL,ALL,${allW},${allL},${t},${fmt(wr,1)},${fmt(r,1)},${fmt(exp,2)},\n`;
    const blob = new Blob([csv],{type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a=document.createElement('a');
    const fname = (currentFileName? currentFileName.replace(/[^a-z0-9]/gi,'_') : 'trading_backtest') + `_results_${new Date().toISOString().slice(0,10).replaceAll('-','_')}.csv`;
    a.href=url; a.download=fname; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    showToast('CSV exported');
  }

  $('#saveBtn')?.addEventListener('click', saveToFile);
  $('#loadBtn')?.addEventListener('click', async ()=>{ await loadFromDirectory(); });
  // Legacy file-input load disabled: directory mode is default now
  $('#exportBtn')?.addEventListener('click', exportCSV);

  // Hidden tools (Reset All + Merge Save Files)
  (async function wireHiddenTools(){
    const btn = document.getElementById('hiddenToolsBtn');
    const pop = document.getElementById('hiddenToolsPop');
    if(btn && pop){
      btn.addEventListener('click', ()=>{ pop.classList.toggle('show'); });
      document.addEventListener('click', (e)=>{
        if(!pop.classList.contains('show')) return;
        const path = e.composedPath ? e.composedPath() : [];
        if(!path.includes(pop) && !path.includes(btn)) pop.classList.remove('show');
      });
    }

    async function readJsonFile(file){
      return new Promise((resolve, reject)=>{
        const r = new FileReader();
        r.onload = ()=>{
          try{ resolve(JSON.parse(r.result)); }catch(err){ reject(err); }
        };
        r.onerror = ()=> reject(r.error);
        r.readAsText(file);
      });
    }

    function normalizeDailyData(obj){
      // Accept exported files (obj.data), legacy/local formats (obj.dailyData),
      // and bare dailyData maps with YYYY-MM-DD keys.
      const out = {};
      let src = {};
      if(obj && (obj.data || obj.dailyData)) src = obj.data || obj.dailyData;
      else if(obj && typeof obj==='object'){
        const ks = Object.keys(obj);
        const looksLikeDaily = ks.length>0 && ks.every(k=> /^\d{4}-\d{2}-\d{2}$/.test(k));
        if(looksLikeDaily) src = obj; // bare map
      }
      for(const d of Object.keys(src)){
        const day = src[d] || {};
        const o = { note: day.note||'', _events: Array.isArray(day._events)? day._events.map(ev=>({...ev})): [] };
        // If older format: migrate simple wins/losses per setup to events
        if(o._events.length===0){
          for(const [k,v] of Object.entries(day)){
            if(['note','_events','screenshot'].includes(k)) continue;
            const w = Number(v?.wins||0), l = Number(v?.losses||0);
            for(let i=0;i<w;i++) o._events.push({ id:`${d}-${k}-W-${i+1}`, setup:k, outcome:'W', tags:[], rewardR:2, riskR:1 });
            for(let i=0;i<l;i++) o._events.push({ id:`${d}-${k}-L-${i+1}`, setup:k, outcome:'L', tags:[], rewardR:2, riskR:1 });
          }
        }
        // Ensure fields
        o._events.forEach(ev=>{
          if(!ev.id) ev.id = `${d}-${Math.random().toString(36).slice(2,8)}`;
          if(!Array.isArray(ev.tags)) ev.tags=[];
          if(ev.rewardR===undefined) ev.rewardR=2;
          if(ev.riskR===undefined) ev.riskR=1;
        });
        if(day.screenshot) o.screenshot = day.screenshot;
        out[d]=o;
      }
      return out;
    }

    function sigForEvent(date, ev){
      const tags = Array.isArray(ev.tags)? ev.tags.slice().sort().join('|') : '';
      const rw = Number(ev.rewardR??2), rl=Number(ev.riskR??1);
      const note = (ev.note||'').trim();
      return `${date}|${ev.setup}|${ev.outcome}|${isFinite(rw)?rw:2}|${isFinite(rl)?rl:1}|${tags}|${note}`;
    }

    function buildLargeJSONBlob(saveData){
      // Build JSON in chunks to avoid creating a single huge string
      const parts = [];
      parts.push('{');
      // fileName
      parts.push('"fileName":', JSON.stringify(saveData.fileName||'merged'), ',');
      // data (large)
      parts.push('"data":{');
      const days = Object.keys(saveData.data||{});
      days.forEach((d, i)=>{
        if(i>0) parts.push(',');
        parts.push(JSON.stringify(d), ':', JSON.stringify(saveData.data[d]||{}));
      });
      parts.push('},');
      // journal fields
      parts.push('"journalData":', JSON.stringify(saveData.journalData||{}), ',');
      parts.push('"journalMode":', JSON.stringify(saveData.journalMode||'daily'), ',');
      parts.push('"journalFilterTags":', JSON.stringify(saveData.journalFilterTags||[]), ',');
      parts.push('"journalSearchText":', JSON.stringify(saveData.journalSearchText||''), ',');
      parts.push('"selectedCustomJournalId":', JSON.stringify(saveData.selectedCustomJournalId||null), ',');
      parts.push('"journalFontSize":', JSON.stringify(saveData.journalFontSize||16), ',');
      parts.push('"dayJournalFontSize":', JSON.stringify(saveData.dayJournalFontSize||16), ',');
      // small fields
      parts.push('"currentDate":', JSON.stringify(saveData.currentDate||null), ',');
      parts.push('"savedAt":', JSON.stringify(saveData.savedAt||new Date().toISOString()), ',');
      parts.push('"version":', JSON.stringify(saveData.version||'6.1'), ',');
      parts.push('"tagCatalog":', JSON.stringify(saveData.tagCatalog||[]), ',');
      parts.push('"reportLayout":', JSON.stringify(saveData.reportLayout||[]), ',');
      parts.push('"scaling":', JSON.stringify(saveData.scaling||null), ',');
      parts.push('"setups":', JSON.stringify(saveData.setups||[]));
      parts.push('}');
      return new Blob(parts, {type:'application/json'});
    }

    function stripScreenshotsMap(data){
      const out = {};
      for(const d of Object.keys(data||{})){
        const day = data[d] || {};
        const copy = { note: day.note||'', _events: Array.isArray(day._events)? day._events.map(ev=>({...ev})) : [] };
        // Intentionally drop screenshot
        out[d] = copy;
      }
      return out;
    }

    async function doMerge(){
      const fa = document.getElementById('mergeFileA').files[0];
      const fb = document.getElementById('mergeFileB').files[0];
      if(!fa || !fb){ alert('Select two JSON files'); return; }
      let A, B; try{ A = await readJsonFile(fa); B = await readJsonFile(fb); }catch(e){ console.warn(e); alert('Failed to read files'); return; }
      // Validate: must contain either data/dailyData or be a bare map of YYYY-MM-DD keys
      function isBareDailyMap(o){
        if(!o || typeof o!=='object') return false;
        const ks = Object.keys(o); if(ks.length===0) return false;
        return ks.every(k=> /^\d{4}-\d{2}-\d{2}$/.test(k));
      }
      if(!A || !B || (!A.data && !A.dailyData && !isBareDailyMap(A)) || (!B.data && !B.dailyData && !isBareDailyMap(B))){
        alert('Invalid file(s). Please select exported backtest JSON files.'); return;
      }
      const dA = normalizeDailyData(A), dB = normalizeDailyData(B);
      const merged = {};
      const dates = new Set([...Object.keys(dA), ...Object.keys(dB)]);
      for(const d of Array.from(dates).sort()){
        const out = { note:'', _events:[] };
        const sigs = new Set();
        function addDay(src){
          const day = src[d]; if(!day) return;
          // Prefer note from first non-empty
          if(!out.note && day.note) out.note = day.note;
          // Keep screenshot if absent
          if(!out.screenshot && day.screenshot) out.screenshot = day.screenshot;
          (day._events||[]).forEach(ev=>{
            const s = sigForEvent(d, ev);
            if(!sigs.has(s)){
              sigs.add(s);
              // Ensure unique id
              let id = ev.id || `${d}-${Math.random().toString(36).slice(2,8)}`;
              if(out._events.some(e=> e.id===id)) id = `${id}-${Math.random().toString(36).slice(2,4)}`;
              out._events.push({...ev, id});
            }
          });
        }
        addDay(dA); addDay(dB);
        if(out._events.length>0 || (out.note&&out.note.trim()!=='') || out.screenshot){ merged[d]=out; }
      }

      // Build merged setups (cap at 6, keep current order preference)
      const setA = Array.isArray(A.setups)? A.setups : []; const setB = Array.isArray(B.setups)? B.setups : [];
      const mergedSetups = [...SETUPS, ...setA, ...setB].filter((s,i,arr)=> s && arr.indexOf(s)===i).slice(0,6);
      // Tags union
      const tagsA = Array.isArray(A.tagCatalog)? A.tagCatalog: []; const tagsB = Array.isArray(B.tagCatalog)? B.tagCatalog: [];
      const mergedTags = [...new Set([...tagsA, ...tagsB, ...getAllTagsFromData()])];

      function cloneJournalEntry(entry){
        const clone = makeJournalEntry(entry||{});
        if(entry?.date) clone.date = entry.date;
        if(entry?.week) clone.week = entry.week;
        if(entry?.start) clone.start = entry.start;
        if(entry?.end) clone.end = entry.end;
        return clone;
      }
      function normalizeJournal(raw){
        const base = { daily:{}, weekly:{}, custom:[], tags:[] };
        if(!raw || typeof raw!=='object') return base;
        if(raw.daily && typeof raw.daily==='object'){
          for(const [date, entry] of Object.entries(raw.daily)){
            base.daily[date] = cloneJournalEntry(entry);
            base.daily[date].date = entry?.date || date;
          }
        }
        if(raw.weekly && typeof raw.weekly==='object'){
          for(const [week, entry] of Object.entries(raw.weekly)){
            const c = cloneJournalEntry(entry);
            c.week = entry?.week || week;
            c.start = entry?.start || getWeekRange(week).start;
            c.end = entry?.end || getWeekRange(week).end;
            base.weekly[week] = c;
          }
        }
        if(Array.isArray(raw.custom)){
          base.custom = raw.custom.map(j=>{
            const entries = Array.isArray(j.entries) ? j.entries.map(e=>{ const ce = cloneJournalEntry(e); if(!ce.id) ce.id = `je_${Math.random().toString(36).slice(2,10)}`; return ce; }) : [];
            return {
              id: j.id || `jc_${Math.random().toString(36).slice(2,9)}`,
              name: j.name || 'Personal Journal',
              createdAt: j.createdAt || new Date().toISOString(),
              entries
            };
          });
        }
        base.tags = Array.isArray(raw.tags) ? raw.tags.map(normalizeTag).filter(Boolean) : [];
        return base;
      }

      const journalA = normalizeJournal(A.journalData || {});
      const journalB = normalizeJournal(B.journalData || {});
      const mergedJournal = { daily:{}, weekly:{}, custom:[], tags:[...new Set([...(journalA.tags||[]), ...(journalB.tags||[])])].filter(Boolean) };

      for(const [date, entry] of Object.entries(journalA.daily||{})){
        mergedJournal.daily[date] = cloneJournalEntry(entry);
      }
      for(const [date, entry] of Object.entries(journalB.daily||{})){
        const cand = cloneJournalEntry(entry);
        const existing = mergedJournal.daily[date];
        if(!existing){ mergedJournal.daily[date] = cand; continue; }
        const existTime = Date.parse(existing.updatedAt || existing.createdAt || 0);
        const candTime = Date.parse(cand.updatedAt || cand.createdAt || 0);
        if(candTime > existTime){ mergedJournal.daily[date] = cand; continue; }
        if(candTime === existTime){
          const existLen = stripHTML(existing.content||'').length;
          const candLen = stripHTML(cand.content||'').length;
          if(candLen > existLen) mergedJournal.daily[date] = cand;
        }
      }

      for(const [week, entry] of Object.entries(journalA.weekly||{})){
        mergedJournal.weekly[week] = cloneJournalEntry(entry);
      }
      for(const [week, entry] of Object.entries(journalB.weekly||{})){
        const cand = cloneJournalEntry(entry);
        const existing = mergedJournal.weekly[week];
        if(!existing){ mergedJournal.weekly[week] = cand; continue; }
        const existTime = Date.parse(existing.updatedAt || existing.createdAt || 0);
        const candTime = Date.parse(cand.updatedAt || cand.createdAt || 0);
        if(candTime > existTime){ mergedJournal.weekly[week] = cand; continue; }
        if(candTime === existTime){
          const existLen = stripHTML(existing.content||'').length;
          const candLen = stripHTML(cand.content||'').length;
          if(candLen > existLen) mergedJournal.weekly[week] = cand;
        }
      }

      const customMap = new Map();
      function mergeCustomList(list){
        (list||[]).forEach(journal=>{
          const key = (journal.name||'').toLowerCase().trim() || `journal-${customMap.size}`;
          let target = customMap.get(key);
          if(!target){
            target = {
              id: journal.id || `jc_${Math.random().toString(36).slice(2,9)}`,
              name: journal.name || 'Personal Journal',
              createdAt: journal.createdAt || new Date().toISOString(),
              entries: []
            };
            customMap.set(key, target);
          }
          const entryMap = new Map((target.entries||[]).map(e=> [e.id, e]));
          (journal.entries||[]).forEach(entry=>{
            const cand = cloneJournalEntry(entry);
            cand.id = cand.id || `je_${Math.random().toString(36).slice(2,10)}`;
            const existing = entryMap.get(cand.id);
            if(!existing){ target.entries.push(cand); entryMap.set(cand.id, cand); return; }
            const existTime = Date.parse(existing.updatedAt || existing.createdAt || 0);
            const candTime = Date.parse(cand.updatedAt || cand.createdAt || 0);
            if(candTime > existTime || (candTime===existTime && stripHTML(cand.content||'').length > stripHTML(existing.content||'').length)){
              Object.assign(existing, cand);
            }
          });
        });
      }
      mergeCustomList(journalA.custom);
      mergeCustomList(journalB.custom);
      mergedJournal.custom = Array.from(customMap.values());

      const saveData = {
        fileName: 'merged',
        data: merged,
        journalData: mergedJournal,
        journalMode: 'daily',
        journalFilterTags: [],
        journalSearchText: '',
        selectedCustomJournalId: mergedJournal.custom[0]?.id || null,
        journalFontSize,
        dayJournalFontSize,
        currentDate,
        savedAt: new Date().toISOString(),
        version: '6.1',
        tagCatalog: mergedTags,
        reportLayout: getCurrentReportLayout(),
        scaling: serializeScalingState(),
        setups: mergedSetups
      };
      // Create blob safely; avoid a single massive string to prevent RangeError
      let blob;
      try{
        const json = JSON.stringify(saveData); // no pretty-print to reduce size
        blob = new Blob([json], {type:'application/json'});
      }catch(e1){
        try{
          blob = buildLargeJSONBlob(saveData);
        }catch(e2){
          // Last resort: drop screenshots to reduce size dramatically
          const slim = {...saveData, data: stripScreenshotsMap(saveData.data)};
          try{
            const json2 = JSON.stringify(slim);
            blob = new Blob([json2], {type:'application/json'});
            showToast('Merged (screenshots excluded due to size)');
          }catch(e3){
            console.warn('Merge stringify failed:', e1, e2, e3);
            alert('Merged file is too large to download. Try smaller files or remove screenshots.');
            return;
          }
        }
      }
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='merged_backtest.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      showToast('Merged file downloaded');
      // Close popover
      pop?.classList.remove('show');
    }

    document.getElementById('mergeGoBtn')?.addEventListener('click', doMerge);

    // ===== Bundle (ZIP) export/import =====
    function dataURLToUint8(dataUrl){
      const m = /^data:([^;]+);base64,(.*)$/.exec(dataUrl||'');
      if(!m) return {mime:'application/octet-stream', bin:new Uint8Array()};
      const mime = m[1]; const b64 = m[2];
      const raw = atob(b64);
      const arr = new Uint8Array(raw.length);
      for(let i=0;i<raw.length;i++) arr[i] = raw.charCodeAt(i);
      return {mime, bin: arr};
    }
    function extForMime(mime){
      if(!mime) return 'png';
      if(mime.includes('png')) return 'png';
      if(mime.includes('jpeg') || mime.includes('jpg')) return 'jpg';
      if(mime.includes('webp')) return 'webp';
      return 'png';
    }
    function buildThinDataWithRefs(){
      // No longer embed or reference screenshot filenames in JSON.
      // Consumers infer shots as shots/YYYY-MM-DD.<ext> in the save folder or bundle.
      const thin = {};
      for(const d of Object.keys(dailyData).sort()){
        const day = dailyData[d]||{};
        // Preserve note and events only
        const out = { note: day.note||'', _events: Array.isArray(day._events)? day._events.map(ev=>({...ev})) : [] };
        thin[d]=out;
      }
      return thin;
    }
    async function exportBundle(){
      if(typeof JSZip==='undefined'){ alert('JSZip not available'); return; }
      const zip = new JSZip();
      const folder = zip.folder('shots');
      // Add images
      for(const d of Object.keys(dailyData)){
        const shot = dailyData[d]?.screenshot; if(!shot) continue;
        const {mime, bin} = dataURLToUint8(shot);
        const ext = extForMime(mime);
        const name = `${d}.${ext}`;
        folder.file(name, bin, {binary:true});
      }
      // Add data.json
      const saveData = {
        fileName: currentFileName || 'bundle',
        data: buildThinDataWithRefs(),
        journalData,
        journalMode,
        journalFilterTags,
        journalSearchText,
        selectedCustomJournalId,
        journalFontSize,
        dayJournalFontSize,
        currentDate,
        savedAt: new Date().toISOString(),
        version: '6.1-bundle',
        tagCatalog: getAllTagsFromData(),
        reportLayout: getCurrentReportLayout(),
        scaling: serializeScalingState(),
        setups: (SETUPS||[]).slice()
      };
      zip.file('data.json', JSON.stringify(saveData));
      const blob = await zip.generateAsync({type:'blob'});
      const a = document.createElement('a');
      const base = (currentFileName? currentFileName.replace(/[^a-z0-9]/gi,'_') : 'backtest');
      a.href = URL.createObjectURL(blob); a.download = `${base}_bundle.zip`; document.body.appendChild(a); a.click(); a.remove();
      showToast('Bundle ZIP exported');
    }
    async function loadBundle(file){
      if(typeof JSZip==='undefined'){ alert('JSZip not available'); return; }
      try{
        const zip = await JSZip.loadAsync(file);
        // Find JSON manifest
        const jsonEntry = zip.file('data.json') || zip.file('backtest.json') || zip.file('manifest.json');
        if(!jsonEntry){ alert('Invalid bundle: data.json missing'); return; }
        const text = await jsonEntry.async('string');
        const loaded = JSON.parse(text);
        const dataMap = loaded.data || loaded.dailyData || {};
        // Preload images into IndexedDB and attach to dailyData
        const entries = Object.entries(dataMap);
        for(const [d, day] of entries){
          // New behavior: infer by date-named file in shots/ folder
          let found = null;
          const candidates = [`shots/${d}.png`, `shots/${d}.jpg`, `shots/${d}.jpeg`, `shots/${d}.webp`];
          for(const path of candidates){
            const f = zip.file(path);
            if(f){ found = {path, file:f}; break; }
          }
          // Back-compat: if manifest had screenshotFile, try it as fallback
          if(!found && day.screenshotFile){
            const f = zip.file(day.screenshotFile);
            if(f){ found = {path: day.screenshotFile, file: f}; }
          }
          if(found){
            const b64 = await found.file.async('base64');
            const ext = found.path.split('.').pop().toLowerCase();
            const mime = ext==='jpg'||ext==='jpeg' ? 'image/jpeg' : (ext==='webp'?'image/webp':'image/png');
            const dataUrl = `data:${mime};base64,${b64}`;
            if(!dataMap[d]._events) dataMap[d]._events = [];
            dataMap[d].screenshot = dataUrl;
          }
        }
        // Finish as regular load
        if(Object.keys(dailyData).length>0){
          if(!confirm('Loading will replace current data. Continue?')) return;
        }
        dailyData = dataMap;
        journalData = loaded.journalData || journalData;
        journalMode = (loaded.journalMode==='daily' || loaded.journalMode==='weekly' || loaded.journalMode==='custom') ? loaded.journalMode : 'daily';
        journalFilterTags = Array.isArray(loaded.journalFilterTags) ? loaded.journalFilterTags.map(normalizeTag).filter(Boolean) : [];
        journalSearchText = typeof loaded.journalSearchText === 'string' ? loaded.journalSearchText : '';
        selectedCustomJournalId = loaded.selectedCustomJournalId || null;
        journalFontSize = Number.isFinite(parseInt(loaded.journalFontSize,10)) ? parseInt(loaded.journalFontSize,10) : journalFontSize;
        dayJournalFontSize = Number.isFinite(parseInt(loaded.dayJournalFontSize,10)) ? parseInt(loaded.dayJournalFontSize,10) : dayJournalFontSize;
        if(Array.isArray(loaded.setups) && loaded.setups.length>0){
          SETUPS = loaded.setups.slice(0,6).map(s=> String(s).trim()).filter(Boolean);
          if(!SETUPS.includes(currentSetup)) currentSetup = SETUPS[0] || currentSetup;
        }
        tagCatalog = Array.isArray(loaded.tagCatalog)? loaded.tagCatalog : [];
        currentFileName = loaded.fileName || null;
        reportLayout = Array.isArray(loaded.reportLayout) ? loaded.reportLayout : [];
        if(loaded.currentDate) currentDate = loaded.currentDate;
        migrateIfNeeded();
        syncTagCatalog();
        applyLoadedScalingState(loaded.scaling);
        try{ persistShotsForCurrentData(); }catch(e){}
        renderSetupButtons(); populateSetupSelects();
        renderJournalModeControls();
        renderJournalFilterChips();
        renderJournalList();
        renderJournalDetail();
        saveLocal();
        applyReportLayout();
        updateBacktestView(); updateReportView(); renderAllTrades();
        showToast(`Loaded bundle${currentFileName? ` \"${currentFileName}\"`:''}`);
      }catch(err){
        console.warn('Load bundle failed:', err);
        alert('Failed to read bundle');
      }
    }

    document.getElementById('exportBundleBtn')?.addEventListener('click', exportBundle);
    const bundleIn = document.getElementById('bundleInput');
    document.getElementById('loadBundleBtn')?.addEventListener('click', ()=> bundleIn?.click());
    bundleIn?.addEventListener('change', (e)=>{ const f = e.target.files && e.target.files[0]; if(f) loadBundle(f); e.target.value=''; });

    // Directory mode (beta: Chromium File System Access API)
    async function exportToDirectory(){
      if(!window.showDirectoryPicker){ alert('Directory export requires a Chromium browser'); return; }
      try{
        const dir = await window.showDirectoryPicker({ id:'tt_export_dir', mode:'readwrite', startIn:'downloads' });
        try{ await idbSetPref('defaultDir', dir); updateDefaultDirLabel(dir); }catch(_){}
        // Shots subfolder
        const shots = await dir.getDirectoryHandle('shots', {create:true});
        // Write images
        for(const d of Object.keys(dailyData)){
          const shot = dailyData[d]?.screenshot; if(!shot) continue;
          const {mime, bin} = dataURLToUint8(shot);
          const ext = extForMime(mime);
          const name = `${d}.${ext}`;
          const fh = await shots.getFileHandle(name, {create:true});
          const w = await fh.createWritable(); await w.write(bin); await w.close();
        }
        // Write data.json with file references
        const saveData = {
          fileName: currentFileName || 'folder',
          data: buildThinDataWithRefs(),
          journalData,
          journalMode,
          journalFilterTags,
          journalSearchText,
          selectedCustomJournalId,
          journalFontSize,
          dayJournalFontSize,
          currentDate,
          savedAt: new Date().toISOString(),
          version: '6.1-dir',
          tagCatalog: getAllTagsFromData(),
          reportLayout: getCurrentReportLayout(),
          scaling: serializeScalingState(),
          setups: (SETUPS||[]).slice()
        };
        const jh = await dir.getFileHandle('data.json', {create:true});
        const jw = await jh.createWritable(); await jw.write(JSON.stringify(saveData, null, 2)); await jw.close();
        showToast('Exported to folder');
      }catch(e){
        console.warn('Export dir failed', e);
        const msg = String(e?.message||e||'');
        if(msg.toLowerCase().includes('system files')){
          const goZip = confirm('This folder is protected by the OS (contains system files).\nChoose a different folder (e.g., a new empty folder in Downloads/Documents) or export a ZIP bundle instead.\n\nExport ZIP bundle now?');
          if(goZip){ try{ await exportBundle(); }catch(_){} }
        }else{
          alert('Export failed. Try a different folder (e.g., a new folder in Downloads) or use Export Bundle (ZIP).');
        }
      }
    }
    function abToBase64(buf){
      const bytes = new Uint8Array(buf); const chunk = 0x8000; let binary = '';
      for(let i=0;i<bytes.length;i+=chunk){ binary += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk)); }
      return btoa(binary);
    }
    async function loadFromDirectory(){
      if(!window.showDirectoryPicker){ alert('Directory load requires a Chromium browser'); return; }
      try{
        const dir = await window.showDirectoryPicker({ id:'tt_load_dir', mode:'read', startIn:'downloads' });
        // Read data.json
        const jh = await dir.getFileHandle('data.json');
        const jf = await jh.getFile();
        const text = await jf.text();
        const loaded = JSON.parse(text);
        const dataMap = loaded.data || loaded.dailyData || {};
        // Determine shots subdir and attach images by date
        let shotsDir = null;
        try{ shotsDir = await dir.getDirectoryHandle('shots'); }catch(_){ shotsDir=null; }
        for(const d of Object.keys(dataMap)){
          if(!shotsDir) break;
          let matched = false;
          for(const ext of ['png','jpg','jpeg','webp']){
            const name = `${d}.${ext}`;
            try{
              const fh = await shotsDir.getFileHandle(name);
              const f = await fh.getFile();
              const b = await f.arrayBuffer();
              const mime = ext==='jpg'||ext==='jpeg' ? 'image/jpeg' : (ext==='webp'?'image/webp':'image/png');
              const b64 = abToBase64(b);
              dataMap[d].screenshot = `data:${mime};base64,${b64}`;
              matched = true; break;
            }catch(_){ /* try next */ }
          }
          // Back-compat: try explicit screenshotFile if present
          if(!matched){
            const sf = dataMap[d]?.screenshotFile;
            if(sf){
              const name = sf.split('/').pop();
              try{
                const fh = await shotsDir.getFileHandle(name);
                const f = await fh.getFile();
                const b = await f.arrayBuffer();
                const ext = name.split('.').pop().toLowerCase();
                const mime = ext==='jpg'||ext==='jpeg' ? 'image/jpeg' : (ext==='webp'?'image/webp':'image/png');
                const b64 = abToBase64(b);
                dataMap[d].screenshot = `data:${mime};base64,${b64}`;
              }catch(_e){ /* missing image, skip */ }
            }
          }
        }
        if(Object.keys(dailyData).length>0){ if(!confirm('Loading will replace current data. Continue?')) return; }
        dailyData = dataMap;
        journalData = loaded.journalData || journalData;
        journalMode = (loaded.journalMode==='daily' || loaded.journalMode==='weekly' || loaded.journalMode==='custom') ? loaded.journalMode : 'daily';
        journalFilterTags = Array.isArray(loaded.journalFilterTags) ? loaded.journalFilterTags.map(normalizeTag).filter(Boolean) : [];
        journalSearchText = typeof loaded.journalSearchText === 'string' ? loaded.journalSearchText : '';
        selectedCustomJournalId = loaded.selectedCustomJournalId || null;
        journalFontSize = Number.isFinite(parseInt(loaded.journalFontSize,10)) ? parseInt(loaded.journalFontSize,10) : journalFontSize;
        dayJournalFontSize = Number.isFinite(parseInt(loaded.dayJournalFontSize,10)) ? parseInt(loaded.dayJournalFontSize,10) : dayJournalFontSize;
        if(Array.isArray(loaded.setups) && loaded.setups.length>0){
          SETUPS = loaded.setups.slice(0,6).map(s=> String(s).trim()).filter(Boolean);
          if(!SETUPS.includes(currentSetup)) currentSetup = SETUPS[0] || currentSetup;
        }
        tagCatalog = Array.isArray(loaded.tagCatalog)? loaded.tagCatalog : [];
        currentFileName = loaded.fileName || null;
        reportLayout = Array.isArray(loaded.reportLayout) ? loaded.reportLayout : [];
        if(loaded.currentDate) currentDate = loaded.currentDate;
        migrateIfNeeded();
        collectAllJournalTags();
        syncTagCatalog();
        applyLoadedScalingState(loaded.scaling);
        try{ persistShotsForCurrentData(); }catch(e){}
        renderSetupButtons(); populateSetupSelects();
        renderJournalModeControls();
        renderJournalFilterChips();
        renderJournalList();
        renderJournalDetail();
        saveLocal(); applyReportLayout(); updateBacktestView(); updateReportView(); renderAllTrades();
        try{ await idbSetPref('defaultDir', dir); updateDefaultDirLabel(dir); }catch(_){}
        showToast('Loaded from folder');
      }catch(e){
        console.warn('Load dir failed', e);
        const msg = String(e?.message||e||'');
        if(msg.toLowerCase().includes('system files')){
          alert('Cannot open that folder (OS-protected). Please select a regular folder (e.g., new folder under Downloads/Documents), or use Load Bundle (ZIP).');
        }else{
          alert('Load failed. Try a different folder or use Load Bundle (ZIP).');
        }
      }
    }

    // Default folder controls
    document.getElementById('setDefaultDirBtn')?.addEventListener('click', async ()=>{ try{ const dir = await window.showDirectoryPicker({ id:'tt_default_dir', mode:'readwrite', startIn:'downloads' }); await idbSetPref('defaultDir', dir); updateDefaultDirLabel(dir); showToast('Default folder set'); }catch(_){} });
    document.getElementById('clearDefaultDirBtn')?.addEventListener('click', async ()=>{ await idbDeletePref('defaultDir'); updateDefaultDirLabel(null); showToast('Default folder cleared'); });
    try{ const d = await idbGetPref('defaultDir'); updateDefaultDirLabel(d); }catch(_){}
  })();

  // Date navigation
  $('#dateInput')?.addEventListener('change', ()=>{ currentDate = $('#dateInput').value || currentDate; updateBacktestView(); saveLocal(); });
  $('#prevDay')?.addEventListener('click', ()=>{ const dt=new Date(currentDate); dt.setDate(dt.getDate()-1); currentDate=dt.toISOString().slice(0,10); updateBacktestView(); saveLocal(); });
  $('#nextDay')?.addEventListener('click', ()=>{ const dt=new Date(currentDate); dt.setDate(dt.getDate()+1); currentDate=dt.toISOString().slice(0,10); updateBacktestView(); saveLocal(); });
  $('#todayBtn')?.addEventListener('click', ()=>{ currentDate = new Date().toISOString().slice(0,10); updateBacktestView(); saveLocal(); });

  // Setup manager wiring
  document.getElementById('setupManageBtn')?.addEventListener('click', ()=>{
    const pop = document.getElementById('setupManagePop');
    if(!pop) return;
    if(pop.classList.contains('show')) closeSetupMgr(); else openSetupMgr();
  });
  document.addEventListener('click', (e)=>{
    const pop = document.getElementById('setupManagePop');
    const btn = document.getElementById('setupManageBtn');
    if(!pop||!btn) return;
    if(!pop.classList.contains('show')) return;
    const path = e.composedPath ? e.composedPath() : [];
    if(!path.includes(pop) && !path.includes(btn)) closeSetupMgr();
  });

  document.getElementById('copyScenarioBtn')?.addEventListener('click', copyScenarioFromS1);
  document.getElementById('calScenarioSel')?.addEventListener('change', (e)=> changeScenario(e.target.value));
  document.getElementById('atScenarioSel')?.addEventListener('change', (e)=> changeScenario(e.target.value));
  document.getElementById('repScenarioSel')?.addEventListener('change', (e)=> changeScenario(e.target.value));

  // Win/Lose
  $('#winBtn')?.addEventListener('click', ()=> record('win'));
  $('#beBtn')?.addEventListener('click', ()=> record('be'));
  $('#loseBtn')?.addEventListener('click', ()=> record('lose'));

  // Reset day/all
  $('#resetDayBtn')?.addEventListener('click', ()=>{
    const day = getDay(currentDate); if(!day) return;
    const snapshotDaily = deepCloneData(dailyData);
    const snapshotJournal = deepCloneData(journalData);
    pushUndo(()=>{
      dailyData = snapshotDaily;
      journalData = snapshotJournal;
      collectAllJournalTags();
      renderJournalList();
      renderJournalDetail();
      renderBacktestJournal(currentDate);
      updateBacktestView();
      updateReportView();
      saveLocal();
    });
    delete dailyData[currentDate];
    dailyData[currentDate] = { note:'', _events:[], screenshotCleared:true };
    if(journalData?.daily){ delete journalData.daily[currentDate]; }
    try{ idbDeleteShot(currentDate); }catch(e){}
    collectAllJournalTags();
    showToast(`Reset ${dispDate(currentDate)}`);
    updateBacktestView();
    updateScreenshotView();
    updateReportView();
    saveLocal();
  });
  $('#resetAllBtn')?.addEventListener('click', ()=>{
    if(Object.keys(dailyData).length===0) return;
    if(!confirm('Clear ALL data?')) return;
    const snapshot = deepCloneData(dailyData);
    pushUndo(()=>{ dailyData = snapshot; updateBacktestView(); updateReportView(); renderAllTrades(); saveLocal(); });
    dailyData={}; tagCatalog=[];
    journalData = { daily:{}, weekly:{}, custom:[], tags:[] };
    journalFilterTags = [];
    journalSearchText = '';
    selectedJournal = { type:'daily', key:null, entryId:null };
    selectedCustomJournalId = null;
    showToast('All data cleared');
    updateBacktestView();
    updateReportView();
    renderAllTrades();
    renderJournalFilterChips();
    renderJournalModeControls();
    renderJournalList();
    renderJournalDetail();
    saveLocal();
    try{ idbClearDatasetShots(); }catch(e){}
    try{ idbDeletePref('defaultDir'); updateDefaultDirLabel(null); }catch(e){}
  });

  // Keyboard shortcuts
  function isInputFocused(){ const a=document.activeElement; return a && (a.tagName==='INPUT'||a.tagName==='TEXTAREA'||a.tagName==='SELECT'||a.isContentEditable); }
  document.addEventListener('keydown', (e)=>{
    if(isInputFocused()) return;
    const activeTab = document.querySelector('.tabcontent.active')?.id || '';
    if(e.key==='ArrowLeft'){
      e.preventDefault();
      if(activeTab==='tab-calendar'){
        // Back one month
        const [y,m] = (calMonth||new Date().toISOString().slice(0,7)).split('-').map(n=>parseInt(n,10));
        const d = new Date(Date.UTC(y, m-2, 1));
        calMonth = d.toISOString().slice(0,7);
        updateCalendarView(); saveLocal();
      } else if(activeTab==='tab-backtest'){
        const dt=new Date(currentDate); dt.setDate(dt.getDate()-1); currentDate=dt.toISOString().slice(0,10); updateBacktestView(); saveLocal();
      }
      return;
    }
    if(e.key==='ArrowRight'){
      e.preventDefault();
      if(activeTab==='tab-calendar'){
        // Forward one month
        const [y,m] = (calMonth||new Date().toISOString().slice(0,7)).split('-').map(n=>parseInt(n,10));
        const d = new Date(Date.UTC(y, m, 1));
        calMonth = d.toISOString().slice(0,7);
        updateCalendarView(); saveLocal();
      } else if(activeTab==='tab-backtest'){
        const dt=new Date(currentDate); dt.setDate(dt.getDate()+1); currentDate=dt.toISOString().slice(0,10); updateBacktestView(); saveLocal();
      }
      return;
    }
    if(activeTab==='tab-backtest' && e.key==='ArrowUp'){ e.preventDefault(); record('win'); return; }
    if(activeTab==='tab-backtest' && e.key==='ArrowDown'){ e.preventDefault(); record('lose'); return; }
    if(activeTab==='tab-backtest' && (e.key==='b' || e.key==='B')){ e.preventDefault(); record('be'); return; }
    if(activeTab==='tab-backtest' && /^[1-6]$/.test(e.key)){
      const idx = parseInt(e.key,10)-1;
      if(SETUPS[idx]){
        currentSetup = SETUPS[idx]; saveLocal();
        // Reflect in UI if buttons exist
        document.querySelectorAll('#setupSeg [data-setup]')?.forEach(b=> b.classList.remove('active'));
        const btn = document.querySelector(`#setupSeg [data-setup="${currentSetup}"]`);
        if(btn) btn.classList.add('active');
      }
      return;
    }
    if(e.key==='s' || e.key==='S'){ e.preventDefault(); saveToFile(); return; }
    if(e.key==='r' || e.key==='R'){ e.preventDefault(); const day = getDay(currentDate); if(day) $('#resetDayBtn').click(); return; }
  });

  // ===== Analytics Worker =====
  function makeWorker(){
    const src = `
      let rngState = 123456789;
      function setSeed(s){ rngState = (s>>>0) || 123456789; }
      function rand(){ rngState ^= rngState << 13; rngState ^= rngState >>> 17; rngState ^= rngState << 5; return ((rngState>>>0) / 4294967296); }
      function quantile(sorted, q){ if(sorted.length===0) return 0; const pos = (sorted.length-1)*q; const base = Math.floor(pos); const rest = pos-base; return sorted[base] + (sorted[base+1] - sorted[base] || 0)*rest; }
      function wilson(wins, n, z=1.96){
        if(n===0) return [0,0];
        const p = wins/n; const denom = 1 + (z*z)/n;
        const center = (p + (z*z)/(2*n)) / denom;
        const margin = (z*Math.sqrt((p*(1-p))/n + (z*z)/(4*n*n))) / denom;
        return [Math.max(0, center - margin), Math.min(1, center + margin)];
      }
      function blockBootstrapMeans(seq, n, resamples, blockSize){
        const N = seq.length; if(N===0) return [];
        const useBlocks = blockSize>1 && N>=blockSize; const out = new Float64Array(resamples);
        for(let r=0; r<resamples; r++){
          let total=0, k=0;
          if(useBlocks){
            while(k<n){
              const start = Math.floor(rand()*N);
              for(let b=0;b<blockSize && k<n;b++){ total += seq[(start+b)%N]; k++; }
            }
          }else{
            for(k=0;k<n;k++){ total += seq[Math.floor(rand()*N)]; }
          }
          out[r] = total/n;
        }
        return out;
      }
      function mcSim(seq, horizon, sims, blockSize, postProgress){
        const N = seq.length; const useBlocks = blockSize>1 && N>=blockSize;
        const finals = new Float64Array(sims); const maxDDs = new Float64Array(sims);
        const fan = Array.from({length:horizon}, ()=> new Float64Array(sims));
        for(let s=0; s<sims; s++){
          let eq=0, peak=0; let t=0;
          if(useBlocks){
            while(t<horizon){
              const start = Math.floor(rand()*N);
              for(let b=0;b<blockSize && t<horizon;b++){
                eq += seq[(start+b)%N]; peak = Math.max(peak, eq);
                const dd = peak - eq; if(dd>maxDDs[s]) maxDDs[s] = dd;
                fan[t][s] = eq; t++;
              }
            }
          }else{
            for(t=0;t<horizon;t++){
              eq += seq[Math.floor(rand()*N)]; peak = Math.max(peak, eq);
              const dd = peak - eq; if(dd>maxDDs[s]) maxDDs[s] = dd;
              fan[t][s] = eq;
            }
          }
          finals[s] = eq; if(s % 200 === 0) postProgress(s+1, sims);
        }
        return {finals, maxDDs, fan};
      }
      self.onmessage = (e)=>{
        const {type, payload} = e.data;
        if(type==='run'){
          const {seq, wins, trades, resamples, sims, horizon, block, seed} = payload;
          if(seed!==undefined && seed!==null) { rngState = (seed>>>0) || 123456789; }
          const post = (done,total)=> self.postMessage({type:'progress', done, total});
          const bootMeans = blockBootstrapMeans(seq, trades, resamples, block);
          const sortedBoot = Array.from(bootMeans).sort((a,b)=>a-b);
          const expCI = [sortedBoot[Math.floor((sortedBoot.length-1)*0.025)] || 0, sortedBoot[Math.floor((sortedBoot.length-1)*0.975)] || 0];
          const wil = wilson(wins, trades);
          const mc = mcSim(seq, horizon, sims, block, post);
          const finals = Array.from(mc.finals).sort((a,b)=>a-b);
          const dds = Array.from(mc.maxDDs).sort((a,b)=>a-b);
          const q5=[], q50=[], q95=[];
          for(let t=0;t<horizon;t++){
            const arr = Array.from(mc.fan[t]).sort((a,b)=>a-b);
            q5.push(arr[Math.floor((arr.length-1)*0.05)] || 0);
            q50.push(arr[Math.floor((arr.length-1)*0.50)] || 0);
            q95.push(arr[Math.floor((arr.length-1)*0.95)] || 0);
          }
          const expMean = seq.length? (seq.reduce((a,b)=>a+b,0)/seq.length) : 0;
          self.postMessage({type:'done', result:{ expMean, expCI, wil, finals, dds, q5, q50, q95 }});
        }
      };
    `;
    const blob = new Blob([src], {type:'application/javascript'});
    const url = URL.createObjectURL(blob);
    const w = new Worker(url); URL.revokeObjectURL(url);
    return w;
  }

  // ===== Help popovers =====
  (function wireHelpPopovers(){
    let pop = document.createElement('div'); pop.className='help-pop'; document.body.appendChild(pop);
    function show(target){
      const text = target.getAttribute('data-help') || '';
      pop.innerHTML = text; pop.classList.add('show');
      const r = target.getBoundingClientRect();
      pop.style.left = `${r.left + window.scrollX + 10}px`;
      pop.style.top = `${r.bottom + window.scrollY + 8}px`;
    }
    function hide(){ pop.classList.remove('show'); }
    document.addEventListener('mouseover', (e)=>{ const t=e.target.closest('.help'); if(t) show(t); });
    document.addEventListener('mouseout', (e)=>{ if(e.target.closest('.help')) hide(); });
    document.addEventListener('click', (e)=>{ if(!e.target.closest('.help-pop')) hide(); });
  })();

  function anaSetStatus(txt){ $('#anaStatus').textContent = txt || ''; }
  function anaSetProgress(done,total){ const pct = total? Math.floor(done/total*100) : 0; $('#anaProg').style.width = pct+'%'; }
  function quantileFromSorted(arr, q){
    if(arr.length===0) return 0;
    const pos = (arr.length-1)*q; const base = Math.floor(pos); const rest = pos-base;
    return arr[base] + (arr[base+1]-arr[base]||0)*rest;
  }

  function runAnalytics(){
    const useFilter = $('#anaUseFilter').checked;
    const data = useFilter ? filteredData() : dailyData;

    const outcomes = getTradeOutcomes(data);
    const seq = buildTradeSequence(data);
    const trades = outcomes.length;
    if(trades<2){ alert('Need at least 2 trades to run analytics.'); return; }

    const horizon = Math.max(1, parseInt($('#anaHorizon').value||trades,10));
    const sims = Math.max(100, parseInt($('#anaSims').value||10000,10));
    const resamples = Math.max(100, parseInt($('#anaBoot').value||10000,10));
    const block = Math.max(1, parseInt($('#anaBlock').value||1,10));
    const seed = $('#anaSeed').value==='' ? null : parseInt($('#anaSeed').value,10);

    const keyObj = {useFilter, horizon, sims, resamples, block, seed, tradesHash: trades, wins: outcomes.filter(x=>x>0).length};
    const key = JSON.stringify(keyObj);
    if(anaCacheKey === key){ anaSetStatus('Using cached results (same params).'); return; }
    anaCacheKey = key;

    if(!anaWorker){
      anaWorker = makeWorker();
      anaWorker.onmessage = (e)=>{
        const {type, result, done, total} = e.data;
        if(type==='progress'){ anaSetProgress(done,total); return; }
        if(type==='done'){
          anaSetProgress(100,100);
          renderAnalytics(result, trades, outcomes.filter(x=>x>0).length);
          anaSetStatus('Done.');
        }
      };
    }

    $('#anaMeta').textContent = `nTrades=${trades}, horizon=${horizon}, sims=${sims}, resamples=${resamples}, block=${block}, seed=${seed ?? '—'}`;
    anaSetStatus('Running…'); anaSetProgress(0,1);
    anaWorker.postMessage({type:'run', payload:{ seq, wins: outcomes.filter(x=>x>0).length, trades, resamples, sims, horizon, block, seed }});
  }

  function renderAnalytics(res, trades, wins){
    const mean = res.expMean;
    const [lo,hi] = res.expCI;
    $('#ciExp').textContent = `${fmt(mean,3)}  [${fmt(lo,3)}, ${fmt(hi,3)}]`;
    const p = trades? (wins/trades) : 0;
    const [wlo, whi] = res.wil;
    $('#ciWR').textContent = `Win Rate: ${fmt(p*100,2)}%  [${fmt(wlo*100,2)}%, ${fmt(whi*100,2)}%]`;

    if(anaBootChart){ anaBootChart.destroy(); }
    anaBootChart = new Chart($('#bootChart'), {
      type:'line',
      data:{ labels: ['lo','q25','mean','q75','hi'], datasets:[{label:'Bootstrap', data:[lo,(lo+mean)/2,mean,(hi+mean)/2,hi], fill:false, borderWidth:2}] },
      options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ x:{title:{display:true, text:'Statistic'}}, y:{title:{display:true, text:'Expectancy (R/trade)'}} } }
    });

    if(mcFanChart) mcFanChart.destroy();
    mcFanChart = new Chart($('#mcFan'), {
      type:'line',
      data:{
        labels: Array.from({length: res.q50.length}, (_,i)=> i+1),
        datasets:[
          {label:'P95', data: res.q95, borderColor:'#9bd5ff', backgroundColor:'#9bd5ff33', fill:'+1', tension:.15},
          {label:'P50', data: res.q50, borderColor:'#4ea1ff', backgroundColor:'#4ea1ff00', fill:false, tension:.15, borderWidth:2},
          {label:'P05', data: res.q5, borderColor:'#9bd5ff', backgroundColor:'#9bd5ff33', fill:'-1', tension:.15}
        ]
      },
      options:{
        responsive:true, maintainAspectRatio:false,
        plugins:{legend:{labels:{color:'#cfd2e6'}}},
        scales:{ x:{grid:{color:'#2b315d'}, title:{display:true, text:'Trade #', color:'#cfd2e6'}}, y:{grid:{color:'#2b315d'}, title:{display:true, text:'Cumulative R', color:'#cfd2e6'}}}
      }
    });

    const finals = res.finals;
    const fmin = finals[0], fmax = finals[finals.length-1];
    const fBins = 30; const step = (fmax-fmin)/fBins || 1;
    const centers = []; const counts = new Array(fBins).fill(0);
    for(let i=0;i<fBins;i++){ centers.push(fmin + (i+0.5)*step); }
    finals.forEach(v=>{ let idx = Math.floor((v - fmin)/step); idx = clamp(idx,0,fBins-1); counts[idx]++; });
    if(mcFinalHistChart) mcFinalHistChart.destroy();
    mcFinalHistChart = new Chart($('#mcFinalHist'), {
      type:'bar', data:{ labels: centers.map(v=> fmt(v,0)), datasets:[{label:'Final R', data: counts}] },
      options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ x:{title:{display:true, text:'Final R'}}, y:{title:{display:true, text:'Frequency'}} } }
    });

    const dds = res.dds;
    anaLastDDs = Array.isArray(dds) ? dds.slice() : null;
    const dmin = dds[0], dmax = dds[dds.length-1];
    const dBins = 30; const dStep = (dmax-dmin)/dBins || 1;
    const dCenters = []; const dCounts = new Array(dBins).fill(0);
    for(let i=0;i<dBins;i++){ dCenters.push(dmin + (i+0.5)*dStep); }
    dds.forEach(v=>{ let idx = Math.floor((v - dmin)/dStep); idx = clamp(idx,0,dBins-1); dCounts[idx]++; });
    if(mcDDHistChart) mcDDHistChart.destroy();
    mcDDHistChart = new Chart($('#mcDDHist'), {
      type:'bar', data:{ labels: dCenters.map(v=> fmt(v,0)), datasets:[{label:'Max DD (R)', data: dCounts}] },
      options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ x:{title:{display:true, text:'Max Drawdown (R)'}}, y:{title:{display:true, text:'Frequency'}} } }
    });

    const meanFinal = finals.reduce((a,b)=>a+b,0)/finals.length;
    const medFinal = quantileFromSorted(finals, 0.5);
    const lo90 = quantileFromSorted(finals, 0.05);
    const hi90 = quantileFromSorted(finals, 0.95);
    const avgDD = dds.reduce((a,b)=>a+b,0)/dds.length;
    const loDD = quantileFromSorted(dds, 0.05);
    const hiDD = quantileFromSorted(dds, 0.95);
    const negProb = finals.filter(v=>v<0).length / finals.length;

    $('#mcMean').textContent = `${fmt(meanFinal,1)} R`;
    $('#mcRange').textContent = `${fmt(lo90,1)} R  →  ${fmt(hi90,1)} R`;
    $('#mcMedian').textContent = `${fmt(medFinal,1)} R`;
    $('#mcAvgDD').textContent = `${fmt(avgDD,1)} R`;
    $('#mcDDRange').textContent = `${fmt(loDD,1)} R  →  ${fmt(hiDD,1)} R`;
    $('#mcNegProb').textContent = `${fmt(negProb*100,2)}%`;
    // Ruin probability vs threshold
    const thrEl = document.getElementById('anaRuinThresh');
    const thr = Number.isFinite(parseFloat(thrEl?.value)) ? parseFloat(thrEl.value) : anaRuinThresh;
    anaRuinThresh = thr; // keep latest
    const ruin = dds.filter(v=> v >= Math.abs(thr)).length / dds.length;
    const ruinEl = document.getElementById('mcRuinProb'); if(ruinEl) ruinEl.textContent = `${fmt(ruin*100,2)}%`;
  }

  // Wire analytics buttons
  $('#anaRun')?.addEventListener('click', runAnalytics);
  $('#anaClear')?.addEventListener('click', ()=>{
    anaCacheKey = null;
    $('#anaProg').style.width = '0%';
    $('#anaStatus').textContent = '';
    $('#anaMeta').textContent = '—';
    if(anaBootChart){ anaBootChart.destroy(); anaBootChart = null; }
    if(mcFanChart){ mcFanChart.destroy(); mcFanChart = null; }
    if(mcFinalHistChart){ mcFinalHistChart.destroy(); mcFinalHistChart = null; }
    if(mcDDHistChart){ mcDDHistChart.destroy(); mcDDHistChart = null; }
    $('#ciExp').textContent = '—';
    $('#ciWR').textContent = '—';
    $('#mcMean').textContent = '—';
    $('#mcRange').textContent = '—';
    $('#mcMedian').textContent = '—';
    $('#mcAvgDD').textContent = '—';
    $('#mcDDRange').textContent = '—';
    $('#mcNegProb').textContent = '—';
  });

  // ===== Journal UI =====
  function seedJournalFromDailyData(){
    ensureJournalStructure();
    const knownDaily = new Set(Object.keys(journalData.daily||{}));
    Object.keys(dailyData||{}).forEach(date=>{
      const day = dailyData[date];
      const hasEvents = !!(day && Array.isArray(day._events) && day._events.length>0);
      const hasNote = !!(day && day.note && day.note.trim()!=='');
      const hasEntry = knownDaily.has(date);
      if(hasEvents || hasNote || hasEntry){
        ensureDailyJournal(date);
      }
      if(hasEvents || hasNote){
        const weekId = weekIdFromDate(date);
        if(weekId) ensureWeeklyJournal(weekId);
      }
    });
    collectAllJournalTags();
  }

  function getJournalEntry(selection){
    if(!selection) return null;
    ensureJournalStructure();
    if(selection.type==='daily'){
      return ensureDailyJournal(selection.key);
    }
    if(selection.type==='weekly'){
      return ensureWeeklyJournal(selection.key);
    }
    if(selection.type==='custom'){
      const journal = getCustomJournal(selection.key || selectedCustomJournalId);
      if(!journal) return null;
      return journal.entries.find(e=> e.id === selection.entryId) || null;
    }
    return null;
  }

  function entryMatchesFilters(item){
    const search = journalSearchText ? journalSearchText.toLowerCase() : '';
    if(search){
      const text = `${item.entry?.title||''} ${stripHTML(item.entry?.content||'')}`.toLowerCase();
      if(!text.includes(search)) return false;
    }
    if(journalFilterTags.length>0){
      const tags = Array.isArray(item.entry?.tags) ? item.entry.tags : [];
      const ok = journalFilterTags.every(tag=> tags.includes(tag));
      if(!ok) return false;
    }
    return true;
  }

  function buildJournalEntries(){
    seedJournalFromDailyData();
    const out = [];
    if(journalMode==='daily'){
      const dates = new Set([...Object.keys(dailyData||{}), ...Object.keys(journalData.daily||{})]);
      dates.forEach(date=>{
        if(!date) return;
        const entry = ensureDailyJournal(date);
        const day = dailyData[date];
        const hasEvents = !!(day && Array.isArray(day._events) && day._events.length>0);
        const hasNote = !!(day && day.note && day.note.trim()!=='');
        const hasContent = stripHTML(entry?.content||'').trim()!=='' || (entry?.tags||[]).length>0;
        if(hasEvents || hasNote || hasContent){
          out.push({ type:'daily', key: date, entry, stats: computeStatsForDates([date]) });
        }
      });
    } else if(journalMode==='weekly'){
      const weeks = new Set(Object.keys(journalData.weekly||{}));
      Object.keys(dailyData||{}).forEach(date=>{
        const day = dailyData[date];
        const hasEvents = !!(day && Array.isArray(day._events) && day._events.length>0);
        const hasNote = !!(day && day.note && day.note.trim()!=='');
        if(hasEvents || hasNote){
          const wk = weekIdFromDate(date);
          if(wk) weeks.add(wk);
        }
      });
      weeks.forEach(weekId=>{
        if(!weekId) return;
        const entry = ensureWeeklyJournal(weekId);
        const dates = datesForWeek(weekId).filter(d=> dailyData[d]);
        const stats = computeStatsForDates(dates);
        const hasContent = stripHTML(entry?.content||'').trim()!=='' || (entry?.tags||[]).length>0 || stats.trades>0;
        if(hasContent){
          out.push({ type:'weekly', key: weekId, entry, stats, dates });
        }
      });
    } else if(journalMode==='custom'){
      const journal = getCustomJournal(selectedCustomJournalId);
      if(journal){
        selectedCustomJournalId = journal.id;
        journal.entries = journal.entries.map(e=> makeJournalEntry(e));
        journal.entries.forEach(entry=>{
          out.push({ type:'custom', key: journal.id, entryId: entry.id, entry });
        });
      }
    }
    return out;
  }

  function renderJournalFilterChips(){
    const box = document.getElementById('journalTagFilterBox');
    if(!box) return;
    renderChipList(box, journalFilterTags, (tag)=>{
      journalFilterTags = journalFilterTags.filter(t=> t!==tag);
      renderJournalFilterChips();
      renderJournalList();
      saveLocal();
    });
  }

  function renderJournalModeControls(){
    const wrap = document.getElementById('journalModeControls');
    if(!wrap) return;
    wrap.innerHTML='';
    if(journalMode==='daily'){
      const dateVal = (selectedJournal.type==='daily' && selectedJournal.key) ? selectedJournal.key : currentDate;
      wrap.innerHTML = `
        <label>Journal date
          <input type="date" id="journalDailyDate" value="${dateVal||''}">
        </label>
        <button class="btn soft" id="journalDailyGo">Open</button>
        <button class="btn soft" id="journalDailyToday">Today</button>
      `;
      document.getElementById('journalDailyGo')?.addEventListener('click', ()=>{
        const date = document.getElementById('journalDailyDate')?.value || currentDate;
        if(!date) return;
        ensureDailyJournal(date);
        selectJournal({type:'daily', key:date}, {skipList:false});
      });
      document.getElementById('journalDailyToday')?.addEventListener('click', ()=>{
        const today = new Date().toISOString().slice(0,10);
        const inp = document.getElementById('journalDailyDate'); if(inp) inp.value = today;
        ensureDailyJournal(today);
        selectJournal({type:'daily', key:today}, {skipList:false});
      });
    } else if(journalMode==='weekly'){
      const wk = (selectedJournal.type==='weekly' && selectedJournal.key) ? selectedJournal.key : weekIdFromDate(currentDate);
      wrap.innerHTML = `
        <label>Week
          <input type="week" id="journalWeekInput" value="${wk||''}">
        </label>
        <button class="btn soft" id="journalWeekGo">Open</button>
        <button class="btn soft" id="journalWeekCurrent">Current Week</button>
      `;
      document.getElementById('journalWeekGo')?.addEventListener('click', ()=>{
        const val = document.getElementById('journalWeekInput')?.value || '';
        if(!val) return;
        ensureWeeklyJournal(val);
        selectJournal({type:'weekly', key:val}, {skipList:false});
      });
      document.getElementById('journalWeekCurrent')?.addEventListener('click', ()=>{
        const cur = weekIdFromDate(currentDate);
        const inp = document.getElementById('journalWeekInput'); if(inp) inp.value = cur || '';
        if(cur){ ensureWeeklyJournal(cur); selectJournal({type:'weekly', key:cur}, {skipList:false}); }
      });
    } else if(journalMode==='custom'){
      ensureJournalStructure();
      const journals = journalData.custom;
      const has = journals.length>0;
      if(has && !selectedCustomJournalId) selectedCustomJournalId = journals[0].id;
      const options = journals.map(j=> `<option value="${j.id}"${j.id===selectedCustomJournalId?' selected':''}>${j.name}</option>`).join('');
      wrap.innerHTML = `
        ${has ? `<select id="journalCustomSelect">${options}</select>` : '<span class="muted">No personal journals yet.</span>'}
        <button class="btn soft" id="journalCustomAdd">New Journal</button>
        <button class="btn soft" id="journalCustomRename" ${has?'':'disabled'}>Rename</button>
        <button class="btn soft danger" id="journalCustomDelete" ${has?'':'disabled'}>Delete</button>
        <button class="btn soft" id="journalNewEntryBtn" ${has?'':'disabled'}>New Entry</button>
      `;
      document.getElementById('journalCustomAdd')?.addEventListener('click', ()=>{
        const name = prompt('Name for the new journal:', 'My Journal');
        if(name===null) return;
        const journal = addCustomJournal(name);
        selectedCustomJournalId = journal.id;
        createCustomEntry(journal, {title:'New entry'});
        selectJournal({type:'custom', key:journal.id, entryId: journal.entries[0]?.id || null});
        renderJournalModeControls();
        renderJournalList();
        renderJournalDetail();
        saveLocal();
      });
      document.getElementById('journalCustomSelect')?.addEventListener('change', (e)=>{
        const val = e.target.value;
        selectedCustomJournalId = val;
        const journal = getCustomJournal(val);
        if(journal){
          const entry = journal.entries[0] || createCustomEntry(journal, {title:'New entry'});
          selectJournal({type:'custom', key:journal.id, entryId: entry?.id || null});
        }
        saveLocal();
      });
      document.getElementById('journalCustomRename')?.addEventListener('click', ()=>{
        const journal = getCustomJournal(selectedCustomJournalId);
        if(!journal) return;
        const next = prompt('Rename journal:', journal.name);
        if(next===null) return;
        const trimmed = next.trim();
        if(trimmed){ journal.name = trimmed.slice(0,80); renderJournalModeControls(); renderJournalList(); saveLocal(); }
      });
      document.getElementById('journalCustomDelete')?.addEventListener('click', ()=>{
        const journal = getCustomJournal(selectedCustomJournalId);
        if(!journal) return;
        if(!confirm(`Delete journal "${journal.name}"? Entries will be removed.`)) return;
        journalData.custom = journalData.custom.filter(j=> j.id!==journal.id);
        selectedCustomJournalId = journalData.custom[0]?.id || null;
        selectedJournal = { type:'custom', key:selectedCustomJournalId, entryId: journalData.custom[0]?.entries?.[0]?.id || null };
        renderJournalModeControls();
        renderJournalList();
        renderJournalDetail();
        saveLocal();
      });
      document.getElementById('journalNewEntryBtn')?.addEventListener('click', ()=>{
        const journal = getCustomJournal(selectedCustomJournalId);
        if(!journal) return;
        const entry = createCustomEntry(journal, {title:'New entry'});
        selectJournal({type:'custom', key:journal.id, entryId: entry.id});
        renderJournalList();
        renderJournalDetail();
        saveLocal();
      });
    }
  }

  function renderJournalList(){
    const list = document.getElementById('journalList');
    const empty = document.getElementById('journalEmptyState');
    if(!list || !empty) return;
    const entries = buildJournalEntries().filter(entryMatchesFilters);
    entries.sort((a,b)=>{
      const pinA = a.entry?.pinned ? 1 : 0;
      const pinB = b.entry?.pinned ? 1 : 0;
      if(pinA !== pinB) return pinB - pinA;
      if(a.type==='daily' && b.type==='daily') return (b.key||'').localeCompare(a.key||'');
      if(a.type==='weekly' && b.type==='weekly') return (b.key||'').localeCompare(a.key||'');
      const timeA = Date.parse(a.entry?.updatedAt || a.entry?.createdAt || 0);
      const timeB = Date.parse(b.entry?.updatedAt || b.entry?.createdAt || 0);
      return timeB - timeA;
    });
    list.innerHTML='';
    entries.forEach(item=>{
      const el = document.createElement('div');
      el.className = 'journal-item';
      el.dataset.type = item.type;
      el.dataset.key = item.key || '';
      if(item.type==='custom') el.dataset.entryId = item.entryId || '';
      const isSelected = (selectedJournal.type===item.type) && (
        item.type==='custom'
          ? (selectedJournal.entryId===item.entryId && selectedJournal.key===item.key)
          : selectedJournal.key===item.key
      );
      if(isSelected) el.classList.add('active');
      const title = item.entry?.title || (item.type==='daily' ? dispDate(item.key) : item.type==='weekly' ? item.key : 'Untitled');
      let meta='';
      if(item.type==='daily'){
        const stats = item.stats;
        const netTone = stats.netR>0?'var(--green)':stats.netR<0?'var(--red)':'var(--amber)';
        meta = `<span>${dispDate(item.key)}</span><span>${stats.trades} trades</span><span style="color:${netTone}">${fmt(stats.netR,2)}R</span>`;
      } else if(item.type==='weekly'){
        const stats = item.stats;
        const netTone = stats.netR>0?'var(--green)':stats.netR<0?'var(--red)':'var(--amber)';
        const range = getWeekRange(item.key);
        meta = `<span>${range.start} → ${range.end}</span><span>${stats.trades} trades</span><span style="color:${netTone}">${fmt(stats.netR,2)}R</span>`;
      } else {
        const words = countWords(stripHTML(item.entry?.content||''));
        const updated = item.entry?.updatedAt ? new Date(item.entry.updatedAt).toLocaleString() : '';
        meta = `<span>${words} words</span>${updated?`<span>${updated}</span>`:''}`;
      }
      const pin = item.entry?.pinned ? '<span class="journal-pin">★</span>' : '';
      el.innerHTML = `<div class="title">${pin}${title}</div><div class="meta">${meta}</div>`;
      el.addEventListener('click', ()=>{
        if(item.type==='custom'){
          selectJournal({type:'custom', key:item.key, entryId:item.entryId});
        } else {
          selectJournal({type:item.type, key:item.key});
        }
      });
      list.appendChild(el);
    });
    empty.style.display = entries.length===0 ? 'block' : 'none';
    list.scrollTop = 0;
    renderJournalStats(selectedJournal && entries.length>0 ? selectedJournal : null);
  }

  function renderJournalStats(selection){
    const wrap = document.getElementById('journalStatsWrap');
    if(!wrap) return;
    wrap.innerHTML = '';
    if(!selection) return;
    const entry = getJournalEntry(selection);
    if(!entry) return;
    const cards = [];
    if(selection.type==='daily'){
      const stats = computeStatsForDates([selection.key]);
      cards.push({label:'Trades', value: stats.trades});
      cards.push({label:'Win %', value: `${fmt(stats.winRate,1)}%`});
      cards.push({label:'Net R', value: `${fmt(stats.netR,2)}R`, tone: stats.netR>0?'var(--green)':stats.netR<0?'var(--red)':'var(--amber)'});
      cards.push({label:'Expectancy', value: `${fmt(stats.expectancy,2)}R`});
    } else if(selection.type==='weekly'){
      const stats = computeStatsForDates(datesForWeek(selection.key));
      cards.push({label:'Trades', value: stats.trades});
      cards.push({label:'Win %', value: `${fmt(stats.winRate,1)}%`});
      cards.push({label:'Net R', value: `${fmt(stats.netR,2)}R`, tone: stats.netR>0?'var(--green)':stats.netR<0?'var(--red)':'var(--amber)'});
      cards.push({label:'Avg R/Day', value: `${fmt(stats.avgRPerDay,2)}R`});
    } else {
      const plain = stripHTML(entry.content||'');
      cards.push({label:'Words', value: countWords(plain)});
      cards.push({label:'Tags', value: (entry.tags||[]).length});
    }
    cards.forEach(card=>{
      const el = document.createElement('div'); el.className='card';
      el.innerHTML = `<div class="label">${card.label}</div><div class="value" style="color:${card.tone||'inherit'}">${card.value}</div>`;
      wrap.appendChild(el);
    });
  }

  function renderDailyJournalScreenshot(selection, wrap){
    const date = selection?.key;
    if(!date){
      wrap.innerHTML = '<div class="muted">Pick a day to view its screenshot.</div>';
      return;
    }
    const day = getDay(date);
    const shot = day?.screenshot;
    const stats = computeStatsForDates([date]);
    const net = stats.netR || 0;
    const tone = net>0 ? 'var(--green)' : net<0 ? 'var(--red)' : 'var(--amber)';
    const netText = `${net>0?'+':''}${fmt(net,2)}R`;
    if(shot){
      const card = document.createElement('div');
      card.className = 'journal-shot';
      card.innerHTML = `<header><span>${dispDate(date)}</span><span style="color:${tone}; font-weight:700">${netText}</span></header>`;
      const img = document.createElement('img');
      img.src = shot;
      img.alt = `Screenshot for ${dispDate(date)}`;
      img.addEventListener('click', ()=> openCalShot(date));
      card.appendChild(img);
      wrap.appendChild(card);
      return;
    }
    if(day?.screenshotCleared){
      wrap.innerHTML = `<div class="muted">Screenshot cleared for ${dispDate(date)}.</div>`;
      return;
    }
    wrap.innerHTML = '<div class="muted">No screenshot yet. Add one from the Backtest tab.</div>';
    if(typeof getScreenshotForDate === 'function'){
      getScreenshotForDate(date)?.then(url=>{
        if(url){ refreshJournalScreensForDate(date); }
      });
    }
  }

  function renderWeeklyJournalScreenshots(selection, wrap){
    const weekId = selection?.key;
    if(!weekId){
      wrap.innerHTML = '<div class="muted">Pick a week to view its screenshots.</div>';
      return;
    }
    const dates = datesForWeek(weekId);
    if(dates.length===0){
      wrap.innerHTML = '<div class="muted">No trading days in this week.</div>';
      return;
    }
    const shots = [];
    let pending = false;
    dates.forEach(date=>{
      const day = getDay(date);
      if(day?.screenshot){
        shots.push({date, url: day.screenshot});
      } else if(day && !day.screenshotCleared && typeof getScreenshotForDate === 'function'){
        pending = true;
        getScreenshotForDate(date)?.then(url=>{
          if(url){ refreshJournalScreensForDate(date); }
        });
      }
    });
    if(shots.length===0){
      wrap.innerHTML = `<div class="muted">${pending ? 'Loading screenshots for this week…' : 'No screenshots captured for this week yet.'}</div>`;
      return;
    }
    const grid = document.createElement('div');
    grid.className = 'journal-thumb-grid';
    shots.forEach(item=>{
      const box = document.createElement('div');
      box.className = 'journal-thumb';
      const title = document.createElement('strong');
      title.textContent = dispDate(item.date);
      const img = document.createElement('img');
      img.src = item.url;
      img.alt = `Screenshot for ${dispDate(item.date)}`;
      img.addEventListener('click', ()=> openCalShot(item.date));
      const stats = computeStatsForDates([item.date]);
      const net = stats.netR || 0;
      const tone = net>0 ? 'var(--green)' : net<0 ? 'var(--red)' : 'var(--amber)';
      const netEl = document.createElement('span');
      netEl.className = 'net';
      netEl.style.color = tone;
      netEl.textContent = `${net>0?'+':''}${fmt(net,2)}R`;
      box.appendChild(title);
      box.appendChild(img);
      box.appendChild(netEl);
      grid.appendChild(box);
    });
    wrap.appendChild(grid);
  }

  function renderJournalScreenshots(selection, entry){
    const wrap = document.getElementById('journalScreenshotWrap');
    if(!wrap) return;
    wrap.innerHTML = '';
    if(!selection || !entry){
      wrap.innerHTML = '<div class="muted">Select an entry to view screenshots.</div>';
      return;
    }
    if(selection.type==='daily'){
      renderDailyJournalScreenshot(selection, wrap);
    } else if(selection.type==='weekly'){
      renderWeeklyJournalScreenshots(selection, wrap);
    } else {
      wrap.innerHTML = '<div class="muted">Screenshots are available in daily or weekly journals.</div>';
    }
  }

  function refreshJournalScreensForDate(date){
    if(!date) return;
    if(selectedJournal.type==='daily' && selectedJournal.key===date){
      renderJournalScreenshots(selectedJournal, ensureDailyJournal(date));
      return;
    }
    if(selectedJournal.type==='weekly'){
      const wk = weekIdFromDate(date);
      if(wk && selectedJournal.key===wk){
        renderJournalScreenshots(selectedJournal, ensureWeeklyJournal(wk));
      }
    }
  }

  function renderJournalDetail(){
    const titleEl = document.getElementById('journalEntryTitle');
    const editor = document.getElementById('journalEntryEditor');
    const tagBox = document.getElementById('journalTagBox');
    const infoEl = document.getElementById('journalEntryInfo');
    const pinBtn = document.getElementById('journalPinBtn');
    const dupBtn = document.getElementById('journalDuplicateBtn');
    const delBtn = document.getElementById('journalDeleteBtn');
    const fontSel = document.getElementById('journalFontSize');
    if(!titleEl || !editor || !tagBox || !infoEl || !pinBtn) return;
    const entry = getJournalEntry(selectedJournal);
    journalUpdating = true;
    if(!entry){
      titleEl.value = '';
      editor.innerHTML = '';
      editor.setAttribute('contenteditable','false');
      renderChipList(tagBox, [], null);
      infoEl.textContent = 'No entry selected.';
      updatePinButton(pinBtn, false);
      if(dupBtn) dupBtn.style.display = 'none';
      if(delBtn) delBtn.style.display = 'none';
      renderJournalScreenshots(null, null);
      journalUpdating = false;
      return;
    }
    editor.setAttribute('contenteditable','true');
    titleEl.value = entry.title || '';
    editor.innerHTML = entry.content || '';
    editor.style.fontSize = `${journalFontSize}px`;
    if(fontSel){ fontSel.value = String(journalFontSize); }
    const removeMainTag = (tag)=>{
      removeTagFromEntry(entry, tag);
      collectAllJournalTags();
      renderChipList(tagBox, entry.tags||[], removeMainTag);
      renderJournalList();
      saveLocal();
    };
    renderChipList(tagBox, entry.tags||[], removeMainTag);
    const plain = stripHTML(entry.content||'');
    const words = countWords(plain);
    const updated = entry.updatedAt ? new Date(entry.updatedAt).toLocaleString() : new Date().toLocaleString();
    infoEl.textContent = `${words} words • Updated ${updated}`;
    updatePinButton(pinBtn, !!entry.pinned);
    if(dupBtn){ dupBtn.style.display = selectedJournal.type==='custom' ? 'inline-flex' : 'none'; }
    if(delBtn){ delBtn.style.display = selectedJournal.type==='custom' ? 'inline-flex' : 'none'; }
    journalUpdating = false;
    renderJournalScreenshots(selectedJournal, entry);
  }

  function selectJournal(selection, opts={}){
    if(!selection){
      selectedJournal = { type: journalMode, key:null, entryId:null };
      renderJournalDetail();
      renderJournalStats(null);
      return;
    }
    if(selection.type==='custom'){
      selectedCustomJournalId = selection.key;
      const entry = getJournalEntry(selection);
      selectedJournal = { type:'custom', key: selection.key, entryId: entry?.id || selection.entryId || null };
    } else {
      const entry = getJournalEntry(selection);
      selectedJournal = { type: selection.type, key: selection.key, entryId: entry?.id || null };
    }
    if(!opts.skipList) renderJournalList();
    renderJournalDetail();
    renderJournalStats(selectedJournal);
    if(!opts.skipSave) saveLocal();
  }

  function applyJournalFormatting(editor, action){
    if(!editor) return;
    editor.focus();
    try{ document.execCommand('styleWithCSS', false, true); }catch(e){}
    try{
      switch(action){
        case 'bold': document.execCommand('bold'); break;
        case 'italic': document.execCommand('italic'); break;
        case 'underline': document.execCommand('underline'); break;
        case 'strike': document.execCommand('strikeThrough'); break;
        case 'bullet': document.execCommand('insertUnorderedList'); break;
        case 'number': document.execCommand('insertOrderedList'); break;
        case 'quote': document.execCommand('formatBlock', false, 'blockquote'); break;
        case 'h1': document.execCommand('formatBlock', false, 'h1'); break;
        case 'h2': document.execCommand('formatBlock', false, 'h2'); break;
        case 'h3': document.execCommand('formatBlock', false, 'h3'); break;
        case 'clear': document.execCommand('removeFormat'); break;
      }
    }catch(e){ console.warn('Formatting failed', e); }
  }

  function bindJournalToolbar(toolbarId, editorResolver, fontSelectId, sizeKey){
    const toolbar = document.getElementById(toolbarId);
    if(!toolbar) return;
    toolbar.querySelectorAll('button[data-action]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const editor = editorResolver();
        if(!editor) return;
        applyJournalFormatting(editor, btn.getAttribute('data-action'));
        editor.dispatchEvent(new Event('input', {bubbles:true}));
      });
    });
    const fontSel = fontSelectId ? document.getElementById(fontSelectId) : null;
    if(fontSel){
      fontSel.addEventListener('change', ()=>{
        const editor = editorResolver();
        if(!editor) return;
        const size = parseInt(fontSel.value,10);
        if(Number.isFinite(size)){
          editor.style.fontSize = `${size}px`;
          if(sizeKey==='main') journalFontSize = size; else dayJournalFontSize = size;
          saveLocal();
        }
      });
    }
  }

  function syncDayNoteFromEntry(entry){
    if(!entry || !entry.date) return;
    const day = touchDay(entry.date);
    day.note = stripHTML(entry.content||'').slice(0,1000);
  }

  function updatePinButton(btn, pinned){
    if(!btn) return;
    btn.dataset.pinned = pinned ? 'true':'false';
    const label = pinned ? 'Pinned entry' : 'Pin this entry';
    btn.setAttribute('aria-pressed', pinned ? 'true':'false');
    btn.setAttribute('aria-label', label);
    btn.textContent = pinned ? '★' : '☆';
    btn.title = label;
  }

  function renderBacktestJournal(date){
    const titleEl = document.getElementById('dayJournalTitle');
    const editor = document.getElementById('dayJournalEditor');
    const tagBox = document.getElementById('dayJournalTagBox');
    const pinBtn = document.getElementById('toggleDayJournalPin');
    if(!titleEl || !editor || !tagBox || !pinBtn) return;
    const entry = ensureDailyJournal(date);
    journalUpdating = true;
    titleEl.value = entry?.title || '';
    editor.innerHTML = entry?.content || '';
    editor.style.fontSize = `${dayJournalFontSize}px`;
    const fontSel = document.getElementById('dayJournalFontSize'); if(fontSel) fontSel.value = String(dayJournalFontSize);
    const removeDailyTag = (tag)=>{
      removeTagFromEntry(entry, tag);
      collectAllJournalTags();
      renderChipList(tagBox, entry.tags||[], removeDailyTag);
      renderJournalList();
      saveLocal();
    };
    renderChipList(tagBox, entry?.tags||[], removeDailyTag);
    updatePinButton(pinBtn, !!entry?.pinned);
    journalUpdating = false;
    refreshJournalScreensForDate(date);
  }

  function setupDailyJournalUI(){
    bindJournalToolbar('dayJournalToolbar', ()=>document.getElementById('dayJournalEditor'), 'dayJournalFontSize', 'daily');
    const titleEl = document.getElementById('dayJournalTitle');
    const editor = document.getElementById('dayJournalEditor');
    const tagInput = document.getElementById('dayJournalTagInput');
    const pinBtn = document.getElementById('toggleDayJournalPin');
    const openBtn = document.getElementById('openJournalFromBacktest');
    if(titleEl && !titleEl.dataset.bound){
      titleEl.dataset.bound='1';
      titleEl.addEventListener('input', ()=>{
        if(journalUpdating) return;
        const entry = ensureDailyJournal(currentDate);
        entry.title = titleEl.value.slice(0,120);
        entry.updatedAt = new Date().toISOString();
        renderJournalList();
        if(selectedJournal.type==='daily' && selectedJournal.key===currentDate){ renderJournalDetail(); }
        saveLocal();
      });
    }
    if(editor && !editor.dataset.bound){
      editor.dataset.bound='1';
      editor.addEventListener('input', ()=>{
        if(journalUpdating) return;
        const entry = ensureDailyJournal(currentDate);
        entry.content = editor.innerHTML;
        entry.updatedAt = new Date().toISOString();
        syncDayNoteFromEntry(entry);
        renderJournalStats(selectedJournal);
        renderJournalList();
        if(selectedJournal.type==='daily' && selectedJournal.key===currentDate){ renderJournalDetail(); }
        saveLocal();
      });
    }
    if(tagInput && !tagInput.dataset.bound){
      tagInput.dataset.bound='1';
      tagInput.addEventListener('keydown', (e)=>{
        if(e.key==='Enter'){
          e.preventDefault();
          const value = normalizeTag(tagInput.value);
          if(!value) return;
          const entry = ensureDailyJournal(currentDate);
          if(addTagToEntry(entry, value)){
            collectAllJournalTags();
            renderBacktestJournal(currentDate);
            if(selectedJournal.type==='daily' && selectedJournal.key===currentDate){ renderJournalDetail(); }
            renderJournalList();
            renderJournalFilterChips();
            saveLocal();
          }
          tagInput.value='';
        }
      });
    }
    if(pinBtn && !pinBtn.dataset.bound){
      pinBtn.dataset.bound='1';
      pinBtn.addEventListener('click', ()=>{
        const entry = ensureDailyJournal(currentDate);
        entry.pinned = !entry.pinned;
        updatePinButton(pinBtn, entry.pinned);
        if(selectedJournal.type==='daily' && selectedJournal.key===currentDate){ renderJournalDetail(); }
        renderJournalList();
        saveLocal();
      });
    }
    if(openBtn && !openBtn.dataset.bound){
      openBtn.dataset.bound='1';
      openBtn.addEventListener('click', ()=>{
        ensureDailyJournal(currentDate);
        switchTab('journal');
        journalMode = 'daily';
        document.querySelectorAll('#journalModeSeg button').forEach(btn=>{
          const active = btn.getAttribute('data-mode')==='daily';
          btn.classList.toggle('active', active);
          btn.setAttribute('aria-selected', active?'true':'false');
        });
        renderJournalModeControls();
        selectJournal({type:'daily', key:currentDate}, {skipList:false});
      });
    }
  }

  function setupJournalUI(){
    ensureJournalStructure();
    bindJournalToolbar('journalMainToolbar', ()=>document.getElementById('journalEntryEditor'), 'journalFontSize', 'main');
    renderJournalFilterChips();
    renderJournalModeControls();
    renderJournalList();
    renderJournalDetail();

    const seg = document.getElementById('journalModeSeg');
    if(seg){
      seg.querySelectorAll('button').forEach(btn=>{
        const isActive = btn.getAttribute('data-mode') === journalMode;
        btn.classList.toggle('active', isActive);
        btn.setAttribute('aria-selected', isActive ? 'true':'false');
      });
    }
    seg?.querySelectorAll('button').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const mode = btn.getAttribute('data-mode');
        if(!mode) return;
        journalMode = mode;
        seg.querySelectorAll('button').forEach(b=>{
          const active = b===btn;
          b.classList.toggle('active', active);
          b.setAttribute('aria-selected', active?'true':'false');
        });
        if(journalMode!=='custom'){ selectedJournal = {type: journalMode, key:null, entryId:null}; }
        renderJournalModeControls();
        renderJournalList();
        renderJournalDetail();
        saveLocal();
      });
    });

    const searchEl = document.getElementById('journalSearch');
    if(searchEl) searchEl.value = journalSearchText;
    searchEl?.addEventListener('input', ()=>{
      journalSearchText = searchEl.value;
      renderJournalList();
    });

    const filterInput = document.getElementById('journalTagFilterInput');
    filterInput?.addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){
        e.preventDefault();
        const value = normalizeTag(filterInput.value);
        if(!value) return;
        if(!journalFilterTags.includes(value)) journalFilterTags.push(value);
        filterInput.value='';
        renderJournalFilterChips();
        renderJournalList();
        saveLocal();
      }
    });

    document.getElementById('journalClearFilters')?.addEventListener('click', ()=>{
      journalFilterTags = [];
      journalSearchText = '';
      const search = document.getElementById('journalSearch'); if(search) search.value='';
      const filt = document.getElementById('journalTagFilterInput'); if(filt) filt.value='';
      renderJournalFilterChips();
      renderJournalList();
      saveLocal();
    });

    const titleEl = document.getElementById('journalEntryTitle');
    titleEl?.addEventListener('input', ()=>{
      if(journalUpdating) return;
      const entry = getJournalEntry(selectedJournal);
      if(!entry) return;
      entry.title = titleEl.value.slice(0,120);
      entry.updatedAt = new Date().toISOString();
      renderJournalList();
      saveLocal();
    });

    const editor = document.getElementById('journalEntryEditor');
    editor?.addEventListener('input', ()=>{
      if(journalUpdating) return;
      const entry = getJournalEntry(selectedJournal);
      if(!entry) return;
      entry.content = editor.innerHTML;
      entry.updatedAt = new Date().toISOString();
      if(selectedJournal.type==='daily' && entry.date){
        syncDayNoteFromEntry(entry);
        if(entry.date===currentDate){ renderBacktestJournal(currentDate); }
      }
      const infoEl = document.getElementById('journalEntryInfo');
      if(infoEl){
        const plain = stripHTML(entry.content||'');
        const words = countWords(plain);
        infoEl.textContent = `${words} words • Updated ${new Date(entry.updatedAt).toLocaleString()}`;
      }
      renderJournalStats(selectedJournal);
      renderJournalList();
      saveLocal();
    });

    const tagInput = document.getElementById('journalTagInput');
    tagInput?.addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){
        e.preventDefault();
        const entry = getJournalEntry(selectedJournal);
        if(!entry) return;
        const value = normalizeTag(tagInput.value);
        if(!value) return;
        if(addTagToEntry(entry, value)){
          entry.updatedAt = new Date().toISOString();
          collectAllJournalTags();
          renderJournalDetail();
          renderJournalList();
          renderJournalFilterChips();
          if(selectedJournal.type==='daily' && entry.date===currentDate){ renderBacktestJournal(currentDate); }
          saveLocal();
        }
        tagInput.value='';
      }
    });

    document.getElementById('journalPinBtn')?.addEventListener('click', ()=>{
      const entry = getJournalEntry(selectedJournal);
      if(!entry) return;
      entry.pinned = !entry.pinned;
      entry.updatedAt = new Date().toISOString();
      updatePinButton(document.getElementById('journalPinBtn'), entry.pinned);
      renderJournalDetail();
      renderJournalList();
      if(selectedJournal.type==='daily' && entry.date===currentDate){ renderBacktestJournal(currentDate); }
      saveLocal();
    });

    document.getElementById('journalDuplicateBtn')?.addEventListener('click', ()=>{
      if(selectedJournal.type!=='custom') return;
      const journal = getCustomJournal(selectedJournal.key);
      const entry = getJournalEntry(selectedJournal);
      if(!journal || !entry) return;
      const copy = createCustomEntry(journal, {
        title: `${entry.title || 'Entry'} (copy)`,
        content: entry.content,
        tags: entry.tags,
        mood: entry.mood,
        pinned: false
      });
      copy.updatedAt = new Date().toISOString();
      selectJournal({type:'custom', key:journal.id, entryId: copy.id});
      renderJournalList();
      saveLocal();
    });

    document.getElementById('journalDeleteBtn')?.addEventListener('click', ()=>{
      if(selectedJournal.type!=='custom') return;
      const journal = getCustomJournal(selectedJournal.key);
      if(!journal) return;
      if(!confirm('Delete this entry?')) return;
      deleteCustomEntry(journal, selectedJournal.entryId);
      const next = journal.entries[0] || null;
      selectJournal(next ? {type:'custom', key:journal.id, entryId: next.id} : {type:'custom', key:journal.id, entryId:null});
      renderJournalList();
      renderJournalDetail();
      saveLocal();
    });
  }

  // ===== Tabs =====
  function switchTab(name){
    ['backtest','journal','alltrades','calendar','report','analytics','scaling','compare'].forEach(id=>{
      $(`#tabBtn-${id}`).classList.toggle('active', id===name);
      $(`#tabBtn-${id}`).setAttribute('aria-selected', id===name ? 'true':'false');
      $(`#tab-${id}`)?.classList.toggle('active', id===name);
    });
    $('#quickDock')?.classList.toggle('hidden', name!=='backtest');
    if(name==='report'){ applyReportLayout(); updateReportView(); }
    if(name==='alltrades') renderAllTrades();
    if(name==='calendar') updateCalendarView();
    if(name==='scaling'){ updateScalingUI(); refreshScalingTradeCountIfNeeded(); }
    if(name==='journal'){
      renderJournalList();
      renderJournalDetail();
    }
    if(name==='compare'){
      refreshCompareView();
      if(compareChartsDirty) updateCompareCharts(true);
    }
  }
  $('#tabBtn-backtest')?.addEventListener('click', ()=> switchTab('backtest'));
  $('#tabBtn-journal')?.addEventListener('click', ()=> switchTab('journal'));
  $('#tabBtn-alltrades')?.addEventListener('click', ()=> switchTab('alltrades'));
  $('#tabBtn-calendar')?.addEventListener('click', ()=> switchTab('calendar'));
  $('#tabBtn-report')?.addEventListener('click', ()=> switchTab('report'));
  $('#tabBtn-analytics')?.addEventListener('click', ()=> switchTab('analytics'));
  $('#tabBtn-scaling')?.addEventListener('click', ()=> switchTab('scaling'));
  $('#tabBtn-compare')?.addEventListener('click', ()=> switchTab('compare'));

  // ===== Boot =====
  async function boot(){
    loadLocal();
    migrateIfNeeded();
    // Reattach screenshots from IndexedDB for current dataset
    try{ await attachShotsFromDB(); }catch(e){}
    syncTagCatalog();
    // Build tag pickers (compact popovers)
    populateTagSelects();
    setupTagPicker("rep");
    setupTagPicker("repEx");
    setupTagPicker("at");
    setupTagPicker("atEx");
    setupTagPicker("cal");
    setupTagPicker("calEx");
    // Setups UI
    renderSetupButtons();
    populateSetupSelects();
    renderQuickTags();
    wireScreenshot();
    wireReportDrag();
    applyReportLayout();
    // Calendar drag
    wireCalDrag();
    applyCalLayout();
    setupDailyJournalUI();
    setupJournalUI();
    setupCompareTab();
    setupScalingTab();
    syncScenarioControls();
    if(journalMode==='weekly'){
      const defaultDate = currentDate || new Date().toISOString().slice(0,10);
      const wkCandidate = (selectedJournal.type==='weekly' && selectedJournal.key) ? selectedJournal.key : weekIdFromDate(defaultDate);
      const baseDate = new Date(`${defaultDate}T00:00:00Z`);
      const fallbackYear = Number.isFinite(baseDate.getUTCFullYear()) ? baseDate.getUTCFullYear() : new Date().getUTCFullYear();
      const wk = wkCandidate || `${fallbackYear}-W01`;
      if(wk){ ensureWeeklyJournal(wk); selectJournal({type:'weekly', key:wk}, {skipSave:true}); }
      else { ensureDailyJournal(currentDate); selectJournal({type:'daily', key: currentDate}, {skipSave:true}); }
    } else if(journalMode==='custom'){
      let journal = getCustomJournal(selectedCustomJournalId);
      if(!journal){
        journal = addCustomJournal('Personal Journal');
        selectedCustomJournalId = journal.id;
      }
      const entry = journal.entries[0] || createCustomEntry(journal, {title:'New entry'});
      selectJournal({type:'custom', key: journal.id, entryId: entry.id}, {skipSave:true});
    } else {
      journalMode = 'daily';
      ensureDailyJournal(currentDate);
      selectJournal({type:'daily', key: currentDate}, {skipSave:true});
    }
    // Sync Period Net toggle active state
    $$('#periodNetSeg button').forEach(x=>{
      const isActive = x.getAttribute('data-period') === periodNetMode;
      x.classList.toggle('active', isActive);
    });
    // Sync Rolling WR toggle active state
    $$('#rollWinSeg button').forEach(x=>{
      const isActive = parseInt(x.getAttribute('data-n'),10) === rollingWinWindow;
      x.classList.toggle('active', isActive);
    });
    updateBacktestView();
    updateReportView();
    renderAllTrades();
    updateCalendarView();

    // Initialize ruin threshold input
    const rt = document.getElementById('anaRuinThresh');
    if(rt){
      rt.value = (Number.isFinite(anaRuinThresh)? anaRuinThresh : 10);
      rt.addEventListener('change', ()=>{
        const v = parseFloat(rt.value);
        anaRuinThresh = Number.isFinite(v)? v : 10;
        saveLocal();
        if(Array.isArray(anaLastDDs) && anaLastDDs.length){
          const ruin = anaLastDDs.filter(x=> x >= Math.abs(anaRuinThresh)).length / anaLastDDs.length;
          const out = document.getElementById('mcRuinProb'); if(out) out.textContent = `${fmt(ruin*100,2)}%`;
        }
      });
    }

    // (Daily rules removed in v8.13)

    // (Utilities: Position Sizer removed in v8.13)
  }
  document.addEventListener('DOMContentLoaded', boot);
  </script>
</body>
</html>
